C=DECK      SHRRED
C BEG APR 1993
      SUBROUTINE SHRRED(IREDUC,NX,NY,NXY,TX,TY,G,EIG,NPRT,IMOD,JJJ,
C BEG OCT 1996
C BEG NOV 1997
C BEG MAR 2009
     1                  XWAVE,YWAVE,INDEX,NXF,NYF,IKOUNT)
C END MAR 2009
C END NOV 1997
C END OCT 1996
C END APR 1993
C
C  PURPOSE IS TO CALCULATE REDUCTION FACTOR DUE TO TRANSVERSE SHEAR
C  DEFORMATION AND TO MULTILPY EIGENVALUE EIG BY IT.
C
C  IT IS ASSUMED THAT THE REDUCTION FACTOR FOR A PLATE IS THE SAME
C  AS IT IS FOR A TIMOSHENKO BEAM. THE EQUATION FOR THE REDUCTION
C  FACTOR, GIVEN BY TIMOSHENKO AND GOODIER, 2ND ED., P. 132-135, IS:
C
C      REDUCTION FACTOR FOR AXIALLY COMPRESSED WIDE COLUMN =
C            K = 1/[1 + n*N(EULER)/(Teff*Geff)]
C
C  IN WHICH n IS A SHAPE FACTOR (1.2 FOR HOMOGENOUS SHEET); N(EULER)
C  IS THE CRITICAL AXIAL STRESS RESULTANT FROM KIRCHOFF THEORY; Teff
C  IS THE EFFECTIVE WALL THICKNESS (SIMPLY THE TOTAL WALL THICKNESS
C  IN OUR CASE); AND Geff IS THE EFFECTIVE TRANSVERSE SHEAR STIFFNESS.
C
C  FOR A LAYERED MEDIUM, Geff IS ASSUMED TO BE GIVEN BY:
C
C    Geff = Teff/SUM-OVER-i [ t(i)/G13(i) ]
C
C  IN WHICH t(i) IS THE THICKNESS OF THE iTH LAYER AND G13(i) IS THE
C  TRANSVERSE SHEAR STIFFNESS OF THE iTH LAYER MEASURED IN THE AXIAL-
C  CIRCUMFERENTIAL COORDINATE SYSTEM.
C
C BEG NOV 1997
C  WE ASSUME THAT THE KNOCKDOWN FACTOR, KSTAR, IS THE MINIMUM OF
C
C              Kx, Ky, Kxy
C END NOV 1997
C
C  IN WHICH Kx IS THE KNOCKDOWN FACTOR FOR COMPRESSION IN THE X-DIR.;
C  Ky THE FACTOR FOR COMPRESSION IN THE Y-DIR.; Kxy THE FACTOR FOR
C  IN-PLANE SHEAR.
C
C  INPUT DATA...
C
C  IREDUC   0 MEANS DON'T REDUCE EIG BY THE TRANSVERSE SHEAR DEFORMATION
C             REDUCTION FACTOR.
C           1 MEANS YES,  REDUCE EIG
C      NX   AXIAL RESULTANT ("EIGENVALUE" LOAD COMPONENT)
C     NXF   AXIAL RESULTANT ("FIXED" LOAD COMPONENT)
C      NY   CIRC. RESULTANT ("EIGENVALUE" LOAD COMPONENT)
C     NYF   CIRC. RESULTANT ("FIXED" LOAD COMPONENT)
C     NXY   IN-PLANE SHEAR RESULTANT
C      TX   EFFECTIVE THICKNESS OF ONE OF SEGMENTS OR ASSEMBLY OF THE
C           STRINGER-SKIN MODULE
C      TY   EFFECTIVE THICKNESS OF ONE OF SEGMENTS OR ASSEMBLY OF THE
C           RING-SKIN MODULE
C       G   EFFECTIVE TRANSVERSE SHEAR STIFFNESS COMPONENTS
C     EIG   BUCKLING EIGENVALUE FROM "EULER" (KIRCHOFF) THEORY.
C   XWAVE   LENGTH OF BUCKLING WAVE IN X-DIRECTION
C   YWAVE   LENGTH OF BUCKLING WAVE IN Y-DIRECTION
C BEG OCT 1996
C   INDEX   0 means largest permissible value of COMBO is 0.7
C           1 means largest permissible value of COMBO is 0.9
C
C  OUTPUT DATA...
C
C     EIG   BUCKLING EIGENVALUE AS REDUCED TO ACCOUNT APPROXIMATELY
C           FOR TRANSVERSE SHEAR DEFORMATION.
C
C BEG JUL 2010
      COMMON/GEOM3/ISTIF(2),NLAYER(4,2),NSEG(2),INTEXT(2)
C END JUL 2010
C BEG JAN 2010
      COMMON/ICONSX/ICONSV
C END JAN 2010
C BEG DEC 2009
      COMMON/ILABLZ/ILABLW
C END DEC 2009
C BEG MAR 2007
      COMMON/ILABLX/ILABLY
      COMMON/SHRFCX/SHRFAC,SMRFAC
C END MAR 2007
      COMMON/KSTARR/EIGOLD,KSTAR
C BEG NOV 1997
      COMMON/IIIROL/IROLL,IPRELM,IQUICK
      REAL N, NX,NY,NXY, KX,KY,KXY,KSTAR, NXF, NYF
C END NOV 1997
      DIMENSION G(*)
      KSTAR = 1.0
C BEG NOV 1997
C     EIGOLD= EIG
C END NOV 1997
C BEG MAR 2007
      SHRFAC = 1.0
C END MAR 2007
      IF (IREDUC.EQ.0) RETURN
C BEG JUN 1999
      IF (EIG.GE.10.E+15) RETURN
C END JUN 1999
C
      N = 1.2
C
C BEG NOV 1997
C BEG MAR 2009
      TGS1 = TX*G(1)
      TGS2 = TY*G(2)
      TGS  = MIN(TGS1,TGS2)
C BEG JAN 2010
C BEG JUL 2010
C     IF (ICONSV.LE.0) THEN
      IF (ICONSV.LE.0.AND.ISTIF(1).NE.5) THEN
         KX = 1./(1. + N*ABS(NXF+NX*EIG)/(TX*G(1)))
         KY = 1./(1. + N*ABS(NYF+NY*EIG)/(TY*G(2)))
      ELSE
         KX = 1./(1. + N*ABS(NXF+NX*EIG)/TGS)
         KY = 1./(1. + N*ABS(NYF+NY*EIG)/TGS)
      ENDIF
C END JAN 2010
C END MAR 2009
C BEG MAR 2007
C     IF (ILABLY.EQ.9255) THEN
C        WRITE(8,'(A,1P,4E12.4)')' TX,TY,G(1),G(2)=',
C    1                             TX,TY,G(1),G(2)
C        WRITE(8,'(A,/,1P,6E12.4)')' N,NXF,NX,NYF,NY,NXY=',
C    1                               N,NXF,NX,NYF,NY,NXY
C     ENDIF
C END MAR 2007
C END NOV 1997
C BEG MAR 2009 (Next three commented out. They were moved up.)
C     TGS1 = TX*G(1)
C     TGS2 = TY*G(2)
C     TGS  = MIN(TGS1,TGS2)
C END MAR 2009
C BEG APR 1993
C     IF (XWAVE.GT.0.0.AND.YWAVE.GT.0.0) THEN
C        TXWAVE = TX/XWAVE
C        TYWAVE = TY/YWAVE
C        TSUM   = TXWAVE + TYWAVE
C        TGS = (TXWAVE*TGS1 + TYWAVE*TGS2)/TSUM
C        WRITE(8,*) ' TGS1,TGS2,TGS=',TGS1,TGS2,TGS
C        WRITE(8,*) ' TX,XWAVE,TY,YWAVE=',TX,XWAVE,TY,YWAVE
C     ENDIF
C END APR 1993
      KXY= 1./(1. +N*ABS(NXY)*EIG/TGS)
C
C BEG NOV 1997  Test cases show that the expression for COMBO is no good.
C     COMBO = (1. - KX)**2 + (1. - KY)**2 + (1. - KXY)**2
C BEG OCT 1996
C     COMBIG = 0.7
C     IF (INDEX.EQ.1) COMBIG = 0.9
C     IF (COMBO.GE.COMBIG) COMBO = COMBIG
C END OCT 1996
C     KSTAR = 1. - SQRT(COMBO)
C     EIG   = KSTAR*EIG
C
C  KSTAR is now computed as follows:
      KSTAR = MIN(KX,KY)
      KSTAR = MIN(KSTAR,KXY)
      EIGX = 10.E+16
      EIGY = 10.E+16
      EIGXY= 10.E+16
      IF (NX.LT.0.0) EIGX = ABS(((NXF +EIG*NX)*KX - NXF)/NX)
      IF (NY.LT.0.0) EIGY = ABS(((NYF +EIG*NY)*KY - NYF)/NY)
      EIGXY = ABS(EIG*KXY)
C     WRITE(8,'(A,1P4E12.4)')' KX,KY,KXY,KSTAR=',KX,KY,KXY,KSTAR
C     WRITE(8,'(A,/,1P5E12.4)')' EIG,KSTAR,EIGX,EIGY,EIGXY=',
C    1                           EIG,KSTAR,EIGX,EIGY,EIGXY
      EIGMIN = MIN(EIGXY,EIGX)
      EIGMIN = MIN(EIGMIN,EIGY)
C     KSTAR = EIGMIN/EIG         (NOTE: This line is commented out.)
      EIGINP = EIG
      EIG = EIGMIN
      IF (IPRELM.EQ.2) EIG = EIGINP*KSTAR
C END NOV 1997
C BEG APR 2007
      IF (G(1).LE.0.0.OR.G(2).LE.0.0.OR.EIG.LE.0.0) THEN
      WRITE(8,'(A,/,A,2I5,1P,4E12.4,/,A,1P,3E12.4,/,A,1P,4E12.4,/,A)')
     1' Eigenvalue after t.s.d. may be less than or equal to zero.',
     1' IKOUNT,ILABLY,TX,TY,G(1),G(2)=',IKOUNT,ILABLY,TX,TY,G(1),G(2),
     1' EIGX, EIGY, EIGXY   =',EIGX,EIGY,EIGXY,
     1' KX, KY, KXY, KSTAR  =',KX,KY,KXY,KSTAR,
     1' Output eigenvalue is therefore set equal to input eigenvalue'
         EIG = EIGINP
      ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
C END APR 2007
C
C BEG MAR 2007
C BEG MAR 2009
C BEG DEC 2009
      IF (NPRT.GE.2.AND.ILABLY.EQ.9260.AND.ILABLW.EQ.7185) THEN
         WRITE(8,5) EIGINP,KSTAR,EIG
    5 FORMAT(/,' In SUBROUTINE SHRRED',/,
     1' Knockdown due to transverse shear deformation:',/,
     1' (Kirchoff theory value=',1PE10.2,')x(knockdown=',1PE10.2,
     1')=(final=',1PE11.3,')')
C
         WRITE(8,*)' TX,TY,G(1),G(2)=',TX,TY,G(1),G(2)
         WRITE(8,*)' KX,KY,TGS,KXY=', KX,KY,TGS,KXY
         WRITE(8,*)' N,NX,NY,NXY,EIG=',N,NX,NY,NXY,EIG
      ENDIF
C END DEC 2009
C END MAR 2009
C END MAR 2007
C BEG OCT 1998
      IF (NPRT.GE.2) WRITE(8,'(A,1P,E12.4,A,1P,E12.4)')
     1' Buckling load factor before t.s.d.=',EIGINP,' After t.s.d.=',EIG
C BEG DEC 2009
      IF (NPRT.GE.2) WRITE(8,'(A,/)') ' Leaving SUBROUTINE SHRRED'
C END DEC 2009
C BEG MAR 2007
      SHRFAC = ABS(EIG/EIGINP)
C END MAR 2007
C23456789012345678901234567890123456789012345678901234567890123456789012
C END OCT 1998
C
      RETURN
      END
C
C
C
C=DECK      MATMS4
      SUBROUTINE MATMS4(B,A,C,K,J,IZERO)  
C     
C     CALLED FROM BOTH PRESTS AND STABIL (LINKS 2 AND 3). SIMILAR TO    
C     MATMU2 EXCEPT FOR ONE STATEMENT  AFTER LABEL 50.
C     WE FORM THE PRODUCT C = A(TRANSPOSE)XBXA, WHERE B IS SYMMETRIC    
c     If IZERO is 1, then C = C + A'xBxA.  For the non-cray versions,
c     C = Cold + LowerTri(A'xBxA) if IZERO = 1, and C = LowerTri(A'xBxA)
c     otherwise.
C     
      DIMENSION B(K,K),A(K,J),C(J,J)
#if cray
       real e
       dimension D(MAX(K,J), MAX(K,J)), e(J, J)
       integer m, n
 
       call mover(0.0, 0, D, 1, MAX(K,J)*MAX(K,J))
       call mxm(B, K, A, K, D, J)
       call mxma(A, K, 1, D, 1, K, e, J, 1, J, K, J)
       if (IZERO .eq. 1) then
         do 10 m = 1, J
         do 10 n = 1, m
           C(m, n) = C(m, n) + e(m, n)
   10   continue
       else
         call mover(e, 1, C, 1, J*J)
       endif
#else
      DIMENSION D(7,7)
      DO 10 KK=1,K
      DO 10 JJ=1,J
      D(KK,JJ) = 0.0    
10    CONTINUE    
      DO 30 KK=1,K
      DO 30 JJ=1,J
      DO 20 LL=1,K
      D(KK,JJ) = D(KK,JJ) + B(KK,LL)*A(LL,JJ)   
20    CONTINUE    
30    CONTINUE    
      IF (IZERO.EQ.1) GO TO 50
      DO 40 II=1,J
      DO 40 JJ=1,J
      C(II,JJ) = 0.0    
40    CONTINUE    
50    DO 70 II=1,J
      DO 70 JJ=1,II     
      DO 60 KK=1,K
      C(II,JJ) = C(II,JJ) + A(KK,II)*D(KK,JJ)   
60    CONTINUE    
70    CONTINUE    
#endif
      RETURN
      END   
C
C
C
C=DECK      MINM  
      SUBROUTINE MINM(A,B,NXEIG,NYEIG,NXYEIG,CSLOPE,IDESGN,MBAR,NBAR,
C BEG MAR 1998
C BEG APR 1998
     1 EIGVAL,INDX,EIG,PARX1,PARX2,FFLAT,IAGAIN,MNCHEK,EIGCHK,CSLCHK,
     1 ITESTY)
C END APR 1998
C END MAR 1998
C     
C     PURPOSE IS TO FIND CRITICAL NUMBER OF HALFWAVES M IN THE AXIAL    
C     DIRECTION.  
C     
C        MBAR = M = NUMBER OF AXIAL HALF-WAVES  
C      EIGVAL = CURRENT VALUE OF EIGENVALUE.    
C     
C BEG MAR 1998
      DIMENSION MNCHEK(50,10),CSLCHK(50,10),EIGCHK(50,10)
C END MAR 1998
C BEG FEB 1996
      COMMON/IRESTX/IRESTY
C END FEB 1996
      COMMON/MMAXWV/MMAX
      REAL NXEIG,NYEIG,NXYEIG,MBAR,NBAR,MBARS,MBARP,MBARM   
      EXTERNAL EIG
      EIGVM = 2.*EIGVAL 
      MBARS = MBAR
      M = MBAR    
      IPRCNT = 0.1*MBAR
      PRCNTM = IPRCNT
      PRCNTM = AMAX1(1.0, PRCNTM)
      SLOPE = CSLOPE    
      MBARP = MBAR + PRCNTM   
C BEG APR 1998
      IF (IDESGN.EQ.0) SLOPE = 0.0
C END APR 1998
      CALL EIG(A,B,NBAR,MBARP,NXEIG,NYEIG,NXYEIG,SLOPE,IDESGN,EIGVP,    
     1 INDX,FFLAT,IAGAIN,0)
C BEG MAR 1998
C BEG APR 1998
      IF (ITESTY.EQ.0) THEN
         I = MBARP
         J = NBAR
C BEG MAY 1998
C BEG OCT 2001
         IF (J.GT.0.AND.I.LE.50.AND.J.LE.10.AND.I.GT.0) THEN
C END OCT 2001
          IF (MNCHEK(I,J).EQ.0) THEN
            MNCHEK(I,J) = 1
            EIGCHK(I,J) = EIGVP
            CSLCHK(I,J) = SLOPE
          ENDIF
         ENDIF
C END MAY 1998
      ENDIF
C END APR 1998
C END MAR 1998
C BEG FEB 1996
      IF (IRESTY.EQ.1) GO TO 2222
C END FEB 1996
      IF (EIGVP.GT.EIGVAL) GO TO 10 
      INCR =  PRCNTM     
      SINCR = 1.0 
      FINCR = INCR
      EIGVAL = EIGVP    
      CSLOPE = SLOPE    
C     
      GO TO 30    
   10 CONTINUE    
      IF (M.EQ.1) GO TO 100
      SLOPE = CSLOPE    
      MBARM = MBAR - PRCNTM   
C BEG FEB 1006
      IF (M.GT.1) THEN
C BEG APR 1998
       IF (IDESGN.EQ.0) SLOPE = 0.0
C END APR 1998
       CALL EIG(A,B,NBAR,MBARM,NXEIG,NYEIG,NXYEIG,SLOPE,IDESGN,EIGVM,   
     1 INDX,FFLAT,IAGAIN,0)
C BEG MAR 1998
C BEG APR 1998
C23456789012345678901234567890123456789012345678901234567890123456789012
       IF (ITESTY.EQ.0) THEN
          I = MBARM
          J = NBAR
C BEG MAY 1998
C BEG OCT 2001
          IF (J.GT.0.AND.I.LE.50.AND.J.LE.10.AND.I.GT.0) THEN
C END OCT 2001
           IF (MNCHEK(I,J).EQ.0) THEN
             MNCHEK(I,J) = 1
             EIGCHK(I,J) = EIGVM
             CSLCHK(I,J) = SLOPE
           ENDIF
          ENDIF
C END MAY 1998
       ENDIF
C END APR 1998
C END MAR 1998
       IF (IRESTY.EQ.1) GO TO 2222
      ENDIF
C END FEB 1996
      IF (EIGVM.GT.EIGVAL.OR.M.LE.1) GO TO 100  
      INCR =  -PRCNTM    
      SINCR = -1.0
      FINCR = INCR
      EIGVAL = EIGVM    
      CSLOPE = SLOPE    
C 
C BEG APR 1998
   30 CONTINUE    
      MBAR = MBAR + FINCR     
      KOUNT = 0
   35 CONTINUE
      KOUNT = KOUNT + 1
      MBARS = MBAR
C END APR 1998
      MBAR = MBAR + FINCR     
      M = MBAR    
      IF (M.LE.1) GO TO 100   
      IF (M.GT.MMAX.AND.EIGVAL.EQ.10.E16) GO TO 100   
C BEG DEC 1998
      IF (M.GT.10000) GO TO 100
C END DEC 1998
C     
      SLOPE = CSLOPE    
C BEG MAR 1998
      IF (IDESGN.EQ.0) THEN
         IF (MBAR.LT.3.) SLOPE = 0.0
C BEG APR 1998
         MMOD = MOD(KOUNT,3)
         IF (MMOD.EQ.0) SLOPE = 0.
C END APR 1998
      ENDIF
C END MAR 1998
      CALL EIG(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,SLOPE,IDESGN,     
     1 EIGV,INDX,FFLAT,IAGAIN,0) 
C BEG MAR 1998
C BEG APR 1998
      IF (ITESTY.EQ.0) THEN
         I = MBAR
         J = NBAR
C BEG MAY 1998
C BEG OCT 2001
         IF (J.GT.0.AND.I.LE.50.AND.J.LE.10.AND.I.GT.0) THEN
C END OCT 2001
          IF (MNCHEK(I,J).EQ.0) THEN
            MNCHEK(I,J) = 1
            EIGCHK(I,J) = EIGV
            CSLCHK(I,J) = SLOPE
          ENDIF
         ENDIF
C END MAY 1998
      ENDIF
C END APR 1998
C END MAR 1998
C BEG FEB 1996
      IF (IRESTY.EQ.1) GO TO 2222
C END FEB 1996
      IF (EIGV.GT.EIGVAL) GO TO 100 
      PRCNTM = 0.1*MBAR 
      INCR =(1.0 + PRCNTM)*SINCR    
      FINCR = INCR
      EIGVAL = EIGV     
      CSLOPE = SLOPE    
      GO TO 35    
C     
  100 CONTINUE    
      MBAR = MBARS
C BEG FEB 1996
 2222 CONTINUE
C END FEB 1996
      RETURN
      END   
C
C
C
C=DECK      ALSUM 
      SUBROUTINE ALSUM  
C     
C     PURPOSE IS TO FIND ASSUM,ASSUM3,ARSUM,ARSUM3 FOR STIFFENERS.
C     THESE QUANTITTIES ARE USED IN THE CALCULATION OF THICKNESSES
C     OF END SEGMENTS OF STIFFENERS. (SUBROUTINE STIFF)     
C     
      DIMENSION SUM(9),SUM3(9)
      COMMON/STR2/ NPARTS,NSEGS(9),NENDS(9)     
      COMMON/RNG2/ NPARTR,NSEGR(9),NENDR(9)     
      COMMON/STR/E11S(9),E12S(9),E22S(9),GS(9),ALS(9),ASSUM(9),ASSUM3(9)
      COMMON/RNG/E11R(9),E12R(9),E22R(9),GR(9),ALR(9),ARSUM(9),ARSUM3(9)
C     
C     
C     FIRST, FIND THE REQUIRED SUMS FOR STRINGERS...  
C     
      IF (NPARTS.EQ.0) GO TO 105    
      DO 10 I = 1,9     
      SUM(I) = 0.0
   10 SUM3(I) = 0.0     
C     
      DO 50 I = 1,NPARTS
      ASSUM3(I) = 0.0   
      ASSUM(I) = 0.0    
      IF (NENDS(I).EQ.0) GO TO 50   
      J = NSEGS(I) +1   
      SUM3(J) = SUM3(J) + ALS(I)**3 
      SUM(J)  = SUM(J)  + ALS(I)    
   50 CONTINUE    
C     
      DO 100 I = 1,NPARTS     
      IF (NENDS(I).EQ.0) GO TO 100  
      J = NSEGS(I) + 1  
      ASSUM3(I) = SUM3(J)     
       ASSUM(I) = SUM(J)
  100 CONTINUE    
  105 CONTINUE    
C     
C     NOW DO THE SAME FOR RINGS...  
C     
      IF (NPARTR.EQ.0) GO TO 300    
      DO 115 I = 1,9    
      SUM(I) = 0.0
  115 SUM3(I) = 0.0     
      DO 150 I = 1,NPARTR     
      ARSUM3(I) = 0.0   
      ARSUM(I) = 0.0    
      IF (NENDR(I).EQ.0) GO TO 150  
      J = NSEGR(I) + 1  
      SUM3(J) = SUM3(J) + ALR(I)**3 
      SUM(J)  = SUM(J)  + ALR(I)    
  150 CONTINUE    
C     
      DO 200 I = 1,NPARTR     
      IF (NENDR(I).EQ.0) GO TO 200  
      J = NSEGR(I) + 1  
      ARSUM3(I) = SUM3(J)     
       ARSUM(I) =  SUM(J)     
  200 CONTINUE    
  300 CONTINUE    
      RETURN
      END   
C
C
C
C=DECK      BEND  
      SUBROUTINE BEND(EIGVAL,NBAR,RAD,NPART,NSEG,NEND,ANGL, 
     1 RPRE,RESLT,AL,C11,D11,D12,D22,GJ,ISTIF,DOC)
C     
C     PURPOSE IS TO OBTAIN BUCKLING FOR STIFFENER ROLLING WITHOUT PARTI-
C     CIPATION OF THE SKIN.   
C     
      DIMENSION NSEG(9),NEND(9),ANGL(9),RPRE(9),RESLT(9),AL(9),C11(9)   
      DIMENSION D11(9),D12(9),D22(9),GJ(9)
      REAL NBAR
      DOUBLE PRECISION N2,N4,C22FLN,PRE,EIG,B3,B,F1P,F2P,F1E,F2E
      DOUBLE PRECISION F3,F4,F5,C44WEB,FL,FL2,FL3,FL4,FCL,E,TE,PREW
      DOUBLE PRECISION EIGW,RAVE,P1,E1,P2,E2,C45WEB,C55WEB,GJWEB
      DOUBLE PRECISION Q1,Q2,Q3,S1,S2,C1,C2,C25,C3,C4,C5,C6,C7,C8
      DOUBLE PRECISION A1,A2,A3,B1,B2,A,C,DISCRM,SDIS
C     
      EIGVAL = 10.E16   
      PI = 3.1415927    
      IF (NPART.EQ.0) RETURN  
      IF (ISTIF.EQ.4) RETURN
      FIOUT = -1.0
      TOL = 0.0001
C     
      DO 100 I = 1,NPART
C
      J = I 
      IF (NSEG(I).NE.0) GO TO 100   
      ATEST = 0.  
      CALL DIFF(ANGL(I),ATEST,DIFF1)
      IF (DIFF1.LT.TOL) GO TO 50    
      ATEST = PI  
      ABSANG = ABS(ANGL(I))   
      CALL DIFF(ABSANG,ATEST,DIFF1) 
      IF (DIFF1.LT.TOL) GO TO 60    
  100 CONTINUE    
      RETURN
C     
   50 CONTINUE    
C     OUTSIDE STIFFENER...    
      FIOUT = 1.0 
   60 CONTINUE    
C     
C     
      J1 = J + 1  
C     
      F1P = 0.    
      F2P = 0.    
      F1E = 0.    
      F2E = 0.    
      F3 = 0.     
      F4 = 0.     
      F5 = 0.     
      RFLNGE = RAD+FIOUT*AL(J)
C     
      IF (J1.GT.NPART) GO TO 210    
      DO 200 I = J1,NPART     
      IF (NSEG(I).NE.J) GO TO 200   
C     
C     THE STIFF SEGMENT IS ATTACHED TO THE END OF A WEB...  
C     
      ATEST = PI/2.     
      ABSANG = ABS(ANGL(I))   
      CALL DIFF(ABSANG,ATEST,DIFF1) 
      IF (DIFF1.GT.TOL) GO TO 200   
C     
C     THIS STIFF SEGMENT IS AT + OR - PI/2 AND IS ATTACHED TO THE WEB...
C     
      C22FLN = C11(I)    
C     
      PRE = RPRE(I)     
      EIG = RESLT(I) - RPRE(I)
      B3 = AL(I)**3/3.  
      B = AL(I)   
      F1P = F1P + PRE*B3
      F2P = F2P + PRE*B 
      F1E = F1E + EIG*B3
      F2E = F2E + EIG*B 
      F3 = F3 + C22FLN*B3     
      F4 = F4 + B3*D11(I)
      F5 = F5 + B*GJ(I)
C     
C     WRITE(8,10) I,NPART,ISTIF,NSEG(I),NEND(I),
C    1            C11(I),D11(I),D12(I),D22(I),GJ(I),
C    1            ANGL(I),AL(I),RAD,NBAR,
C    1            RPRE(I),RESLT(I),PRE,EIG,
C    1            F1P,F2P,F1E,F2E,F3,F4,F5
   10 FORMAT(' STIFFENER PARAMETERS ENTERING SUBROUTINE BEND...'/
     1' I,NPART,ISTIF,NSEG,NEND =',5I5/
     1' C11,D11,D12,D22,GJ      =',1P,5E12.4/
     1' ANGL,AL,RAD,NBAR        =',1P,4E12.4/
     1' RPRE,RESLT,PRE,EIG      =',1P,4E12.4/
     1' F1P,F2P,F1E,F2E,F3,F4,F5=',1P,7E12.4)
C
  200 CONTINUE    
C     
  210 CONTINUE    
      C44WEB = D22(J)
      FL = AL(J)  
      FL2 = FL*FL 
      FL3 = FL2*FL
      FL4 = FL3*FL
      FCL = 4.*C44WEB/FL3
      E = - FIOUT*FL/RFLNGE   
      TE = 2. + E 
      PREW = RPRE(J)    
      EIGW = RESLT(J) - RPRE(J)     
      RAVE = RAD + FIOUT*FL/2.
      N2 = NBAR*NBAR    
      N4 = N2*N2  
C     
C     DIVIDE ALL ENERGY TERMS GIVEN IN EQS.(113) BY B(WEB)**4 IN
C     ORDER TO AVOID OVERFLOW OR UNDERFLOW IN THE VAX.
C
      P1 = -FIOUT*PREW/(3.*RAVE)
      E1 = -FIOUT*EIGW/(3.*RAVE)
      P2 = 0.2*N2*PREW*FL    
      E2 = 0.2*N2*EIGW*FL    
      C45WEB = D12(J)
      C55WEB = D11(J)
      GJWEB = 4.*GJ(J)
C     
      Q1 = 0.2*FL*(C55WEB*N4 +GJWEB*N2/RAVE**2)
      Q2 = -FIOUT*N2*(C55WEB +GJWEB)/RAVE   
      Q3 = (C55WEB/RAVE**2 +GJWEB*N2)/(3.*FL)    
C     
      S1 = 4.*C45WEB*NBAR*NBAR/(3.*FL)     
      S2 = FIOUT*4.*C45WEB/(RAVE*FL2) 
C     
C     DIVIDE ALL ENERGY TERMS GIVEN IN EQS(121) BY B(WEB)**4 IN
C     ORDER TO AVOID OVERFLOW OR UNDERFLOW ON THE VAX.
C
      C1 = N2/FL2 
      C2 = C1*TE*TE     
      C25 = FIOUT/(3.*RFLNGE*FL)   
      C3 = C1*FL2 - 4.*C25    
      C4 = C1 + 2.*E/FL4    
      C5 = C1*(N2*F4 + 4.*F5) 
      C6 = C1*2.*TE     
      C7 = F2P*C25
      C8 =-F2P*0.4*C25  
C     
      A1 = P1 +P2 +FCL +Q1+Q2 +4.*Q3 +F1P*C2 +F2P*C3 +F3*C4*C4*FL4
     1 +C5*TE**2 - S1 + S2
      A2 = .2*P1 +P2/3. -FCL +Q1/3.-Q3 -F1P*C6 -F3*2.*E*C4 -C5*2.*TE +C7
     1  + S1 - S2 
      A3 = .1*P1 +P2/21. +FCL +Q1/21. +.4*Q3 +F1P*C1 +F3*E*E/FL4    
     1 +C5 + C8 + S1/5. + S2/4.
C     
      B1 = E1 +E2 +F1E*C2 +F2E*C3   
      B2 = .2*E1 + E2/3. -F1E*C6 + F2E*C25
      B3 = .1*E1 + E2/21. + F1E*C1 - F2E*0.4*C25
C     
      A = B1*B3 - 0.25*B2*B2  
      B = A1*B3 + B1*A3 - 0.5*A2*B2 
      C = A1*A3 - 0.25*A2*A2  
C     
      DISCRM = B*B - 4.*A*C   
      IF (DISCRM.LT.0.) RETURN
      SDIS = DSQRT(DISCRM)     
      RATIO1 = 10.E16
      RATIO2 = 10.E16
      IF (A.NE.0.) THEN
         RATIO1 = (-B + SDIS)/(2.*A)   
         RATIO2 = (-B -SDIS)/(2.*A)    
      ENDIF
C     WRITE(8,*)' IN BEND: RATIO1, RATIO2=', RATIO1,RATIO2
      IF (RATIO1.LT.0.) RATIO1 = 10.E16   
      IF (RATIO2.LT.0.) RATIO2 = 10.E16   
      EIGVAL = AMIN1(RATIO1,RATIO2) 
C BEG MAR 1996
      DOC = 0.
      IF (EIGVAL.GT.0.0.AND.EIGVAL.LT.10.E15) THEN
         DEN = A2 + EIGVAL*B2
         IF (DEN.NE.0.0) DOC = -2.*(A1+EIGVAL*B1)/DEN
      ENDIF
C     WRITE(8,*)' EIGVAL,DOC=',EIGVAL,DOC
C END MAR 1996
C     
      RETURN
      END   
C
C
C
C=DECK      ROLSTR
C BEG MAR 1996
C BEG JUN 2004
      SUBROUTINE ROLSTR(FLONG,MBAR,EIGSTR,DOCSTR,R,ISTIF,ISUB,FNXWEB)
C END JUN 2004
C END MAR 1996
C     
C     PURPOSE IS TO FIND ROLLING EIGENVALUES FOR STRINGER   
C     SHELL SKIN NOT PARTICIPATING. 
C     
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/STR/D11S(9),D12S(9),D22S(9),GJS(9),ALS(9),ASSM(9),ASSM3(9)
      COMMON/RESULX/RESLTS(9),RESLTR(9),TOTS,TOTR,RSKINX,RSKINY   
      COMMON/RESLTP/RPRES(9),RPRER(9),TOTPS,TOTPR,RSKNXP,RSKNYP   
      COMMON/STR2/NPARTS,NSEGS(9),NENDS(9)
      REAL M,MBAR 
      COMMON/CWEBFL/CXWEB,CXFLNG,CYWEB,CYFLNG
      DIMENSION CXBEG(9)
      CALL MOVER(C1S,1,CXBEG,1,9)
      CXBEG(1) = CXWEB
      CXBEG(2) = CXFLNG
      CXBEG(3) = CXFLNG
      PI = 3.1415927   
      M = MBAR*PI/FLONG
      RAD = 10000.*ABS(R)
C BEG JUN 2004
      IF (ISUB.EQ.1) THEN
         RESLSV = RESLTS(1)
         RESLTS(1) = FNXWEB
      ENDIF
C END JUN 2004
      CALL BEND(EIGSTR,M,RAD,NPARTS,NSEGS,NENDS,ANGLS,RPRES,RESLTS,
C BEG MAR 1996
C BEG JUN 2004
     1 ALS,CXBEG,D11S,D12S,D22S,GJS,ISTIF,DOCSTR)
      IF (ISUB.EQ.1) RESLTS(1) = RESLSV
C END JUN 2004
C END MAR 1996
C     
C     WRITE(8,*)' IN ROLSTR (STRINGER ROLLING): ABIG,MBAR, EIGSTR=',
C    1                                          ABIG,MBAR, EIGSTR
C
      RETURN
      END   
C
C
C
C=DECK      ROLRNG
C BEG MAR 1996
C BEG JUN 2004
      SUBROUTINE ROLRNG(FLONG,NBAR,EIGRNG,DOCRNG,R,ISTIF,ISUB,FNXWEB)
C END JUN 2004
C END MAR 1996
C     
C     PURPOSE IS TO FIND ROLLING EIGENVALUES FOR RING.
C     SHELL SKIN NOT PARTICIPATING. 
C     
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/RNG/D11R(9),D12R(9),D22R(9),GJR(9),ALR(9),ARSM(9),ARSM3(9)
      COMMON/RESULX/RESLTS(9),RESLTR(9),TOTS,TOTR,RSKINX,RSKINY   
      COMMON/RESLTP/RPRES(9),RPRER(9),TOTPS,TOTPR,RSKNXP,RSKNYP   
      COMMON/RNG2/NPARTR,NSEGR(9),NENDR(9)
      REAL N,NBAR 
C     
      PI = 3.1415927   
      N = NBAR*PI/FLONG
      RAD = R     
C     WRITE(8,10) NBAR
C  10 FORMAT(/' RING ROLLING (ROLRNG), CIRC. WAVES N = ',I4)
C BEG JUN 2004
      IF (ISUB.EQ.1) THEN
         RESLSV = RESLTR(1)
         RESLTR(1) = FNXWEB
      ENDIF
C END JUN 2004
      CALL BEND(EIGRNG,N,RAD,NPARTR,NSEGR,NENDR,ANGLR,RPRER,RESLTR,
C BEG MAR 1996
C BEG JUN 2004
     1 ALR,C1R,D11R,D12R,D22R,GJR,ISTIF,DOCRNG)
      IF (ISUB.EQ.1) RESLTR(1) = RESLSV
C END JUN 2004
C END MAR 1996
C     
      RETURN
      END   
C
C
C
C=DECK      ROLL  
      SUBROUTINE ROLL(FL,NPART,IEND,ANGL,C1,AL,NSEG,NRS,RESULT,RPRE, 
     1                ISTIF)
C     
C     PURPOSE IS TO CALCULATE STIFFENER ROLLING INTEGRALS   
C     
      DIMENSION IEND(9),ANGL(9),C1(9),AL(9),NSEG(9)  
      DIMENSION ZA(9),ZB(9),ZORIG(9),YORIG(9),KLAST(9)
      DIMENSION YA(9),YB(9),RESULT(1),RPRE(*)
      COMMON/ROLLIT/NSTOT,NRTOT,IROLL(9,9,2),FN(9,2),FD(9,2)
C BEG FEB 2009
      COMMON/ILABLX/ILABLY
      COMMON/OUTP/NPRT
C
C     FL = stiffener spacing
C     NPART = number of stiffener segments
C     IEND  = 0 if no edges are free; 1 if one edge is free
C     ANGL  = angle with respect to normal to skin of stiffener segment. For
C             a blade stiffener, ANG = 0. deg. for external, 180 deg.
C             for internal stiffener.
C     C1    = axial stiffness/length, C(1,1), of the stiffener segment
C     AL    = height of stiffener segment
C     NSEG  = number of stiffener segments attached to stiffener web.
C     NRS   = 1 for stringers, 2 for rings
C     RESULT= axial stress resultant in stiffener segment, Load Set A
C     RPRE  = axial stress resultant in stiffener segment, Load Seg B
C     ISTIF = type of stiffener: for example, 3 = blade
C
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (ILABLY.EQ.9260.AND.NPRT.GE.2) THEN
        WRITE(8,'(/,A,I6)')
     1' Enter SUBROUTINE ROLL. Label in STRUCT                 =',ILABLY
        WRITE(8,'(A,I6)')
     1' NRS   = 1 for stringers, 2 for rings; NRS              =',NRS
        WRITE(8,'(A,1P,E12.4)')
     1' FL = stiffener spacing; FL                             =',FL
        WRITE(8,'(A,I6)')
     1' NPART = number of stiffener segments; NPART            =',NPART
        WRITE(8,'(A,3I6)')
     1' IEND  = 0=no edges are free; 1=one edge is free; IEND  =',
     1                                (IEND(i),i=1,3)
        WRITE(8,'(A,1P,3E12.4)')
     1' ANGL = 0 deg.or 180 deg.for web, 90 deg.for flange;ANGL=',
     1                                (57.29578*ANGL(i),i=1,3)
        WRITE(8,'(A,1P,3E12.4)')
     1' C1    = axial stiffness/length of stiffener segment; C1=',
     1                                (C1(i),i=1,3)
        WRITE(8,'(A,1P,3E12.4)')
     1' AL    = height of stiffener segment; AL                =',
     1                                (AL(i),i=1,3)
        WRITE(8,'(A,3I6)')
     1' NSEG  = number of stiffener segments attached  web,NSEG=',
     1                                (NSEG(i),i=1,3)
        WRITE(8,'(A,1P,3E12.4)')
     1' RESULT= axial resultant in stiff.seg, Load Set A;RESULT=',
     1                                (RESULT(i),i=1,3)
        WRITE(8,'(A,1P,3E12.4)')
     1' RPRE  = axial resultant in stiff.seg. Load Seg B, RPRE =',
     1                                (RPRE(i),i=1,3)
        WRITE(8,'(A,I6)')
     1' ISTIF = type of stiffener: for example, 3=blade; ISTIF =',ISTIF
      ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
C END FEB 2009
C     
      PI = 3.1415927    
      N = 1 
      III = 0     
      PI90 = PI/2.
      PI270 = 3.*PI/2.  
      FN(1,NRS) = 0.0   
      FD(1,NRS) = 0.0   
      FN(3,NRS) = 0.    
      N1 = N - 1  
      TOL = .0001 
      IF (NPART.EQ.0) GO TO 105     
      IF (ISTIF.EQ.4) GO TO 105
C     
      CALL ZAZB(NPART,NSEG,ANGL,AL,FL,ZA,ZB,YA,YB)    
C     
      DO 100 I = 1,NPART
      III = I     
      IF (IEND(I).EQ.1) GO TO 100   
      CALL DIFF(ANGL(I),PI90,DIFF1) 
      IF (DIFF1.LT.TOL) GO TO 100   
      CALL DIFF(ANGL(I), -PI90,DIFF1)     
      IF (DIFF1.LT.TOL) GO TO 100   
      CALL DIFF(ANGL(I), PI270,DIFF1)     
      IF (DIFF1.LT.TOL) GO TO 100   
      IF (N.EQ.1) GO TO 11    
      N1 = N - 1  
      DO 10 J = 1,N1    
      CALL DIFF(ZA(I),ZORIG(J),DIFF1)     
      CALL DIFF(YA(I),YORIG(J),DIFF2)     
      IF (DIFF1.LT.TOL.AND.DIFF2.LT.TOL) GO TO 100    
   10 CONTINUE    
   11 ZORIG(N) = ZA(I)  
      YORIG(N) = YA(I)  
      N = N + 1   
C     
      N1 = N-1    
      M = 1 
      I1 = I - 1  
      FNUM = 0.0  
      FDEN = 0.0  
      FNUMP = 0.0 
C     
      DO 50 K = I,NPART 
C     
      IF (K.EQ.I) GO TO 20    
      M1 = M - 1  
      DO 15 L = 1,M1    
      KL = KLAST(L)     
      CALL DIFF(ZA(K),ZB(KL),DIFF1) 
      CALL DIFF(YA(K),YB(KL),DIFF2) 
      IF (DIFF1.LT.TOL.AND.DIFF2.LT.TOL) GO TO 20     
      CALL DIFF(ZA(K),ZA(KL),DIFF1) 
      CALL DIFF(YA(K),YA(KL),DIFF2) 
      IF (DIFF1.LT.TOL.AND.DIFF2.LT.TOL) GO TO 20     
   15 CONTINUE    
C     
      GO TO 50    
   20 CONTINUE    
C     
      KLAST(M) = K
      M = M + 1   
      ZMIN = AMIN1(ZA(K),ZB(K)) - ZORIG(N1)     
      ZMAX = AMAX1(ZA(K),ZB(K)) - ZORIG(N1)     
      YMIN = AMIN1(YA(K),YB(K)) - YORIG(N1)     
      YMAX = AMAX1(YA(K),YB(K)) - YORIG(N1)     
C     
      IF (ABS(ANGL(K)).LT.TOL) GO TO 30   
      CALL DIFF(ANGL(K), PI, DIFF1) 
      IF (DIFF1.LT.TOL) GO TO 30    
      CALL DIFF(ANGL(K),-PI, DIFF1) 
      IF (DIFF1.LT.TOL) GO TO 30    
C     
C     BRANCH FOR STIFFENER SEGMENT ORIENTATION AT + OR - 90 DEG. OR     
C     + OR - 270 DEG....
C     
      FNUM = FNUM + C1(K)*(YMAX**3-YMIN**3)/3.  
      FDEN = FDEN + (RESULT(K) - RPRE(K))*(YMAX - YMIN)     
      FNUMP = FNUMP + RPRE(K)*(YMAX - YMIN)     
C     
      GO TO 50    
C     
   30 CONTINUE    
C     
C     BRANCH FOR STIFFENER SEGMENT ORIENTATION AT 0 DEG. OR + OR - 180. 
C     
      FNUM = FNUM + C1(K)*YMIN**2*(ZMAX-ZMIN)   
      FDEN = FDEN + (RESULT(K) - RPRE(K))*(ZMAX - ZMIN)     
      FNUMP = FNUMP + RPRE(K)*(ZMAX - ZMIN)     
C     
   50 CONTINUE    
C     
      FN(N1,NRS) = FNUM 
      FD(N1,NRS) = FDEN 
      FN(3,NRS) = FNUMP 
      M1 = M - 1  
      DO 51 K = 1,9     
   51 IROLL(K,N1,NRS) = 0     
      DO 52 K = 1,M1    
   52 IROLL(K,N1,NRS) = KLAST(K)    
      GO TO 105   
C     
  100 CONTINUE    
  105 CONTINUE    
      FN(2,NRS) = III   
      DO 110 I = 1,9    
  110 IROLL(I,N ,NRS) = 0     
C BEG JUN 2004
C     WRITE(8,'(/,A,4I2)')
C    1' IN SUB. ROLL: NRS,NPART,IEND(1),NSEG(1)=',
C    1                NRS,NPART,IEND(1),NSEG(1)
C     WRITE(8,'(A,5I3)')
C    1' N1,M1,IROLL(1,N1,NRS),IROLL(2,N1,NRS),IROLL(3,N1,NRS)=', 
C    1  N1,M1,IROLL(1,N1,NRS),IROLL(2,N1,NRS),IROLL(3,N1,NRS)
C     WRITE(8,'(A,1P,3E12.4)')
C    1' FN(1,NRS),FN(2,NRS),FN(3,NRS)=',
C    1  FN(1,NRS),FN(2,NRS),FN(3,NRS)
C     WRITE(8,'(A,1P,3E12.4)')
C    1' FD(1,NRS),FD(2,NRS),FD(3,NRS)=',
C    1  FD(1,NRS),FD(2,NRS),FN(3,NRS)
C END JUN 2004
      RETURN
      END   
C
C
C
C=DECK      MINVAL
C BEG AUG 1992
C BEG MAR 1996
C BEG OCT 1996
C BEG JUN 2004
      SUBROUTINE MINVAL(ROLVAL,FLONG,EIGVAL,MMBAR,IDESGN,
     1                  DOC,MSTART,GTRWEB,TWEB,IREDUC,FNXWEB,
     1                  R,ISTIF,ISUB,ICALL)
C END JUN 2004
C END OCT 1996
C END MAR 1996
C END AUG 1992
C     
C     PURPOSE IS TO FIND MINIMUM ROLLING BUCKLING LOAD WITH WAVENUMBER  
C     FOR STIFFENER ROLLING WITH WEB DEFORMATION.  SUBROUTINE ROLVAL    
C     IS EXTERNAL.
C     
C BEG JAN 2005
      COMMON/OUTP/NPRT
C END JAN 2005
C BEG OCT 1996
      DIMENSION GTRWEB(*)
C END OCT 1996
      REAL MBAR,MBARM,MBARP,MBARS   
      EXTERNAL ROLVAL   
      MBAR = MMBAR
C BEG MAR 1996
      IF (IDESGN.EQ.0) MBAR = FLOAT(MSTART)
C BEG JUN 2004
      CALL ROLVAL(FLONG,MBAR,EIGVAL,DOC,R,ISTIF,ISUB,FNXWEB)
C END JUN 2004
C END MAR 1996
C BEG OCT 1996
C     IF (IDESGN.EQ.1) RETURN 
      IF (IDESGN.EQ.1) THEN
         MBARS = MBAR
         GO TO 110
      ENDIF
C END OCT 1996
C     
      EIGVM = 2.*EIGVAL 
      MBARS = MBAR
      M = MBAR    
      IPRCNT = 0.1*MBAR
      PRCNTM = IPRCNT
      PRCNTM = AMAX1(1.0,PRCNTM)
      IF (M.EQ.0) RETURN
      MBARP = MBAR + PRCNTM   
C BEG MAR 1996
C BEG JUN 2004
      CALL ROLVAL(FLONG,MBARP,EIGVP,DOC,R,ISTIF,ISUB,FNXWEB)     
C END JUN 2004
C END MAR 1996
      IF (EIGVP.GT.EIGVAL) GO TO 10 
      INCR =  PRCNTM     
      SINCR = 1.0 
      FINCR = INCR
      EIGVAL = EIGVP    
      GO TO 30    
C     
   10 CONTINUE    
      IF (M.EQ.1) GO TO 100
      MBARM = MBAR - PRCNTM   
C BEG MAR 1996
C BEG JUN 2004
      IF (M.GT.1) CALL ROLVAL(FLONG,MBARM,EIGVM,DOC,R,ISTIF,
     1                        ISUB,FNXWEB)
C END JUN 2004
C END MAR 1996
      IF (EIGVM.GT.EIGVAL.OR.M.LE.1) GO TO 100  
      INCR =  - PRCNTM    
      SINCR = -1.0
      FINCR = INCR
      EIGVAL = EIGVM    
C     
   30 CONTINUE    
      MBAR = MBAR + FINCR     
   35 MBARS = MBAR
      MBAR = MBAR + FINCR     
      M = MBAR    
      IF (M.LE.1) GO TO 100   
      IF (M.GT.100.AND.EIGVAL.EQ.10.E16) GO TO 100    
C     
C BEG MAR 1996
C BEG JUN 2004
      CALL ROLVAL(FLONG,MBAR,EIGV,DOC,R,ISTIF,ISUB,FNXWEB)  
C END JUN 2004
C END MAR 1996
      IF (EIGV.GT.EIGVAL) GO TO 100 
      PRCNTM = 0.1*MBAR 
      INCR =(1.0 + PRCNTM)*SINCR    
      FINCR = INCR
      EIGVAL = EIGV     
      GO TO 35    
C     
  100 CONTINUE    
C BEG MAR 1996
C BEG JUN 2004
      CALL ROLVAL(FLONG,MBARS,EIGVAL,DOC,R,ISTIF,ISUB,FNXWEB)  
C END JUN 2004
C END MAR 1996
      MMBAR = MBARS
C BEG OCT 1996
  110 CONTINUE
      EIGSAV = EIGVAL
      CALL SHRRED(IREDUC,FNXWEB,0.,0.,TWEB,TWEB,GTRWEB,EIGVAL,0,0,0,
C BEG NOV 1997
     1                  MBARS,0.,1,0.,0.,23)
C BEG JAN 2005
      IF (NPRT.GE.2) WRITE(8,'(/,A,1P,E12.4,/,A,1P,E12.4)')
     1' In SUBROUTINE MINVAL: Eigenvalue before t.s.d.=',EIGSAV,
     1'                       Eigenvalue after  t.s.d.=',EIGVAL
C END JAN 2005 
C END NOV 1997
C END OCT 1996
      RETURN
      END   
C
C
C
C=DECK      EIG1  
      SUBROUTINE EIG1(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,SLOPE,IDESGN,
C BEG MAY 1997
     1  EIGVAL,INDX,FFLAT,IAGAIN,IFINAL)
C END MAY 1997
C     
C     COMPUTE BUCKLING LOAD OF SIMPLY-SUPPORTED CYLINDRICAL PANEL 
C     WITH BIAXIAL IN-PLANE LOADING AND IN-PLANE SHEAR.     
C     
C     A = PANEL HEIGHT  (AXIAL DIRECTION) 
C     B = PANEL WIDTH (IN CIRCUMFERENTIAL DIRECTION)  
C  NBAR = NUMBER OF HALF WAVES IN CIRCUMFERENTIAL DIRECTION IN WIDTH, B 
C  MBAR = NUMBER OF HALF WAVES IN AXIAL DIRECTION IN HEIGHT, A    
C EIGVAL = EIGENVALU (LAMBDA) 
C     
C BEG FEB 1998
C23456789012345678901234567890123456789012345678901234567890123456789012
      DOUBLE PRECISION N1,M1,N2,M2,N12,N22,M12,M22,N14,N24,M14,M24,MC,ND
      DOUBLE PRECISION M,N,MSUM,NSUM,N13,N23,M13,M23,N1M1,N2M2,NMDIF,PI
      DOUBLE PRECISION PREB,DEN
      REAL MBAR,NBAR,NUM,NCYL
C END FEB 1998
C BEG JUN 2006
      COMMON/AXLRDX/AXLRED
      COMMON/EIG1XX/EIG1EIG(10,20),EIG1SLP(10,20)
C     DIMENSION EIG1EIG(10,10),EIG1SLP(10,10)
      COMMON/OUTP/NPRT
C END JUN 2006
      REAL NXPRE,NYPRE,NXYPRE 
      REAL NXEIG,NYEIG,NXYEIG 
C BEG DEC 2004
      COMMON/EIGSLY/EIGSLP(100,2),SLPEIG(10,2)
      COMMON/EIGSLW/KOUNTM
C END DEC 2004
C BEG FEB 1996
      COMMON/IRESTX/IRESTY
C END FEB 1996
      COMMON/GEOM3/ISTIF(2),NLAYER(4,2),NSEG(2),INTEXT(2)
      COMMON/IIIROL/IROLL,IPRELM,IQUICK 
      COMMON/NDEBUG/NPRNT
      COMMON/CMOD/CC(6,6)     
C BEG AUG 2003
      COMMON/NPRNTX/NPRREG
C END AUG 2003
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN   
      COMMON/GENLOC/NXFIX,NYFIX,NXYFIX,TEST,E0XP,E0YP 
C BEG AUG 1994
      COMMON/RESMEM/FXPRE,FYPRE,FXYPRE,FXXEIG,FYYEIG,FXYEIG
C BEG JUN 1996
      COMMON/ISANDR/ISAND,ISANDS
C END JUN 1996
C END AUG 1994
      COMMON/C11SAV/C11SVE
      COMMON/CWALL/C11,C12,C22,C33,C44,C45,C55,C66    
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL     
      COMMON/WALLD/AK1,AK2,A44,A45,A55,ITRANS(4)
      COMMON/ENEMS/N1,N2,M1,M2,N12,N22,M12,M22,N1M1,N2M2,NSUM,MSUM
      REAL NXFIX,NYFIX,NXYFIX 
C BEG JUL 1999
      REAL NXFIXS,NYFIXS,NXEIGS,NYEIGS
      COMMON/IEIGNN/IEIGN1,IEIGN2
C END JUL 1999
      COMMON/DESVAR/ISPACS(4),R     
      REAL NXY0,NXYNRM,NXYSKN 
      COMMON/GEOM2/BB(2),BB2(2),HH(2),WW(2),WW2(2)
      COMMON/ISKPL/ISKIPL,IRMOD,IBLL,ICD7,ICD8,ICD9
      COMMON/ITESTX/ITEST,IAMPOV(4)
      COMMON/RADIMP/RADMOD,FNWAVX,EIGNOS,FNWNOS,RORIG,W0LOC,
     1              W0GLOB,WG1,WG2
      COMMON/RADIM2/WYYAMP,W0PAN,WYYGEN,WYYPAN,WYYLOC
      COMMON/BARRAY/B1(30),B2(30),BS1(6),BS2(6),ASH(4),K(25),
     1              B1ALT(30),B2ALT(30)
      COMMON/ECHECK/ICHECK
      DIMENSION EIGALL(200),SLPALL(200)
C BEG JUNE 1995
      REAL NSTAR
C END JUNE 1995
C BEG JULY 1995
      COMMON/ILABLX/ILABLY
C END JULY 1995
C BEG NOV 2001
      COMMON/ILABLZ/ILABLW
C END NOV 2001
C BEG NOV 1995
      COMMON/FNSTR/FNSTAR
C END NOV 1995
      REAL K
      COMMON/TEMBUG/DIFFF,INDXX,MMMBAR,NNNBAR,DIFFF2
      REAL MMMBAR,NNNBAR
      COMMON/LWRUPR/VARLOW(50),VARHI(50),CLINK(50,5),VLINK(50),VBV(99)
      COMMON/NUMPAR/NPAR,NVAR,NALLOW,NNNCON,NDEC,NLINK,NESCAP,ITYPE
      COMMON/PARAMS/PAR(99),VAR(50),ALLOW(50),CONST(99),DEC(50),ESC(50)
      COMMON/OPTVAR/IDEC(50),ILV(50),IDLINK(50,5),ISCAPE(50),JTERMS(50)
      COMMON/MISCLN/NMATEL,IFLAT,DENS(10) 
      COMMON/WORDS/WORDP(99),WORDV(50),WORDA(50),WORDC(99),WORDD(50)
C BEG DEC 1998
      COMMON/I9200X/I9200
C END DEC 1998
      CHARACTER*80 WORDP,WORDV,WORDA,WORDC,WORDD
      LOGICAL IBOOL
C     
      MMMBAR = MBAR
      NNNBAR = NBAR
      INDXX  = INDX
C
      IF (ITRANS(INDX).GT.0) CALL MOVER(0.,0,B1,1,161)
      EIGVAL = 10.E16   
      EIGSAV = EIGVAL   
C
C     IF (MBAR.EQ.5.0.AND.NBAR.EQ.1.0) SLOPE = 0.39
C
      SLOPSV = SLOPE    
      SLOP0 = SLOPE
C BEG JUL 1999
      IBACKB = 0
C END JUL 1999
      PI = 3.141592654    
C     
      M = MBAR*PI/A     
      N = NBAR*PI/B
C BEG JUN 1999
      DELSLP = 0.
      IF (ISAND.EQ.0.AND.NBAR.LT.0.00001) DELSLP = 0.00001
C END JUN 1999
C BEG FEB 1998
      FM = M
C END FEB 1998
C     
C BEG JUNE 1995
      RSAVE = R
      FYEIG = NYEIG
C  REMOVE IF (IRMOD.NE.0) THEN ... ENDIF FROM HERE AND INSERT IT AFTER
C  10 CONTINUE...
C END JUNE 1995
      KOUNT = 0   
      KOUNT2 = 0
      DONNEL = 1. 
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
      NXPRE = NXFIX/DONNEL    
      NYPRE = NYFIX/DONNEL    
      NXYPRE = NXYFIX/DONNEL  
C BEG AUG 1994
      FXPRE = NXPRE
      FYPRE = NYPRE
      FXYPRE= NXYPRE
      FXXEIG= NXEIG
      FYYEIG= NYEIG
      FXYEIG= NXYEIG
C     ISAND = 1
      ITRANS(INDX) = 0
C END AUG 1994
      SUM = NXYPRE + NXYEIG   
      SGN = 1.0   
      IF (SUM.LT.0.0) SGN = -1.0    
      FINCR = 0.01*SGN
C BEG MAY 1997
      FPROD0 = 1.2
      IF (IFINAL.EQ.1) FPROD0 = 1.02
      FPROD = FPROD0
C END MAY 1997
      ITHRU = 0
      ICHECS = 0
      SLPMAX = 30.
C BEG DEC 1995
      IBACK = 0
C END DEC 1995
C BEG DEC 2004
      IF (IFINAL.EQ.2) THEN
         ICHECS = 1
         GO TO 301
      ENDIF
C END DEC 2004
C     
   10 CONTINUE    
C   THE STATEMENT "KOUNT2 = KOUNT2 + 1"  TRANSFERRED FURTHER DOWN.
C BEG JUN 1999
      D = SLOPE + DELSLP
      C = 0.0     
      IF (TEST.GT.0.99) D = 0. 
      IF (TEST.GT.0.99) C = SLOPE + DELSLP
C END JUN 1999
C     
C BEG JUNE 1995
C  CALCULATE RADIUS OF CURVATURE AS MODIFIED BY INITIAL LOCAL OR GLOBAL
C  IMPERFECTION W0 AND CIRCUMFERENTIAL WAVENUMBER PARAMETER N.
C     
C BEG DEC 2004
C     IF (IRMOD.NE.0) THEN
      IF (IFINAL.NE.2.AND.IRMOD.NE.0) THEN
C END DEC 2004
         NSTAR = N
C        IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + ABS(D)/M)
C BEG NOV 1995
C        IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + 1.00*ABS(D)/M)
         IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + FNSTAR*ABS(D)/M)
C END NOV 1995
         AMPMOD = 1.0
         WGARG = WG1
         IF (IRMOD.EQ.1) THEN
            WIMPX = W0LOC
            IF (ISTIF(1).NE.0.OR.ISTIF(2).NE.0) WGARG = 0.
         ENDIF
         IF (IRMOD.EQ.2.OR.IRMOD.EQ.4) WIMPX = WG2
         IF (IRMOD.EQ.3) THEN
            WIMPX = W0PAN
            IF (ISTIF(2).NE.0) WGARG = 0.
         ENDIF
         IF (ABS(WIMPX).GT.0.0.AND.N.GT.0.0.AND.M.GT.0.0)
C BEG FEB 1998
C BEG APR 1998
C    1      AMPMOD = ABS(0.1/WIMPX)*MIN(1./FM,1./NSTAR)
     1      AMPMOD = ABS(0.2/WIMPX)*MIN(1./FM,1./NSTAR)
C END APR 1998
C END FEB 1998
         IF (AMPMOD.GT.1.0) AMPMOD = 1.0
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG JUN 2004
C  IRMOD = 1 means local buckling; 2 means general buck.; 3 means panel buck.
         IF (IRMOD.EQ.1.AND.
     1                 (W0LOC.NE.0.0.OR.WYYGEN.NE.0.0.OR.WYYPAN.NE.0.)) 
     1      CALL RADWAV(ABS(WYYGEN)+ABS(WYYPAN),RORIG,WYYAMP,
     1                 AMPMOD*W0LOC,NSTAR,R,WGARG,IAMPOV(IRMOD))
C BEG JUN 2006
C        IF ((IRMOD.EQ.2.OR.IRMOD.EQ.4).AND.W0GLOB.NE.0.)
C    1      CALL RADWAV(0.0,RORIG,WYYAMP,AMPMOD*WG2,NSTAR,R,
         IF ((IRMOD.EQ.2.OR.IRMOD.EQ.4).AND.W0GLOB.NE.0.) THEN
            FMULT = 1.0
C BEG AUG 2006
C           IF (IFLAT.EQ.0.AND.ILABLW.EQ.7165.AND.ILABLY.EQ.9160)
            IF (IFLAT.EQ.0.AND.(ILABLW.EQ.7165.OR.ILABLW.EQ.7175)
     1                                       .AND.ILABLY.EQ.9160)
C END AUG 2006
     1      FMULT = AXLRED
            CALL RADWAV(0.0,RORIG,WYYAMP,FMULT*AMPMOD*WG2,NSTAR,R,
     1                  WGARG,IAMPOV(IRMOD))
         ENDIF
C END JUN 2006
C END JUN 2004
         IF (IRMOD.EQ.3.AND.(W0PAN.NE.0.0.OR.WYYGEN.NE.0.0))
     1      CALL RADWAV(WYYGEN,RORIG,WYYAMP,AMPMOD*W0PAN,NSTAR,R,WGARG,
     1                  IAMPOV(IRMOD))
C BEG JULY 1995
C        IF (FYEIG.LT.0.0.AND.
C    1    ((IRMOD.EQ.2.OR.IRMOD.EQ.4).OR.
C    1     (ISTIF(1).EQ.0.AND.ISTIF(2).EQ.0))) THEN
C           NYEIG = FYEIG*ABS(R/RORIG)
C           IF (ABS(NYEIG).GT.ABS(1.12*FYEIG)) NYEIG = 1.12*FYEIG
C           IF (ABS(NYEIG).LT.ABS(FYEIG)) NYEIG = FYEIG
C        ENDIF
C END JULY 1995
C BEG APR 1998
C BEG MAR 2005
C        IF (NPRNT.EQ.INDX.AND.SLOPE.GT.0.378.AND.SLOPE.LT.0.379
C    1                    .AND.NBAR.EQ.2.0.AND.MBAR.EQ.1.0) THEN
C23456789012345678901234567890123456789012345678901234567890123456789012
C           WRITE(8,'(A,I2,A,1P,E12.4,/,A,/,1P,6E12.4)')
C    1    ' Compute change in radius for IRMOD=',IRMOD,', TEST=',TEST,
C    1    ' MBAR,NBAR,NSTAR,RORIG,R,B=', MBAR,NBAR,NSTAR,RORIG,R,B
C           WRITE(8,'(A,/,1P,4E12.4)')
C    1    ' Components of initial imperfection, W0LOC,W0PAN,WG2,WGARG=',
C    1                                          W0LOC,W0PAN,WG2,WGARG
C           WRITE(8,'(A,I3,/,A,/,1P,5E12.4)')
C    1    ' Other parameters: IAMPOV(IRMOD)=',IAMPOV(IRMOD),
C    1    ' WYYGEN,WYYAMP,AMPMOD,FNSTAR,NSTAR=',
C    1      WYYGEN,WYYAMP,AMPMOD,FNSTAR,NSTAR
C        ENDIF
C END MAR 2005
C END APR 1998
      ENDIF
C END JUNE 1995
      MC = M*C    
      ND = N*D    
      N1 = N+MC   
      N2 = N-MC   
      M1 = M+ND   
      M2 = M-ND   
C     
      N12 = N1*N1 
      N22 = N2*N2 
      M12 = M1*M1 
      M22 = M2*M2 
      MSUM = M12 + M22  
      NSUM = N12 + N22  
      N1M1 = N1*M1
      N2M2 = N2*M2
      NMDIF= N2M2 -N1M1 
C
C     IF (IFLAT.EQ.0) 
C    1         PREB = NXPRE*MSUM +NYPRE*NSUM +2.*NXYPRE*NMDIF
C     IF (IAGAIN.NE.2.AND.(IFLAT.NE.0.OR.FFLAT.GT.0.5))
C    1         PREB = NXPRE*2.*M*M + NYPRE*2.*N*N + 2.*NXYPRE*NMDIF
C
C     IF (IFLAT.EQ.0) 
C    1          DEN = -NXEIG*MSUM -NYEIG*NSUM -2.*NXYEIG*NMDIF 
C     IF (IAGAIN.NE.2.AND.(IFLAT.NE.0.OR.FFLAT.GT.0.5))
C    1          DEN = -NXEIG*2.*M*M - NYEIG*2.*N*N -2.*NXYEIG*NMDIF 
               PREB = NXPRE*MSUM +NYPRE*NSUM +2.*NXYPRE*NMDIF
                DEN = -NXEIG*MSUM -NYEIG*NSUM -2.*NXYEIG*NMDIF
C BEG JAN 1996
      NEGDEN = 0
C BEG MAR 1998
      IF (DEN.LE.0.0.AND.ISAND.EQ.0) THEN
C END MAR 1998
         NEGDEN = 1
         IF (NPRNT.EQ.INDX) WRITE(8,'(A,/,3I3,1P,4E10.2)')
     1    ' NEG.DEN: ISHEAR,IBAL,KOUNT,SLOPE,MBAR,NBAR,EIGVAL=',
     1               ISHEAR,IBAL,KOUNT,SLOPE,MBAR,NBAR,EIGVAL
C        IF (ISHEAR.EQ.0) GO TO 300 
         IF (ISHEAR.EQ.0.AND.IBAL.EQ.0) GO TO 300 
C        IF (ABS(SLOPE).GT.5.) GO TO 300  
         IF (ABS(SLOPE).GT.21.) GO TO 300
         IF (ITHRU.EQ.0.AND.ABS(SLOPE).GT.5.) GO TO 300  
C BEG DEC 1995
         IF (IDESGN.EQ.1.AND.IBACK.EQ.0) GO TO 320
C END DEC 1995
C        IF (KOUNT.GT.0)  GO TO 300
         IF (ITHRU.EQ.0.AND.KOUNT.GT.0)  GO TO 300
C        IF (ISHEAR.NE.0) GO TO 110 
         IF (ISHEAR.NE.0.OR.IBAL.NE.0) GO TO 110 
C END JAN 1996
      ENDIF
C     
      EIGSVV = EIGSAV   
      EIGSAV = EIGVAL   
      KOUNT = KOUNT + 1 
      KOUNT2 = KOUNT2 + 1
C BEG JUL 1999
   14 CONTINUE
C END JUL 1999
      IF (ITRANS(INDX).EQ.0) GO TO 20
C
C      EIGENVALUE WITH TRANSVERSE SHEAR DEFORMATION OF STIFFENER WEB...
C
C     WRITE(8,*)' BEFORE FILLLB,..KOUNT=', KOUNT
      CALL FILLLB(R,B,B1,B2,BS1,BS2,ASH,FFLAT,IAGAIN,B1ALT,B2ALT)
      IORDER = 5
      CALL EIGSHR(EIGV2,CC,B1ALT,B2ALT,BS1,BS2,ASH,IORDER,K,PREB,DEN,  
     1 NBAR,MBAR,SLOPE)
      EIGV1 = EIGV2
      RBB = ABS(R)/ABS(B)
      IF (IAGAIN.NE.2.AND.FFLAT.GT.0.5) RBB = 10000.
      IF (RBB.LT.10.)
     1   CALL EIGSHR(EIGV1,CC,B1,B2,BS1,BS2,ASH,IORDER,K,PREB,DEN,  
     1   NBAR,MBAR,SLOPE)
      EIGVAL = MIN(EIGV1,EIGV2)
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
      EIGVAL = DONNEL*EIGVAL
      GO TO 30
C
   20 CONTINUE
C
C      EIGENVALUE WITHOUT TRANSVERSE SHEAR DEFORMATION EFFECT...
C
C BEG JULY 1995
C BEG AUG 2003
C     NINTGR = NBAR
C     MINTGR = MBAR
C     SPECSL = 0.02
C     DIFSLP = ABS(SLOPE - SPECSL)/ABS(SPECSL)
      NPRREG = 0
C     IF (NINTGR.EQ.2.AND.MINTGR.EQ.1.AND.DIFSLP.LT.0.0001
C    1               .AND.ILABLW.EQ.7185.AND.ILABLY.EQ.9260)
C    1    NPRREG = 3
C     IF (NPRREG.EQ.3) WRITE(8,'(A,2I6,1P,E13.5)')
C    1   ' NPRREG=3: N,M,SLOPE=',NINTGR,MINTGR,SLOPE
C BEG MAR 2005
C     IF (NPRNT.EQ.INDX.AND.SLOPE.GT.0.378.AND.SLOPE.LT.0.379
C    1                 .AND.NBAR.EQ.2.0.AND.MBAR.EQ.1.0) THEN
C        WRITE(8,'(A,2I5,/,1P,5E12.4)')
C    1 ' before eigreg:IAGAIN,INDX,RORIG,PREB,DEN,B,FFLAT=',
C    1                 IAGAIN,INDX,RORIG,PREB,DEN,B,FFLAT
C        WRITE(8,'(A,1P,5E12.4)')
C    1 ' A,B,NXEIG,NYEIG,NXYEIG=',A,B,NXEIG,NYEIG,NXYEIG
C        NPRREG = 3
C        WRITE(8,'(A,1P,2E12.4)') ' NBAR,MBAR=',NBAR,MBAR
C     ENDIF
C END MAR 2005
      CALL EIGREG(EIGVAL,PREB,DEN,B,FFLAT,IAGAIN,NBAR,MBAR,SLOPE,
     1            NPRREG,8)
C END AUG 2003
C END JULY 1995
C BEG MAR 2005
C     IF (NPRNT.EQ.INDX.AND.SLOPE.GT.0.378.AND.SLOPE.LT.0.379
C    1                 .AND.NBAR.EQ.2.0.AND.MBAR.EQ.1.0) THEN
C        WRITE(8,'(A,2I5,/,1P,5E12.4)')
C    1 ' after eigreg: IAGAIN,INDX,RORIG,PREB,DEN,B,FFLAT=',
C    1   IAGAIN,INDX,RORIG,PREB,DEN,B,FFLAT
C        WRITE(8,'(A,1P,5E12.4)')
C    1 ' A,B,NXEIG,NYEIG,NXYEIG=',A,B,NXEIG,NYEIG,NXYEIG
C        NPRREG = 3
C        WRITE(8,'(A,1P,2E12.4)') ' NBAR,MBAR=',NBAR,MBAR
C     ENDIF
C END MAR 2005
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
C BEG MAR 2005
C     IF (NPRNT.EQ.INDX.AND.SLOPE.GT.0.378.AND.SLOPE.LT.0.379
C    1                 .AND.NBAR.EQ.2.0.AND.MBAR.EQ.1.0) THEN
C        WRITE(8,'(A,/,1P,6E12.4)')
C    1 ' PREB,DEN,B,FFLAT,DONNEL,EIGVAL=',
C    1   PREB,DEN,B,FFLAT,DONNEL,EIGVAL
C        NPRREG = 0
C     ENDIF
C END MAR 2005
C BEG AUG 1996
C     IF (INDX.EQ.NPRNT) WRITE(8,*)' MBAR,NBAR,EIGVAL,DONNEL=',
C    1                               MBAR,NBAR,EIGVAL,DONNEL
C END AUG 1996
      EIGVAL = DONNEL*EIGVAL
C     WRITE(8,*)' IN EIG1: MBAR,NBAR,SLOPE,EIGVAL,ISAND=', 
C    1                     MBAR,NBAR,SLOPE,EIGVAL,ISAND
C     
   30 CONTINUE
C     IF (NPRNT.EQ.INDX.AND.MBAR.EQ.1.0.AND.NBAR.EQ.1.0) THEN
      IF (NPRNT.EQ.INDX) THEN
C BEG JULY 1995
         WRITE(8,7011) MBAR,NBAR,SLOPE,R,EIGVAL
 7011    FORMAT(' M,N,S,R,EIG=', 1P,4E12.4,E14.6)
C END JULY 1995
C BEG NOV 2001
C        IF (ILABLW.EQ.7185.AND.ILABLY.EQ.9140) CALL EXIT
C END NOV 2001
      ENDIF
C BEG DEC 2004
      IF (IFINAL.EQ.2) THEN
         EIGSLP(KOUNT2,1) = SLOPE
         EIGSLP(KOUNT2,2) = EIGVAL
         KOUNTM = MAX(KOUNTM,KOUNT2)
      ENDIF
C END DEC 2004
      IF (EIGVAL.LT.0.0) THEN
         IF (NPRNT.EQ.INDX) WRITE(8,7010) NBAR,MBAR,SLOPE,EIGVAL,DONNEL
         IF (INDX.EQ.1.AND.IPRELM.EQ.2.AND.IQUICK.EQ.0) GO TO 300
         IIERR = 0
         IBOOL = (INDX.NE.1.OR.IROLL.EQ.1.OR.NBAR.GT.1.1)
         IF (IBOOL.OR.ISTIF(1).EQ.4) IIERR = 1
C BEG DEC 1998
         IF (ILABLY.EQ.9200) THEN
            IF (I9200.EQ.0)
     1  WRITE(8,'(A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A)')
     1' **** WARNING ***** WARNING ***** WARNING ***** WARNING *****',
     1' Negative eigenvalue found at Label 9200 in SUBROUTINE STRIMP',
     1' This is a wide column buckling computation carried out even',
     1' though the user elected not to use the wide column option.',
     1' Therefore, the negative eigenvalue will be ignored. It means',
     1' that the loads in Load Set B are sufficient to cause wide',
     1' column buckling by themselves. It might be a good idea to',
     1' use the wide column model in order to avoid unconservative',
     1' designs.',
     1' ******** END WARNING *** END WARNING *** END WARNING ********'
            I9200 = 1
            GO TO 300
         ENDIF
C END DEC 1998
C BEG JUL 1999
         WRITE(8,'(/,A,/,A,I5,A)')' ********* WARNING ***********',
     1  ' Negative eigenvalue at location',ILABLY,' in STRUCT'
         IF (IIERR.EQ.1.AND.IEIGN1.EQ.0) THEN
C END JUL 1999
            CALL OUTOPT(8,NVAR,IDEC,ISCAPE,ILV,CLINK,IDLINK,
     1                  VARLOW,VARHI,VAR,WORDV,
     1 '         SUMMARY OF INFORMATION FROM OPTIMIZATION ANALYSIS      
     1  ',57)
C
            DETTER = C11SVE**2*(C11*C22 - C12*C12)
            WRITE(8,15) INDX,A,B,NBAR,MBAR,SLOPE,EIGVAL,
     1                               IROLL,NXFIX*C11SVE,NYFIX*C11SVE,
     1                               NXYFIX*C11SVE,NXEIG*C11SVE,
     1                               NYEIG*C11SVE,NXYEIG*C11SVE
            WRITE(8,151) C11*C11SVE,C22*C11SVE,C33*C11SVE,C44*C11SVE,
     1                   C55*C11SVE,C66*C11SVE,DETTER
         ENDIF
C
   15    FORMAT(//' ************* NEGATIVE BUCKLING LOAD(S) **********'/
     1' We are now in the PANDA-type (closed form) analysis branch.'/
     1' We are now in SUBROUTINE EIG1. Relevant parameters have the'/
     1' the following values:'/
     1'   Indicator for type of buckling, INDX               =',I10/
     1'    (1=local; 2=general; 3=smeared stringers; 4=smeared rings)'/
     1'   Axial length of part of panel being evaluated, a   =',1PE12.4/
     1'   Circ. length of part of panel being evaluated, b   =',1PE12.4/
     1'   Number of circumferential halfwaves in this part, n=',1PE12.4/
     1'   Number of      axial      halfwaves in this part, m=',1PE12.4/
     1'   Slope of the buckling nodal lines, SLOPE           =',1PE12.4/
     1'   Buckling load factor, EIGVAL                       =',1PE12.4/
     1'   Index for including stiffener rolling,        IROLL=',I5//
     1'   Fixed axial resultant (Load Set B),         Nx(pre)=',1PE12.4/
     1'   Fixed hoop  resultant (Load Set B),         Ny(pre)=',1PE12.4/
     1'   Fixed shear resultant (Load Set B),        Nxy(pre)=',1PE12.4/
     1'   Eigenvalue axial resultant (Load Set A),    Nx(eig)=',1PE12.4/
     1'   Eigenvalue hoop  resultant (Load Set A),    Ny(eig)=',1PE12.4/
     1'   Eigenvalue shear resultant (Load Set A),   Nxy(eig)=',1PE12.4)
  151    FORMAT (/,   
     1' Tangent stiffness terms, CTAN...'/
     1'   Axial stiffness,                             C(1,1)=',1PE12.4/
     1'   Hoop  stiffness,                             C(2,2)=',1PE12.4/
     1'   In-plane shear stiffness,                    C(3,3)=',1PE12.4/
     1'   Axial bending  stiffness,                    C(4,4)=',1PE12.4/
     1'   Hoop  bending  stiffness,                    C(5,5)=',1PE12.4/
     1'   Torsional      stiffness,                    C(6,6)=',1PE12.4/
     1'   C11*C22 - C12**2 (must be positive!) C11*C22-C12**2=',1PE12.4)
C
C BEG JUL 1999
         IF (IIERR.EQ.1.AND.IEIGN1.EQ.0) WRITE(8,16)
C END JUL 1999
   16    FORMAT(/' CHECK FOR THE FOLLOWING:'/
     1'   1. Are the signs of your applied loads correct?'/
     1'   2. Do you have a Load Set B that is more than large enough'/
     1'      to cause buckling by itself? (If you suspect that the'/
     1'      pressure is causing this trouble, rerun with the pressure'/
     1'      in Load Set A instead of Load Set B.)'/
     1'   3. Are thermal resultants large enough to cause buckling by'/
     1'      themselves? (If so, move thermal loads to Load Set A).'/
     1'   4. Are any terms on the diagonal of the tangent stiffness'/
     1'      matrix CTAN negative? If so, there is something wrong'/
     1'      with the calculation of the constitutive law. (Contact'/
     1'      Dave Bushnell, (415) 424-3237 ).'/
     1'   5. Is C11*C22 - C12**2 negative? If so, there is something'/
     1'      wrong with the local postbuckling solution (contact Dave'/
     1'      Bushnell, (415) 424-3237).'//
     1' IF THE DIFFICULTY IS NOT ITEMS 4 OR 5, YOU MIGHT FIRST TRY TO'/
     1' AVOID THE PROBLEM BY INCREASING THE LOAD COMPONENTS IN'/
     1' LOAD SET A.'/)
C BEG JUL 1999
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NXFIX.LT.-0.0001.OR.NYFIX.LT.-0.0001) THEN
            IF (IEIGN1.EQ.0) WRITE(8,'(A,/,A,/,A)')
     1    ' Either Nx(fixed) or Ny(fixed) is significant and negative.',
     1    ' Therefore, the negative "fixed" loads (Load Set B) will be',
     1    ' included with the "eigenvalue" loads (Load Set A) for the',
     1    ' remainder of the execution of SUBROUTINE EIG1 in this case.'
            IBACKB = 1
            FNXMLT = 1.
            FNYMLT = 1.
            IF (NXFIX.GT.0.0) FNXMLT = 0.
            IF (NYFIX.GT.0.0) FNYMLT = 0.
            NXFIXS = NXFIX
            NYFIXS = NYFIX
            NXEIGS = NXEIG
            NYEIGS = NYEIG
            NXEIG = FNXMLT*NXFIXS + NXEIGS
            NYEIG = FNYMLT*NYFIXS + NYEIGS
            NXFIX = (1. - FNXMLT)*NXFIXS
            NYFIX = (1. - FNYMLT)*NYFIXS
            NXPRE = NXFIX/DONNEL    
            NYPRE = NYFIX/DONNEL    
            FXPRE = NXPRE
            FYPRE = NYPRE
            FXXEIG= NXEIG
            FYYEIG= NYEIG
            PREB  = NXPRE*MSUM +NYPRE*NSUM +2.*NXYPRE*NMDIF
            DEN   = -NXEIG*MSUM -NYEIG*NSUM -2.*NXYEIG*NMDIF
            IF (IEIGN1.EQ.0) WRITE(8,152) NXFIX*C11SVE,NYFIX*C11SVE,
     1                                    NXYFIX*C11SVE,NXEIG*C11SVE,
     1                                    NYEIG*C11SVE,NXYEIG*C11SVE
  152    FORMAT(/' ************* NEW LOADING **********'/
     1'   Fixed axial resultant (Load Set B),         Nx(pre)=',1PE12.4/
     1'   Fixed hoop  resultant (Load Set B),         Ny(pre)=',1PE12.4/
     1'   Fixed shear resultant (Load Set B),        Nxy(pre)=',1PE12.4/
     1'   Eigenvalue axial resultant (Load Set A),    Nx(eig)=',1PE12.4/
     1'   Eigenvalue hoop  resultant (Load Set A),    Ny(eig)=',1PE12.4/
     1'   Eigenvalue shear resultant (Load Set A),   Nxy(eig)=',1PE12.4)
            IEIGN1 = 1
            GO TO 14
         ENDIF
C END JUL 1999
C
C BEG FEB 1996
C BEG FEB 1999
         CALL LOADBA(11)
C END FEB 1999
         IF (IRESTY.EQ.1) THEN
          WRITE(8,*)' THIS MESSAGE PRINTED FROM SUBROUTINE EIG1.'
          WRITE(8,7012) MBAR,NBAR,SLOPE,EIGVAL
 7012     FORMAT(
     1     ' PANDA-type (closed form) buckling mode and eigenvalue'/
     1     ' before loads switched from Load Set B to Load Set A:'/
     1     '   Number of axial halfwaves,      MBAR=',1PE12.4/
     1     '   Number of circ. halfwaves,      NBAR=',1PE12.4/
     1     '   Slope of buckling nodal lines, SLOPE=',1PE12.4/
     1     '   Buckling load factor,         EIGVAL=',1PE12.4)
          GO TO 2222
         ENDIF
C END FEB 1996
         IF (IIERR.EQ.1) CALL ERREX
   32    CONTINUE
      ENDIF
C
C     IF (INDX.EQ.2.AND.KOUNT.EQ.1.AND.MBAR.LT.2.) WRITE(6,5105) 
C     IF (NPRNT.EQ.INDX.AND.MBAR.EQ.1.)WRITE(8,5100) MBAR,NBAR,SLOPE,
C    1 EIGVAL,TEST,DEN,C,D
 5100 FORMAT(' M,N,C,EIG,TEST,DEN,C,D=',1P,8E11.3) 
 5105 FORMAT(1H0) 
C BEG DEC 1995
      IF (IDESGN.EQ.1.AND.IBACK.EQ.0) GO TO 320    
C END DEC 1995
C     
      IF (ISHEAR.EQ.0.AND.IBAL.EQ.0) GO TO 320
      IF (EIGVAL.GE.EIGSAV.AND.KOUNT.GT.1.AND.ITHRU.EQ.0) GO TO 200  
      IF (ITHRU.EQ.1) THEN
         EIGALL(KOUNT2) = EIGVAL
         SLPALL(KOUNT2) = SLOPE
         IF (ICHECS.EQ.1.AND.SLOPE.GE.0.) FPROD = 1.2
C BEG DEC 2004
         IF (ICHECS.EQ.1.AND.SLOPE.GE.0.0.AND.IFINAL.EQ.2)
     1                                    FPROD = 1.1
C END DEC 2004
      ENDIF
      IF (ABS(SLOPE).GT.SLPMAX) GO TO 300
      SLOPSV = SLOPE    
C     
C     ITERATE ON THE SLOPE OF THE BUCKLING PATTERN... 
C     
  110 CONTINUE
      SLOPC = SLOPE     
      IF (ABS(SLOPC).LE.0.1) SLOPE = SLOPE + FINCR    
      IF (ABS(SLOPC).GT.0.1) SLOPE = SLOPE*FPROD
C BEG JAN 1996
      IF (NEGDEN.EQ.1.AND.ABS(SLOPE).GT.ABS(SLOPC)) FPROD = 1.2
C     IF (NPRNT.EQ.INDX) WRITE(8,*)
C    1' ICHECS,EIGVAL,EIGSAV,FINCR,FPROD,SLOPE=',
C    1  ICHECS,EIGVAL,EIGSAV,FINCR,FPROD,SLOPE
C END JAN 1996
C     
      GO TO 10    
C     
  200 CONTINUE    
      IF (EIGVAL.EQ.EIGSAV.OR.KOUNT.GT.2) GO TO 300     
      SLOPE = SLOPSV    
      EIGVAL = EIGSAV   
      FINCR =  -FINCR   
      IF (ABS(SLOPE).GT.0.1) FPROD = 1./FPROD  
      GO TO 110   
C     
  300 CONTINUE    
C     
      SLOPE = SLOPSV    
      EIGVAL = EIGSAV   
C
      IF (ITHRU.EQ.1) THEN
         EIGALL(KOUNT2) = EIGVAL
         SLPALL(KOUNT2) = SLOPE
      ENDIF
      ICHECS = ICHECK
C BEG APR 1998
      IF (IBACK.EQ.1) ICHECS = 1
C END APR 1998
C BEG JAN 1996
C     IF (SLOP0.EQ.0.0.AND.FFLAT.LT.0.5) ICHECS=1
      IF (SLOP0.EQ.0.0.AND.FFLAT.LT.0.5
     1                .AND.(ISHEAR.NE.0.OR.IBAL.NE.0)) ICHECS=1
C END JAN 1996
C BEG DEC 2004
  301 CONTINUE
C END DEC 2004
      IF (ICHECS.EQ.1.AND.ITHRU.EQ.0) THEN
         IF (NPRNT.EQ.INDX) WRITE(8,302)
  302    FORMAT(/' CHECK WIDE RANGE OF SLOPE FOR MINIMUM EIGENVALUE.')
         SLPMIN = -20.
         IF (SGN.GT.0.0.AND.NXYEIG.GT.0.1*ABS(NXEIG)
     1         .AND.C46.GE.0.) SLPMIN = 0.
         SLPMAX = 20.1
         ITHRU  = 1
         SLOP1  = SLOPE
         EIGEV1 = EIGVAL
         KOUNT  = 0
         KOUNT2 = 0
         SLOPE  = SLPMIN
         EIGVAL = 10.E16
         FINCR = 0.05
         FPROD = 1./1.2 
         IF (SLOPE.GE.0.) FPROD = 1.2
         GO TO 10
      ENDIF
      IF (ICHECS.EQ.1.AND.ITHRU.EQ.1) THEN
         EIGMIN = EIGEV1
         DO 305 I = 1,KOUNT2
            EIGMIN = MIN(EIGMIN,EIGALL(I))
  305    CONTINUE
         DIFF = ABS(EIGEV1 - EIGMIN)/ABS(EIGEV1)
         IF (DIFF.LT.0.01) THEN
            EIGVAL = EIGEV1
            SLOPE  = SLOP1
            GO TO 320
         ELSE
            DO 310 I = 1,KOUNT2
             DIFF = ABS(EIGMIN - EIGALL(I))/ABS(EIGMIN)
             IF (DIFF.LT.0.0001) THEN
               EIGVAL = EIGALL(I)
               SLOPE  = SLPALL(I)
               IF (NPRNT.EQ.INDX) 
     1            WRITE(8,308) EIGEV1,SLOP1,EIGVAL,SLOPE
  308          FORMAT(' CRITICAL EIGENVALUE SMALLER THAN THAT FOUND'/
     1       ' BY INITIAL SEARCH:'/
     1       '  PREVIOUS VALUE AND SLOPE:  EIGEV1, SLOP1 =',1P,2E12.4/
     1       '  MINIMUM  VALUE AND SLOPE:  EIGVAL, SLOPE =',1P,2E12.4/)
               GO TO 320
             ENDIF
  310       CONTINUE
         ENDIF
      ENDIF
C 
  320 CONTINUE    
C BEG DEC 1995
      NN = NBAR
      MM = MBAR
C BEG APR 1998
      IF (IBACK.EQ.0.AND.NN.EQ.1.AND.MM.EQ.1.AND.ABS(SLOPE).GT.0.2
     1              .AND.TEST.GE.0.95.AND.TEST.LE.1.05) THEN
C     IF (IBACK.EQ.0.AND.TEST.GE.0.95.AND.TEST.LE.1.05
C    1              .AND.(IBAL.NE.0.OR.ISHEAR.NE.0)
C    1              .AND.(IFLAT.EQ.0.OR.(NN.EQ.1.AND.MM.EQ.1))) THEN
C BEG APR 1998
         IBACK = 1
         TESTX = TEST
         SLOPX = SLOPE
         EIGX  = EIGVAL
         ICHECX= ICHECK
         IF (TESTX.GT.0.99) TEST = 0.9
         IF (TESTX.LE.0.99) TEST = 1.1
         ICHECK = 0
         KOUNT = 0   
         KOUNT2 = 0
C BEG APR 1998
         FINCR = 0.01*SGN
         FPROD0 = 1.2
         FPROD = FPROD0
         ITHRU = 0
         ICHECS = 0
         SLPMAX = 30.
         SLOPE = SLOP0
         SLOPSV = SLOPE
         EIGVAL = 10.E16
         EIGSAV = EIGVAL
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRNT.EQ.INDX) THEN
            WRITE(8,'(A,1P,E12.4,/,A,1P,3E12.4)')
     1    ' Must check results for "opposite" TEST. Orignl TEST=',TESTX,
     1    ' new TEST, old SLOPE, old EIGVAL=',TEST,SLOPX,EIGX
         ENDIF
C END APR 1998
         GO TO 10
      ENDIF
      IF (IBACK.EQ.1) THEN
         TEST = TESTX
         SLOPE = SLOPX
         EIGBAK = EIGVAL
         W1 = -10.0*TESTX + 10.5
         W2 =  10.0*TESTX -  9.5
         IF (TESTX.LE.0.99) THEN
            EIGVAL = W1*EIGX + W2*EIGBAK
         ELSE
            EIGVAL = W2*EIGX + W1*EIGBAK
         ENDIF
         ICHECK = ICHECX
C BEG APR 1998
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRNT.EQ.INDX) THEN
            WRITE(8,'(A,1P,E12.4,/,A,1P,3E12.4)')
     1    ' Just checked results for new TEST. Old eigenvalue=',EIGX,
     1    ' new eigenvalue, EIGNEW, weights W1,W2=',EIGBAK,W1,W2
            IF (TESTX.LE.0.99) WRITE(8,'(A,1P,E12.4)')
     1    ' Weighted average: W1*EIGOLD + W2*EIGNEW = EIGVAL=',EIGVAL
            IF (TESTX.GT.0.99) WRITE(8,'(A,1P,E12.4)')
     1    ' Weighted average: W2*EIGOLD + W1*EIGNEW = EIGVAL=',EIGVAL
         ENDIF
C END APR 1998
      ENDIF
C END DEC 1995
      IF (NPRNT.EQ.INDX) WRITE(8,7010) NBAR,MBAR,SLOPE,EIGVAL,DONNEL
 7010    FORMAT(' NBAR,MBAR,SLOPE,EIGVAL,DONNEL=',1P,5E12.4)
C     
      IF (IRMOD.NE.0) THEN
         R = RSAVE
         NYEIG=FYEIG
      ENDIF
C BEG FEB 1996
 2222 CONTINUE
C END FEB 1996
C BEG JUL 1999
      IF (IBACKB.EQ.1) THEN
         WRITE(8,'(A,A,/,A,1P,4E12.4)')
     1 ' Load Set B Nx(fixed) and Ny(fixed) temporarily shifted',
     1 ' to Load Set A:',
     1 ' MBAR,NBAR,SLOPE,EIGVAL=', MBAR,NBAR,SLOPE,EIGVAL
         NXFIX = NXFIXS
         NYFIX = NYFIXS
         NXEIG = NXEIGS
         NYEIG = NYEIGS
      ENDIF
C END JUL 1999
C BEG JUN 2006
C   store results for NBAR,MBAR in arrays for later printing
      IF (NPRT.GE.2.AND.ITYPE.EQ.2.AND.IDESGN.EQ.0) THEN
        IF ((ILABLY.EQ.9150.AND.ILABLW.EQ.7165).OR.
     1      (ILABLY.EQ.9260.AND.ILABLW.EQ.7185)) THEN
           J = NBAR
           I = MBAR
C BEG OCT 2006
           IF (I.LE.10.AND.J.LE.20
     1         .AND.I.GT.0.AND.J.GT.0) THEN
C END OCT 2006
              DIFF1 = ABS(FLOAT(I) - MBAR)
              DIFF2 = ABS(FLOAT(J) - NBAR)
              IF (DIFF1.LT.0.00001.AND.DIFF2.LT.0.00001) THEN
                 EIG1EIG(I,J) = EIGVAL
                 EIG1SLP(I,J) = SLOPE 
C                WRITE(8,'(A,2I5,1P,2E12.4)')
C    1         ' In Sub. EIG1: I,J,SLOPE,EIGVAL=',
C    1                         I,J,SLOPE,EIGVAL
              ENDIF
           ENDIF
        ENDIF
      ENDIF
C END JUN 2006
      RETURN
      END   
C
C
C
C=DECK      RADWAV
      SUBROUTINE RADWAV(WYYGEN,R,WYYAMP,W0,N,RADMOD,WGARG,IAMPOV)
C
C    GET MODIFIED RADIUS OF CURVATURE, RADMOD, CORRESPONDING TO
C    LOCAL IMPERFECTION THAT VARIES CIRCUMFERENTIALLY AS
C    WIMP(LOCAL) = W0*SIN(NBAR*PI/B):
C
C BEG NOV 2001
      COMMON/ILABLX/ILABLY
C END NOV 2001
      REAL N
      IF (R.EQ.0.) RETURN
      PI = 3.1415927
      WYY = WYYAMP*W0*N**2
      CURRAD = ABS(1./R)
      IF (IAMPOV.EQ.1) CURMOD = CURRAD - ABS(WYY) - ABS(WYYGEN) 
     1                           - ABS(WYYAMP*WGARG*4./R**2)
      IF (IAMPOV.EQ.0) CURMOD = CURRAD - ABS(WYY) - ABS(WYYGEN) 
     1                           - ABS(       WGARG*4./R**2)
C BEG NOV 2001
C     IF (ILABLY.EQ.9160) WRITE(8,'(A,/,1P,6E12.4)')
C    1' WYYAMP,W0,N,WYY,CURRAD,CURMOD=',WYYAMP,W0,N,WYY,CURRAD,CURMOD
C END NOV 2001
      IF (CURMOD.LE.(0.01*CURRAD)) CURMOD = 0.01*CURRAD
      RADMOD = (R/ABS(R))/CURMOD
      RETURN
      END
C
C
C
C=DECK      FILLLB
      SUBROUTINE FILLLB(R,B,B1,B2,BS1,BS2,ASH,FFLAT,IAGAIN,
     1                  B1ALT,B2ALT)
C
C      PURPOSE IS TO FILL B1, B2,BS1,BS2, AND ASH FOR BUCKLING PROBLEMS
C      IN WHICH TRANSVERSE SHEAR DEFORMATION IS ACCOUNTED FOR.
C
      COMMON/WALLD/AK1,AK2,A44,A45,A55,ITRANS(4)
      COMMON/ENEMS/N1,N2,M1,M2,N12,N22,M12,M22,N1M1,N2M2,NSUM,MSUM
      DIMENSION B1(6,5),B2(6,5),BS1(2,3),BS2(2,3),ASH(2,2)
C BEG FEB 1998
      DOUBLE PRECISION N1,M1,N2,M2,N12,N22,M12,M22
      DOUBLE PRECISION MSUM,NSUM,N1M1,N2M2
C END FEB 1998
C
      DIMENSION B1ALT(6,5),B2ALT(6,5)
      RBB = ABS(R)/ABS(B)
      FCUR = 1.
      IF (IAGAIN.NE.2.AND.FFLAT.GT.0.5) THEN
         RBB = 10000.
         FCUR = 0.
      ENDIF
C   ALTERNATE FORMULATION (PANDA2 NEWS ITEM 68)
      B1ALT(1,1) = -M12
      B1ALT(2,2) = N1*N1
      B1ALT(2,3) = FCUR/R
      B1ALT(3,1) = N1*M1
      B1ALT(3,2) = -M1*N1
C
      B2ALT(1,1) = M22
      B2ALT(2,2) = -N2*N2
      B2ALT(2,3) = -FCUR/R
      B2ALT(3,1) = N2*M2
      B2ALT(3,2) = -N2*M2
C
      B1ALT(4,4) = M12
      B1ALT(5,5) = N12
      B1ALT(6,4) = -M1*N1
      B1ALT(6,5) = -M1*N1
C
      B2ALT(4,4) = -M22
      B2ALT(5,5) = -N22
      B2ALT(6,4) = -M2*N2
      B2ALT(6,5) = -M2*N2
C
      IF (RBB.LT.10.) THEN
C   ORIGINAL FORMULATION
         B1(1,1) = -M12*N22
         B1(2,2) = N1*N2
         B1(2,3) = FCUR/R
         B1(3,1) = N22*N1*M1
         B1(3,2) = -M1*N2
C
         B2(1,1) = M22*N12
         B2(2,2) = -N1*N2
         B2(2,3) = -FCUR/R
         B2(3,1) = N12*N2*M2
         B2(3,2) = -N1*M2
C
         B1(4,4) = M12
         B1(5,5) = N12
         B1(6,4) = -M1*N1
         B1(6,5) = -M1*N1
C
         B2(4,4) = -M22
         B2(5,5) = -N22
         B2(6,4) = -M2*N2
         B2(6,5) = -M2*N2
      ENDIF
C
      BS1(1,1) = -N1
      BS1(1,3) = N1
      BS1(2,1) = M1
      BS1(2,2) = -M1
C
      BS2(1,1) =  N2
      BS2(1,3) = -N2
      BS2(2,1) = M2
      BS2(2,2) =-M2
C
      ASH(1,1) = A44
      ASH(1,2) = A45
      ASH(2,1) = A45
      ASH(2,2) = A55
C
      RETURN
      END
C
C
C
C=DECK      EIGSHR
      SUBROUTINE EIGSHR(EIGVAL,C,B1,B2,BS1,BS2,ASH,IORDER,K,PREB,DEN,
     1 NBAR,MBAR,SLOPE)
C
C      PURPOSE IS TO OBTAIN EIGENVALUE, INCLUDING EFFECTS OF
C      TRANSVERSE SHEAR DEFORMATION.
C
C BEG FEB 1998
      DOUBLE PRECISION PREB,DEN
C END FEB 1998
      COMMON/NDEBUG/NPRNT
      COMMON/TEMBUG/DIFFF,INDX,MMMBAR,NNNBAR,DIFFF2
      DIMENSION C(6,6),B1(6,IORDER),B2(6,IORDER),BS1(2,3),BS2(2,3)
      DIMENSION ASH(2,2),K(IORDER,IORDER),K1(3,3)
      DIMENSION A(5,5),IPERM(5),V(5),DETNUM(2),DETDEN(2),IDETN(2)
      DIMENSION IDETD(2)
      EQUIVALENCE (DETNUM(1),IDETN(1))
      EQUIVALENCE (DETDEN(1),IDETD(1))
      REAL K, K1, NBAR, MBAR, MMMBAR, NNNBAR
C
C     WRITE(8,*)' ENTERING EIGSHR. NBAR,MBAR=',NBAR,MBAR
C
      CALL MATMS4(C,B1,K,6,IORDER,0)
      CALL MATMS4(C,B2,K,6,IORDER,1)
      K(3,3) = K(3,3) + PREB
C
      IF (IORDER.EQ.3) GO TO 15
      CALL MATMS4(ASH,BS1,K1,2,3,0)
      CALL MATMS4(ASH,BS2,K1,2,3,1)
C
      K(3,3) = K(3,3) + K1(1,1)
      K(4,3) = K(4,3) + K1(2,1)
      K(5,3) = K(5,3) + K1(3,1)
      K(4,4) = K(4,4) + K1(2,2)
      K(5,4) = K(5,4) + K1(3,2)
      K(5,5) = K(5,5) + K1(3,3)
C
   15 CONTINUE
      DO 20 I = 2,IORDER
      I1 = I - 1
      DO 20 J = 1,I1
   20 K(J,I) = K(I,J)
C
      DO 30 I = 1,IORDER
      DO 30 J = 1,IORDER
   30 A(I,J) = K(I,J)
C
C    NEXT COMPUTE DETERMINANT OF K AND THE DETERMINANT OF THE MINOR OF
C    K(3,3), IN PREPARATION FOR THE CALCULATION OF THE EIGENVALUE.
C
C     IF (INDX.EQ.NPRNT.AND.MMMBAR.EQ.1.AND.NNNBAR.EQ.1) THEN
C        WRITE(8,31) NBAR,MBAR,SLOPE
C  31    FORMAT(/' STABILITY MATRIX FOR NBAR=',1PE9.2,', MBAR=',1PE9.2,
C    1   ', SLOPE=',1PE9.2,'...')
C        DO 34 I = 1,IORDER
C        WRITE(8,33) (A(I,J),J=1,IORDER)
C  33    FORMAT(1P,5E12.4)
C  34    CONTINUE
C  36    CONTINUE
C     ENDIF
      CALL LUFACS(A,5,IORDER,IPERM,V,ISING,DETNUM)
C
C     IF (INDX.EQ.NPRNT.AND.MMMBAR.EQ.1.AND.NNNBAR.EQ.1)
C    1     WRITE(8,*)' AFTER 1ST LUFACS...IPERM,DETNUM=',IPERM,DETNUM(1)
      IF (ISING.EQ.0) GO TO 35
      WRITE(8,*)' SINGULAR MATRIX K...RANK DEFICIENCY=', ISING
      WRITE(8,*)' IORDER =', IORDER
      WRITE(8,*)' K(1,1), K(1,2), K(1,3)=',K(1,1),K(1,2),K(1,3)
      WRITE(8,*)' K(2,1), K(2,2), K(2,3)=',K(2,1),K(2,2),K(2,3)
      WRITE(8,*)' K(3,1), K(3,2), K(3,3)=',K(3,1),K(3,2),K(3,3)
      CALL ERREX
   35 CONTINUE
C
      DO 40 I = 1,IORDER
   40 K(I,3) = 0.
      DO 50 J = 1,IORDER
   50 K(3,J) = 0.
      K(3,3) = 1
C
      CALL LUFACS(K,IORDER,IORDER,IPERM,V,ISING,DETDEN)
C
C     IF (INDX.EQ.NPRNT.AND.MMMBAR.EQ.1.AND.NNNBAR.EQ.1)
C    1  WRITE(8,*)' 2ND LUFACS...IPERM,DETDEN,IDETN(2),IDETD(2),DEN=',
C    1                          IPERM,DETDEN(1),IDETN(2),IDETD(2),DEN
      IF (ISING.EQ.0) GO TO 55
      WRITE(8,*)' SINGULAR MINOR A33...RANK DEFICIENCY=', ISING
      CALL ERREX
   55 CONTINUE
C
      NPOWER = IDETN(2) - IDETD(2)
      RATIO = DETNUM(1)/DETDEN(1)
      EIGVAL = RATIO*2.**NPOWER/DEN
C
      RETURN
      END
C
C
C
C=DECK      EIGREG
C BEG JULY 1995
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG AUG 2003
      SUBROUTINE EIGREG(EIGVAL,PREB,DEN,B,FFLAT,IAGAIN,NBAR,MBAR,SLOPE,
     1                  NPREIG,IFILE)
C END AUG 2003
C END JULY 1995
C
C     PURPOSE IS TO CALCULATE BUCKLING EIGENVALUE WITH NEGLECT OF
C     TRANSVERSE SHEAR DEFORMATION EFFECTS.
C
      COMMON/ENEMS/N1,N2,M1,M2,N12,N22,M12,M22,N1M1,N2M2,NSUM,MSUM
C BEG FEB 1998
C BEG MAR 1998
      DOUBLE PRECISION A33ADD, B33ADD
C END MAR 1998
C BEG APR 1998
      DOUBLE PRECISION A12N,A22N,A23N,A13N,A12NN,PROD1,PROD2,PROD3,NUM
C END APR 1998
      DOUBLE PRECISION N1,M1,N2,M2,N12,N22,M12,M22,N14,N24,M14,M24
      DOUBLE PRECISION MSUM,NSUM,N13,N23,M13,M23,N1M1,N2M2
      DOUBLE PRECISION PREB,DEN
      DOUBLE PRECISION FCUR,RDUB,FXSUM
      DOUBLE PRECISION D11,D12,D22,D33,D44,D45,D55,D66
      DOUBLE PRECISION D13,D14,D15,D16,D23,D24,D25,D26
      DOUBLE PRECISION D34,D35,D36,D46,D56
C BEG APR 1998 (put "NUM" in double precision)
      REAL MBAR,NBAR
C END APR 1998
      DOUBLE PRECISION A11ALT,A12ALT,A13ALT,A22ALT,A23ALT
      DOUBLE PRECISION A11,A12,A13,A22,A23,A33
      DOUBLE PRECISION B11,B12,B13,B22,B23,B33
C END FEB 1998
C BEG MAR 1998
      COMMON/PRESSZ/PRESSR,PRESS0
C END MAR 1998
      COMMON/CWALL/C11,C12,C22,C33,C44,C45,C55,C66    
      COMMON/WALLB/C14,C15,C25,C36  
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL   
      COMMON/DESVAR/ISPACS(4),R
      COMMON/TEMBUG/DIFF,INDX,MMMBAR,NNNBAR,DIFFF2
      COMMON/NDEBUG/NPRNT
C BEG AUG 1994
      COMMON/RESMEM/FXPRE,FYPRE,FXYPRE,FXXEIG,FYYEIG,FXYEIG
C BEG JUN 1996
      COMMON/ISANDR/ISAND,ISANDS
C END JUN 1996
C END AUG 1994
C BEG JULY 1995
      COMMON/ILABLX/ILABLY
C END JULY 1995
C BEG NOV 2001
      COMMON/ILABLZ/ILABLW
C END NOV 2001
C BEG JUN 1996 (ELASTIC FOUNDATION)
      COMMON/XFOUND/EFOUND,HXSIDE,WFOUND(4,2),HEXSID(4,2)
      COMMON/C11SAV/C11SVE
C END JUN 1996
      REAL MMMBAR,NNNBAR
C
C BEG AUG 2003
      IF (NPREIG.EQ.3) WRITE(IFILE,'(A,I2)')
     1  ' *********** ENTERING EIGREG ***********: ISAND=',ISAND
C END AUG 2003
      C24 = C15
C
      N14 = N12*N12     
      N24 = N22*N22     
      M14 = M12*M12     
      M24 = M22*M22     
      N13 = N12*N1
      N23 = N22*N2
      M13 = M12*M1
      M23 = M22*M2
C BEG FEB 1998
      RDUB = R
      D11 = C11
      D12 = C12
      D14 = C14
      D15 = C15
      D22 = C22
      D24 = C24
      D25 = C25
      D33 = C33
      D36 = C36
      D44 = C44
      D45 = C45
      D55 = C55
      D66 = C66
C END FEB 1998
C     
C     TERMS FOR BALANCED LAMINATES...     
C     
      RBB = ABS(R)/ABS(B)
      FCUR = 1.0
C BEG MAR 1998
      A33ADD = 0.
      B33ADD = 0.
      B13    = 0.
      B12    = 0.
C END MAR 1998
      IF (IAGAIN.NE.2.AND.FFLAT.GT.0.5) THEN
         RBB = 10000.
         FCUR = 0.
      ENDIF
C BEG JULY 1995
C BEG AUG 2003
         IF (NPREIG.EQ.3)
     1   WRITE(IFILE,*)' IN EIGREG: IAGAIN,FFLAT,R,B,RBB,FCUR=',
     1                              IAGAIN,FFLAT,R,B,RBB,FCUR
C END AUG 2003
C END JULY 1995
      IF (RBB.LT.10.) THEN
C   ORIGINAL FORMULATION (Computers and Structures, Vol. 27, 1987,
C                         p. 552, Eqs.(55)...)
C BEG FEB 1998 (D11 = double precision version of C11, etc.)
         A11 =D11*(N24*M14 +N14*M24) + D33*(N24*N12*M12 +N14*N22*M22)
         A12 = -(D12+D33)*(N23*N1*M12 + N13*N2*M22)
         A22 = 2.*D22*N12*N22 + D33*(N22*M12 +N12*M22)   
         A13 = -D12*(N22*M12+N12*M22)*FCUR/RDUB -D14*(N22*M14 +N12*M24)
     1         -(D15+2.*D36)*N12*N22*MSUM    
         A23 = N1*N2*(D22*2.*FCUR/RDUB +(D24+2.*D36)*MSUM +D25*NSUM)
C BEG AUG 1994
C  ADD TERMS FOR NON-SHALLOW SHELL EQUATIONS AND SANDERS "WORK DONE"...
C BEG MAR 1998
         IF (ISAND.EQ.1.OR.ISAND.EQ.2) THEN
            A12 =A12 +2.*D36*(-N1*N23*M12-N13*N2*M22)*FCUR/RDUB
     1               +D15*(-N1*N23*M12-N13*N2*M22)*FCUR/RDUB
            A22 =A22 +2.*D55*N12*N22*FCUR/RDUB**2
     1               +4.*D66*(N22*M12+N12*M22)*FCUR/RDUB**2
     1               +4.*D36*(N22*M12+N12*M22)*FCUR/RDUB
     1               +4.*D25*N12*N22*FCUR/RDUB
            A23 =A23 +(D45+4.*D66)*(N1*N2*M12+N1*N2*M22)*FCUR/RDUB
     1               +D55*(N13*N2+N1*N23)*FCUR/RDUB
     1               +2.*D25*N1*N2*FCUR/RDUB**2
         ENDIF
         IF (ISAND.EQ.1) THEN
            FXSUM = FXPRE + FYPRE
            PRSRAT = PRESS0/C11SVE
            A11 =A11 +FXSUM*0.25*(N24*N12*M12+N14*N22*M22)
            A12 =A12 +FXSUM*0.25*(N23*N1*M12+N13*N2*M22)
            A13 = A13 - PRSRAT*(N22*M12 + N12*M22)
            A22 =A22 +FXSUM*0.25*(N22*M12+N12*M22)
     1               +FYPRE*(N22+N12)*FCUR/RDUB**2
     1               +PRSRAT*(N12+N22)*FCUR/RDUB
            A23 =A23 +(2.*FYPRE*N1*N2 + FXYPRE*(N1*M2-N2*M1))*FCUR/RDUB
     1               + PRSRAT*2.*N1*N2
            A33ADD = 2.*PRSRAT*FCUR/RDUB
         ENDIF
         IF (ISAND.EQ.2) THEN
            PRSRAT = PRESS0/C11SVE
            A11 = A11 + FXPRE*(N24*M14 + N14*M24)
     1                + FYPRE*(N24*N12*M12 + N14*N22*M22)
            A13 = A13 - PRSRAT*(N22*M12 + N12*M22)
            A22 = A22 + FXPRE*(M12*N22 + M22*N12)
     1                + FYPRE*((N12+N22)*FCUR/RDUB**2 +2.*N12*N22)
     1                + PRSRAT*(N12+N22)*FCUR/RDUB
            A23 = A23 + FYPRE*4.*N1*N2*FCUR/RDUB + PRSRAT*2.*N1*N2
            A33ADD = FYPRE*2.*FCUR/RDUB**2 + 2.*PRSRAT*FCUR/RDUB
         ENDIF
C END MAR 1998
C END AUG 1994
      ENDIF
C    ALTERNATE FORMULATION (PANDA2.NEWS ITEM 68...)
      A11ALT =D11*(M14 +M24) + D33*(N12*M12 +N22*M22)
      A12ALT = -(D12+D33)*(N12*M12 + N22*M22)
      A22ALT = D22*(N14+N24) + D33*(N12*M12 +N22*M22)   
      A13ALT = -D12*(M12+M22)*FCUR/RDUB -D14*(M14 +M24)
     1         -(D15+2.*D36)*(N12*M12 +N22*M22)
      A23ALT = D22*(N12+N22)*FCUR/RDUB +(D24+2.*D36)*(N12*M12 +N22*M22)
     1        +D25*(N14+N24)
      A33 = D22*2.*FCUR/RDUB**2 + 2.*D24*MSUM*FCUR/RDUB
     1 +2.*D25*NSUM*FCUR/RDUB
     1 +D44*(M14+M24) +D55*(N14+N24) +(2.*D45+4.*D66)*(N12*M12+M22*N22)
C BEG JUN 1996 (ADD EFFECT OF ELASTIC FOUNDATION, EFOUND...
C                panda2.news item 271)
C BEG MAR 1998
     1 + PREB + A33ADD + 2.*EFOUND/C11SVE
C END MAR 1998
C END JUN 1996
C
C  ADD TERMS FOR SANDERS "WORK DONE"...
C BEG MAR 1998
      IF (ISAND.EQ.1.OR.ISAND.EQ.2) THEN
C END MAR 1998
         FXSUM = 0.25*(FXPRE+FYPRE)*(N12*M12+N22*M22)
         A11ALT=A11ALT +FXSUM
         A12ALT=A12ALT +FXSUM
         A22ALT=A22ALT +FXSUM +FYPRE*(N12+N22)*FCUR/RDUB**2
         A23ALT=A23ALT +(2.*FYPRE*N1*N2 
     1         + FXYPRE*(N2*M2-N1*M1))*FCUR/RDUB
      ENDIF
C     
C     BRANCH FOR UNBALANCED LAMINATES...  
C
C  IF IBAL = 0, THE CONTRIBUTION OF THE D16 AND D26 TERMS (AND OTHER TERMS
C  TYPICAL OF ANISOTROPIC WALLS) ARE OMITTED. (NEXT STATEMENT IS COMMENTED
C  OUT. IT WAS SET EQUAL TO ZERO ONCE TO DEMONSTRATE THE EFFECT OF THE
C  ANISOTROPIC TERMS IN A CERTAIN CASE WHERE RESULTS FROM PANDA2 WERE BEING
C  COMPARED WITH RESULTS FROM COMPUTER PROGRAMS WRITTEN ELSEWHERE.)
C
C     IBAL = 0
C
      IF (IBAL.EQ.0) GO TO 100
C     
      D13 = C13
      D16 = C16
      D23 = C23
      D26 = C26
      D34 = C34
      D35 = C35
      D46 = C46
      D56 = C56
      IF (RBB.LT.10.) THEN
C   ORIGINAL FORMULATION (Computers and Structures, Vol. 27, 1987,
C                         p. 552, Eqs.(55)...)
         A11 = A11 +2.*D13*(-N24*M13*N1 +N14*M23*N2)     
         A12 = A12 +D13*(N23*M13 -N13*M23)
     1             +D23*(N23*N12*M1 -N13*N22*M2)
         A22 = A22 +2.*D23*(-N1*N22*M1 +N12*N2*M2) 
         A13 = A13 +(2.*D16+D34)*(N22*N1*M13 - N12*N2*M23)     
     1         +D23*(N22*N1M1 -N12*N2M2)*FCUR/RDUB
     1         +D35*(N22*N13*M1-N12*N23*M2)    
         A23 = A23 +(2.*D26+D35)*(-N12*N2*M1 +N22*N1*M2) 
     1         +D23*(-N2*M1 +N1*M2)*FCUR/RDUB +D34*(-N2*M13 +N1*M23)   
C BEG AUG 1994
C  ADD TERMS FOR NON-SHALLOW SHELL EQUATIONS...
C BEG MAR 1998
         IF (ISAND.EQ.1.OR.ISAND.EQ.2) THEN
C END MAR 1998
            A12 =A12 +2.*D16*(N23*M13-N13*M23)*FCUR/RDUB
     1               +D35*(N12*N23*M1-N13*N22*M2)*FCUR/RDUB
            A22 =A22 +4.*D56*(-N1*N22*M1+N12*N2*M2)*FCUR/RDUB**2
     1               +2.*(D35+2.*D26)*(-N1*N22*M1+N12*N2*M2)*FCUR/RDUB
            A23 =A23 +2.*D26*(-N2*M1+N1*M2)*FCUR/RDUB**2
     1               +2.*D46*(-N2*M13+N1*M23)*FCUR/RDUB
     1               +4.*D56*(-N12*N2*M1+N1*N22*M2)*FCUR/RDUB
         ENDIF
C END AUG 1994
      ENDIF
C    ALTERNATE FORMULATION (PANDA2.NEWS ITEM 68...)
      A11ALT = A11ALT +2.*D13*(-M13*N1 +M23*N2)     
C BEG APR 1998
C     A12ALT = A12ALT +D13*(N2*M13 -N1*M23) +D23*(N13*M1 -N23*M2)    
      A12ALT = A12ALT +D13*(N1*M13 -N2*M23) +D23*(N13*M1 -N23*M2)    
C END APR 1998
      A22ALT = A22ALT +2.*D23*(-N13*M1 +N23*M2) 
      A13ALT = A13ALT +(2.*D16+D34)*(N1*M13 - N2*M23)     
     1         +D23*(N1M1 -N2M2)*FCUR/RDUB +D35*(N13*M1-N23*M2)    
      A23ALT = A23ALT +(2.*D26+D35)*(-N13*M1 +N23*M2) 
     1         +D23*(-N1M1 +N2M2)*FCUR/RDUB +D34*(-N1*M13 +N2*M23)   
      A33 = A33 + 4.*D26*(-N1*M1 +N2*M2)*FCUR/RDUB
     1          + 4.*D46*(-N1*M13 +N2*M23) +4.*D56*(-N13*M1 +N23*M2)
C     
C BEG AUG 2003
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (NPREIG.EQ.3) THEN
       WRITE(IFILE,'(A,/,1P,5E12.4)')
     1' MMMBAR,NNNBAR,C,D,R=',MMMBAR,NNNBAR,C,D,R
       WRITE(IFILE,*)' C14,C15,C16,C24,C25,C26=',C14,C15,C16,C24,C25,C26
       WRITE(IFILE,*)' C34,C35,C36,C46,C56,C66=',C34,C35,C36,C46,C56,C66
       WRITE(IFILE,*)' N1,N2,M1,M2=        ',N1,N2,M1,M2
       WRITE(IFILE,*)' N12,N22,M12,M22=    ',N12,N22,M12,M22
       WRITE(IFILE,*)' N1M1,N2M2,NSUM,MSUM=',N1M1,N2M2,NSUM,MSUM
       WRITE(IFILE,*)' N13,N23,M13,M23=    ',N13,N23,M13,M23
       WRITE(IFILE,*)' N14,N24,M14,M24=    ',N14,N24,M14,M24
      ENDIF
C END AUG 2003
C
  100 CONTINUE    
C BEG AUG 2003
      IF (NPREIG.EQ.3) WRITE(IFILE,'(A,I2)')
     1  ' In EIGREG after 100 Cont.: ISAND=',ISAND
C END AUG 2003
C
C BEG AUG 1994
      IF (ISAND.EQ.0) THEN
C END AUG 1994
         A12N = A12ALT/A11ALT
         A22N = A22ALT/A11ALT
         A23N = A23ALT/A22ALT
         A13N = A13ALT/A22ALT
         A12NN= A12ALT/A22ALT
         PROD1 = A23N*(A12N*A13ALT - A23ALT) 
         PROD2 = A13N*(A12N*A23ALT - A13ALT*A22N)  
         PROD3 = 1. - A12NN*A12N 
         NUM = A33 + (PROD1 + PROD2)/PROD3   
         EIGV2 = NUM/DEN
         EIGV1 = EIGV2
C BEG JULY 1995
C        WRITE(8,*)' R,PREB,NUM,DEN   =',R,PREB,NUM,DEN
C        WRITE(8,*)' PROD1,PROD2,PROD3=',PROD1,PROD2,PROD3
C        WRITE(8,*)' A33,EIGV2,EIGV1  =',A33,EIGV2,EIGV1
C END JULY 1995
         IF (RBB.LT.10.) THEN
            A12N = A12/A11    
            A22N = A22/A11    
            A23N = A23/A22    
            A13N = A13/A22    
            A12NN= A12/A22     
            PROD1 = A23N*(A12N*A13 - A23) 
            PROD2 = A13N*(A12N*A23 - A13*A22N)  
            PROD3 = 1. - A12NN*A12N 
            NUM = A33 + (PROD1 + PROD2)/PROD3   
            EIGV1 = NUM/DEN
         ENDIF
         EIGVAL = MIN(EIGV1,EIGV2)
C BEG MAR 2005
C        IF (NPREIG.EQ.3)
C    1      WRITE(8,*)' IBAL,A33,PROD1,PROD2,PROD3,NUM,DEN=',
C    1                  IBAL,A33,PROD1,PROD2,PROD3,NUM,DEN
C END MAR 2005
C
C BEG AUG 1994
C
      ELSE
C
C SANDERS' EQUATION IMPLEMENTATION. THE EIGENVALUE PROBLEM REPRESENTS
C SOLUTION OF A 3X3 REAL SYMMETRIC SYSTEM: Ax + lambda*Bx = 0. SETTING
C THE DETERMINANT OF [A + lambda*B] TO ZERO YIELDS A CUBIC EQUATION
C WHICH IS SOLVED FOR THE SMALLEST EIGENVALUE lambda (called EIGSAN).
C
C BEG FEB 1998 (RDUB = double precision version of radius R)
         IF (RBB.LT.10.) THEN
C BEG MAR 1998
          IF (ISAND.EQ.1) THEN
            PRSRAT = PRESSR/C11SVE
            FXSUM = FXXEIG + FYYEIG
            B11 = FXSUM*0.25*(N24*N12*M12+N14*N22*M22)
            B13 =-PRSRAT*(N22*M12 + N12*M22)
            B12 = FXSUM*0.25*(N23*N1*M12+N13*N2*M22)
            B22 = FXSUM*0.25*(N22*M12+N12*M22)
     1           +FYYEIG*(N22+N12)*FCUR/RDUB**2
     1           +PRSRAT*(N12+N22)*FCUR/RDUB
            B23 = (2.*FYYEIG*N1*N2 + FXYEIG*(N1*M2-N2*M1))*FCUR/RDUB
     1           +PRSRAT*2.*N1*N2
            B33ADD = 2.*PRSRAT*FCUR/RDUB
          ENDIF
          IF (ISAND.EQ.2) THEN
            PRSRAT = PRESSR/C11SVE
            B11 = FXXEIG*(N24*M14 + N14*M24)
     1           +FYYEIG*(N24*N12*M12 + N14*N22*M22)
     1        +2.*FXYEIG*(N14*N2*M23 - N24*N1*M13)
            B13 =-PRSRAT*(N22*M12 + N12*M22)
            B22 = FXXEIG*(M12*N22 + M22*N12)
     1           +FYYEIG*((N12+N22)*FCUR/RDUB**2 +2.*N12*N22)
     1        +2.*FXYEIG*(N12*N2*M2 - N22*N1*M1)
     1           +PRSRAT*(N12+N22)*FCUR/RDUB
            B23 = FYYEIG*4.*N1*N2*FCUR/RDUB
     1           +FXYEIG*2.*(N1*M2 - N2*M1)*FCUR/RDUB
     1           +PRSRAT*2.*N1*N2
            B33ADD = FYYEIG*2.*FCUR/RDUB**2 + 2.*PRSRAT*FCUR/RDUB
          ENDIF
C END MAR 1998
         ELSE
            FXSUM = 0.25*(FXXEIG+FYYEIG)*(N12*M12+N22*M22)
            B11 = FXSUM
            B12 = FXSUM
            B22 = FXSUM +FYYEIG*(N12+N22)*FCUR/RDUB**2
            B23 = (2.*FYYEIG*N1*N2 + FXYEIG*(N2*M2-N1*M1))*FCUR/RDUB
         ENDIF
C END FEB 1998
C BEG MAR 1998
         B33 = -DEN + B33ADD
C END MAR 1998
         IF (RBB.LT.10.) THEN
C BEG AUG 2003
            IF (NPREIG.EQ.3) THEN
               WRITE(IFILE,'(A,1P,3E12.4)')' A11,A12,A13=',A11,A12,A13
               WRITE(IFILE,*)' A22,A23,A33=',A22,A23,A33
               WRITE(IFILE,*)' B11,B12,B22=',B11,B12,B22
               WRITE(IFILE,*)' B23,B33,RBB=',B23,B33,RBB
            ENDIF
            CALL CUBEIG(IFILE,A11,A12,A13,A22,A23,A33,
     1                    B11,B12,B13,B22,B23,B33,1,EIGSAN,NPREIG)
         ELSE
C23456789012345678901234567890123456789012345678901234567890123456789012
            IF (NPREIG.EQ.3) THEN
               WRITE(IFILE,*)' A11ALT,A12ALT,A13ALT=',
     1                                             A11ALT,A12ALT,A13ALT
               WRITE(IFILE,*)' A22ALT,A23ALT,A33   =',A22ALT,A23ALT,A33
               WRITE(IFILE,*)' B11,B12,B22         =',B11,B12,B22
               WRITE(IFILE,*)' B23,B33,RBB         =',B23,B33,RBB
            ENDIF
            CALL CUBEIG(IFILE,A11ALT,A12ALT,A13ALT,A22ALT,A23ALT,A33,
     1                    B11,B12,B13,B22,B23,B33,1,EIGSAN,NPREIG)
C END AUG 2003
         ENDIF
         EIGVAL = EIGSAN
      ENDIF
      RETURN
      END
C
C
C
C=DECK      CUBEIG
C BEG MAR 1998
      SUBROUTINE CUBEIG(IFILE,A11,A12,A13,A22,A23,A33,
     1                  B11,B12,B13,B22,B23,B33,NEIGEN,EIG,NPRINT)
C END MAR 1998
C 
C  PURPOSE IS TO FIND THE EIGENVALUE  EIG  GIVEN THE ELEMENTS A11,
C  A12,... B11,B12,... OF THE 3X3 REAL SYMMETRIC MATRIX. THE LOWEST
C
C BEG AUG 1996
C     COMMON/NDEBUG/NPRNT
C     DOUBLE PRECISION CONST,CLIN,CQUAD,CUBIK
C END AUG 1996
C BEG FEB 1998
      DOUBLE PRECISION AMAX,BMAX
      DOUBLE PRECISION A11,A12,A13,A22,A23,A33
      DOUBLE PRECISION B11,B12,B13,B22,B23,B33
C END FEB 1998
      DOUBLE PRECISION A,B,EIGLOC,EIGVEC
      DIMENSION A(3,3),B(3,3),EIGLOC(3),EIGVEC(3,3)
C
      BMAX = MAX(ABS(B33),ABS(B23))
      BMAX = MAX(BMAX,ABS(B22))
C BEG FEB 1998
      BMAX = MAX(BMAX,ABS(B13))
C END FEB 1998
      BMAX = MAX(BMAX,ABS(B12))
      BMAX = MAX(BMAX,ABS(B11))
C BEG MAR 1998
      IF (BMAX.EQ.0.0) THEN
         EIG = 10.E+25
         RETURN
      ENDIF
C END MAR 1998
      B11 = B11/BMAX
      B12 = B12/BMAX
C BEG MAR 1998
      B13 = B13/BMAX
C END MAR 1998
      B22 = B22/BMAX
      B23 = B23/BMAX
      B33 = B33/BMAX
C
      AMAX = MAX(ABS(A11),ABS(A12))
      AMAX = MAX(AMAX,ABS(A13))
      AMAX = MAX(AMAX,ABS(A22))
      AMAX = MAX(AMAX,ABS(A23))
      AMAX = MAX(AMAX,ABS(A33))
      A11  = A11/AMAX
      A12  = A12/AMAX
      A13  = A13/AMAX
      A22  = A22/AMAX
      A23  = A23/AMAX
      A33  = A33/AMAX
C
      A(1,1) = A11
      A(1,2) = A12
      A(1,3) = A13
      A(2,1) = A12
      A(2,2) = A22
      A(2,3) = A23
      A(3,1) = A13
      A(3,2) = A23
      A(3,3) = A33
C
      B(1,1) = -B11
      B(1,2) = -B12
C BEG MAR 1998
      B(1,3) = -B13
C END MAR 1998
      B(2,1) = -B12
      B(2,2) = -B22
      B(2,3) = -B23
C BEG MAR 1998
      B(3,1) = -B13
C END MAR 1998
      B(3,2) = -B23
      B(3,3) = -B33
C
C BEG JULY 1995
      IF (NPRINT.GE.3) THEN
         WRITE(IFILE,*) ' AMAX,BMAX=',AMAX,BMAX
         WRITE(IFILE,*) ' A11,A12,A13=',A(1,1),A(1,2),A(1,3)
         WRITE(IFILE,*) ' A21,A22,A23=',A(2,1),A(2,2),A(2,3)
         WRITE(IFILE,*) ' A31,A32,A33=',A(3,1),A(3,2),A(3,3)
         WRITE(IFILE,*) ' B11,B12,B13=',B(1,1),B(1,2),B(1,3)
         WRITE(IFILE,*) ' B21,B22,B23=',B(2,1),B(2,2),B(2,3)
         WRITE(IFILE,*) ' B31,B32,B33=',B(3,1),B(3,2),B(3,3)
      ENDIF
C END JULY 1995
      CALL EIGENZ(IFILE,3,NEIGEN,A,B,EIGLOC,EIGVEC,NPRINT)
      EIG = EIGLOC(1)*AMAX/BMAX
C BEG AUG 1996
C  SOMETHING NOT RIGHT WITH EIGENZ FOR THE CASE "BETA" = 0. SET UP
C  CUBIC EQUATION AND SOLVE, THE WAY THAT IS DONE IN ARBOCZ....
C
C     CONST = A13*(A12*A23 - A13*A22 + A23*A12) -A23*A23*A11
C    1       +A33*(A11*A22 - A12*A12)
C
C     CLIN  = A13*(A13*B22 - A23*B12 - A12*B23 - A23*B12)
C    1       +A23*(A23*B11 + A11*B23) +B23*(A11*A23 - A13*A12)
C    1       +A33*(2.*A12*B12 - A22*B11 - A11*B22) 
C    1       -B33*(A11*A22 - A12*A12)
C
C     CQUAD = B23*(2.*A13*B12 - 2.*A23*B11 - A11*B23)
C    1       +A33*(B11*B22 - B12*B12)
C    1       -B33*(2.*A12*B12 - B11*A22 - A11*B22)
C
C     CUBIK = B23*B23*B11 - B33*(B11*B22 - B12*B12)
C
C     CALL CUBIC(CONST,-CLIN,CQUAD,-CUBIK,EIGV1)
C     IF (NPRNT.NE.0) WRITE(8,*)' CONST,CLIN,CQUAD,CUBIK,EIGV1=',
C    1                            CONST,CLIN,CQUAD,CUBIK,EIGV1
C END AUG 1996
C BEG NOV 1994
C BEG MAR 1998
      IF (EIG.LE.0.0) EIG = EIGLOC(2)*AMAX/BMAX
      IF (EIG.LE.0.0) EIG = EIGLOC(3)*AMAX/BMAX
      IF (EIG.LE.0.0) EIG = 10.E+16
C END MAR 1998
C END NOV 1994
C BEG JULY 1995
      IF (NPRINT.GE.3) THEN
         EIG1 = EIG
         EIG2 = EIGLOC(2)*AMAX/BMAX
         EIG3 = EIGLOC(3)*AMAX/BMAX
         WRITE(8,*) ' EIG1,EIG2,EIG3=',EIG1,EIG2,EIG3
      ENDIF
C END JULY 1995
      RETURN
      END
C
C
C
C=DECK      EIGROL  
      SUBROUTINE EIGROL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,SLOPE,IDESGN,
C BEG MAY 1997
     1  EIGVAL,INDX,FFLAT,IAGAIN,IFINAL)
C END MAY 1997
C     
C     COMPUTE BUCKLING LOAD OF SIMPLY-SUPPORTED CYLINDRICAL PANEL 
C     WITH BIAXIAL IN-PLANE LOADING AND IN-PLANE SHEAR.     
C     
C     INCLUDE ROLLING OF STIFFENERS...
C
C     A = PANEL HEIGHT  (AXIAL DIRECTION) 
C     B = PANEL WIDTH (IN CIRCUMFERENTIAL DIRECTION)  
C  NBAR = NUMBER OF HALF WAVES IN CIRCUMFERENTIAL DIRECTION IN WIDTH, B 
C  MBAR =  UMBER OF HALF WAVES IN AXIAL DIRECTION IN HEIGHT, A    
C EIGVAL = EIGENVALU (LAMBDA) 
C     
C BEG FEB 1998
C23456789012345678901234567890123456789012345678901234567890123456789012
      DOUBLE PRECISION N1,M1,N2,M2,N12,N22,M12,M22,N14,N24,M14,M24,MC,ND
      DOUBLE PRECISION M,N,MSUM,NSUM,N13,N23,M13,M23,N1M1,N2M2,NMDIF,PI
      DOUBLE PRECISION PREB,DEN
      REAL MBAR,NBAR,NUM,NCYL
C END FEB 1998
C BEG JUN 2006
      COMMON/AXLRDX/AXLRED
      COMMON/ILABLZ/ILABLW
C END JUN 2006
C BEG JUL 1999
      COMMON/ILABLX/ILABLY
C END JUL 1999
      REAL NXPRE,NYPRE,NXYPRE 
      REAL NXEIG,NYEIG,NXYEIG 
C BEG FEB 1996
      COMMON/IRESTX/IRESTY
C END FEB 1996
      COMMON/ROLLIT/NSTOT,NRTOT,IROLL(9,9,2),FNUM(9,2),FDEN(9,2)  
      COMMON/CMOD/CC(6,6)     
      COMMON/NDEBUG/NPRNT
C BEG AUG 2003
      COMMON/NPRNTX/NPRROL
C END AUG 2003
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN
      COMMON/C11SAV/C11SVE
      COMMON/GENLOC/NXFIX,NYFIX,NXYFIX,TEST,E0XP,E0YP 
C BEG AUG 1994
      COMMON/MEMSTS/FXPRE,FYPRE,FXYPRE,FXXEIG,FYYEIG,FXYEIG
C BEG JUN 1996
      COMMON/ISANDR/ISAND,ISANDS
C END JUN 1996
C END AUG 1994
      COMMON/CWALL/C11,C12,C22,C33,C44,C45,C55,C66    
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL     
      COMMON/WALLD/AK1,AK2,A44,A45,A55,ITRANS(4)
      COMMON/ENEMS/N1,N2,M1,M2,N12,N22,M12,M22,N1M1,N2M2,NSUM,MSUM
      REAL NXFIX,NYFIX,NXYFIX 
C BEG JUL 1999
      REAL NXFIXS,NYFIXS,NXEIGS,NYEIGS
      COMMON/IEIGNN/IEIGN1,IEIGN2
C END JUL 1999
      COMMON/DESVAR/ISPACS(4),R     
      REAL NXY0,NXYNRM,NXYSKN 
      COMMON/GEOM2/BB(2),BB2(2),HH(2),WW(2),WW2(2)
      COMMON/ISKPL/ISKIPL,IRMOD,IBLL,ICD7,ICD8,ICD9
      COMMON/ITESTX/ITEST,IAMPOV(4)
      COMMON/RADIMP/RADMOD,FNWAVX,EIGNOS,FNWNOS,RORIG,W0LOC,
     1              W0GLOB,WG1,WG2
      COMMON/RADIM2/WYYAMP,W0PAN,WYYGEN,WYYPAN,WYYLOC
      COMMON/GEOM3/ISTIF(2),NLAYER(4,2),NSEG(2),INTEXT(2)
      COMMON/BARRAY/B1(30),B2(30),BS1(6),BS2(6),ASH(4),K(25),
     1              B1ALT(30),B2ALT(30)
      COMMON/MISCLN/NMATEL,IFLAT,DENS(10) 
      COMMON/ECHECK/ICHECK
      DIMENSION EIGALL(200),SLPALL(200)
C BEG JUNE 1995
      REAL NSTAR
C END JUNE 1995
C BEG NOV 1995
      COMMON/FNSTR/FNSTAR
C END NOV 1995
      REAL K
      DIMENSION FENGY(2),FWORK(2)
C     
      IF (ITRANS(INDX).GT.0) CALL MOVER(0.,0,B1,1,161)
      EIGVAL = 10.E16   
      EIGSAV = EIGVAL   
      SLOPSV = SLOPE    
      SLOP0 = SLOPE
C BEG JUL 1999
      IBACKB = 0
C END JUL 1999
      PI = 3.141592654
      M = MBAR*PI/A     
      N = NBAR*PI/B     
C BEG JUN 1999
      DELSLP = 0.
      IF (ISAND.EQ.0.AND.NBAR.LT.0.00001) DELSLP = 0.00001
C END JUN 1999
C BEG FEB 1998
      FM = M
C END FEB 1998
C BEG JUNE 1995
      RSAVE = R
      FYEIG = NYEIG
C  REMOVE IF (IRMOD.NE.0) THEN ... ENDIF FROM HERE AND INSERT IT AFTER
C  10 CONTINUE...
C END JUNE 1995
C BEG MAR 1998
C     IF (NPRNT.EQ.INDX) WRITE(8,'(A,1P,4E12.4)')
C    1' BEFORE STFROL, M,N,MBAR,NBAR = ', M,N,MBAR,NBAR
C END MAR 1998
      CALL STFROL(M,N,FENGY,FWORK,CS,CR,BS,BR,A,B,INDX,MBAR,NBAR)
C BEG MAR 1998
C BEG JUN 2004
C     IF (NPRNT.EQ.INDX) THEN
C        WRITE(8,'(A,/,1P,6E12.4)')
C    1 ' AFTER STFROL, CS,CR,BS,BR,FENGY(1),FENGY(2)=',
C    1                 CS,CR,BS,BR,FENGY(1),FENGY(2)
C        WRITE(8,'(A,/,1P,4E12.4)')
C    1 ' MBAR,NBAR,FWORK(1),FWORK(2)=',
C    1   MBAR,NBAR,FWORK(1),FWORK(2)
C        CALL EXIT
C     ENDIF
C END JUN 2004
C END MAR 1998
      KOUNT = 0   
      KOUNT2 = 0
      DONNEL = 1. 
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
      NXPRE = NXFIX/DONNEL    
      NYPRE = NYFIX/DONNEL    
      NXYPRE = NXYFIX/DONNEL  
C BEG AUG 1994
      FXPRE = NXPRE
      FYPRE = NYPRE
      FXYPRE= NXYPRE
      FXXEIG= NXEIG
      FYYEIG= NYEIG
      FXYEIG= NXYEIG
C     ISAND = 1
      ITRANS(INDX) = 0
C END AUG 1994
      SUM = NXYPRE + NXYEIG   
      SGN = 1.0   
      IF (SUM.LT.0.0) SGN = -1.0    
      FINCR = 0.01*SGN  
C BEG MAY 1997
      FPROD0 = 1.2
      IF (IFINAL.EQ.1) FPROD0 = 1.02
      FPROD = FPROD0
C END MAY 1997
      ITHRU = 0
      ICHECS = 0
      SLPMAX = 30.
C BEG APR 1998
      IBACK = 0
C END APR 1998
C     
   10 CONTINUE    
C   THE STATEMENT "KOUNT2 = KOUNT2 + 1"  TRANSFERRED FURTHER DOWN.
C BEG JUN 1999
      D = SLOPE + DELSLP
      C = 0.0     
      IF (TEST.GT.0.99) D = 0. 
      IF (TEST.GT.0.99) C = SLOPE + DELSLP
C END JUN 1999
C BEG JUNE 1995
C  CALCULATE RADIUS OF CURVATURE AS MODIFIED BY INITIAL LOCAL OR GLOBAL
C  IMPERFECTION W0 AND CIRCUMFERENTIAL WAVENUMBER PARAMETER N.
C     
      IF (IRMOD.NE.0) THEN
         NSTAR = N
C        IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + ABS(D)/M)
C BEG NOV 1995
C        IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + 1.00*ABS(D)/M)
         IF (N.GT.0.AND.M.GT.0) NSTAR = 1./(1./N + FNSTAR*ABS(D)/M)
C END NOV 1995
         AMPMOD = 1.0
         WGARG = WG1
         IF (IRMOD.EQ.1) THEN
            WIMPX = W0LOC
            IF (ISTIF(1).NE.0.OR.ISTIF(2).NE.0) WGARG = 0.
         ENDIF
         IF (IRMOD.EQ.2.OR.IRMOD.EQ.4) WIMPX = WG2
         IF (IRMOD.EQ.3) THEN
            WIMPX = W0PAN
            IF (ISTIF(2).NE.0) WGARG = 0.
         ENDIF
         IF (ABS(WIMPX).GT.0.0.AND.N.GT.0.0.AND.M.GT.0.0)
C BEG FEB 1998
C BEG APR 1998
C    1      AMPMOD = ABS(0.1/WIMPX)*MIN(1./FM,1./NSTAR)
     1      AMPMOD = ABS(0.2/WIMPX)*MIN(1./FM,1./NSTAR)
C END APR 1998
C END FEB 1998
         IF (AMPMOD.GT.1.0) AMPMOD = 1.0
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG JUN 2004
C  IRMOD = 1 means local buckling; 2 means general buck.; 3 means panel buck.
         IF (IRMOD.EQ.1.AND.
     1                 (W0LOC.NE.0.0.OR.WYYGEN.NE.0.0.OR.WYYPAN.NE.0.)) 
     1      CALL RADWAV(ABS(WYYGEN)+ABS(WYYPAN),RORIG,WYYAMP,
     1                 AMPMOD*W0LOC,NSTAR,R,WGARG,IAMPOV(IRMOD))
C BEG JUN 2006
C        IF ((IRMOD.EQ.2.OR.IRMOD.EQ.4).AND.W0GLOB.NE.0.)
C    1      CALL RADWAV(0.0,RORIG,WYYAMP,AMPMOD*WG2,NSTAR,R,
         IF ((IRMOD.EQ.2.OR.IRMOD.EQ.4).AND.W0GLOB.NE.0.) THEN
            FMULT = 1.0
C BEG AUG 2006
C BEG AUG 2006
C           IF (IFLAT.EQ.0.AND.ILABLW.EQ.7165.AND.ILABLY.EQ.9160)
            IF (IFLAT.EQ.0.AND.(ILABLW.EQ.7165.OR.ILABLW.EQ.7175)
     1                                       .AND.ILABLY.EQ.9160)
C END AUG 2006
     1      FMULT = AXLRED
            CALL RADWAV(0.0,RORIG,WYYAMP,FMULT*AMPMOD*WG2,NSTAR,R,
     1                  WGARG,IAMPOV(IRMOD))
         ENDIF
C END JUN 2006
C END JUN 2004
         IF (IRMOD.EQ.3.AND.(W0PAN.NE.0.0.OR.WYYGEN.NE.0.0))
     1      CALL RADWAV(WYYGEN,RORIG,WYYAMP,AMPMOD*W0PAN,NSTAR,R,WGARG,
     1                  IAMPOV(IRMOD))
         IF (FYEIG.LT.0.0.AND.
     1    ((IRMOD.EQ.2.OR.IRMOD.EQ.4).OR.
     1     (ISTIF(1).EQ.0.AND.ISTIF(2).EQ.0))) THEN
            NYEIG = FYEIG*ABS(R/RORIG)
            IF (ABS(NYEIG).GT.ABS(1.12*FYEIG)) NYEIG = 1.12*FYEIG
            IF (ABS(NYEIG).LT.ABS(FYEIG)) NYEIG = FYEIG
         ENDIF
C        WRITE(8,*)' IN EIG1: IRMOD,WYYAMP,W0LOC,W0GLOB,B,NBAR,R=',
C    1                        IRMOD,WYYAMP,W0LOC,W0GLOB,B,NBAR,R
C        WRITE(8,*)' ISTIF(2),A,MBAR,DLONG,BB(2),AMPMOD=',
C    1               ISTIF(2),A,MBAR,DLONG,BB(2),AMPMOD
      ENDIF
C END JUNE 1995
      MC = M*C    
      ND = N*D    
      N1 = N+MC   
      N2 = N-MC   
      M1 = M+ND   
      M2 = M-ND   
C     
      N12 = N1*N1 
      N22 = N2*N2 
      M12 = M1*M1 
      M22 = M2*M2 
      MSUM = M12 + M22  
      NSUM = N12 + N22  
      N1M1 = N1*M1
      N2M2 = N2*M2
      NMDIF= N2M2 -N1M1 
C     
C     IF (IFLAT.EQ.0) 
C    1      PREB = NXPRE*MSUM + NYPRE*NSUM + 2.*NXYPRE*NMDIF
C    1           + CS*FENGY(1)  +  CR*FENGY(2)
C     IF (IAGAIN.NE.2.AND.(IFLAT.NE.0.OR.FFLAT.GT.0.5))
C    1      PREB = NXPRE*2.*M*M + NYPRE*2.*N*N + 2.*NXYPRE*NMDIF
C    1           + CS*FENGY(1)  +  CR*FENGY(2)
C
C     IF (IFLAT.EQ.0)
C    1      DEN = -NXEIG*MSUM - NYEIG*NSUM -2.*NXYEIG*NMDIF 
C    1            -CS*BS**2*(FWORK(1) + FDEN(1,1))  
C    1            -CR*BR**2*(FWORK(2) + FDEN(1,2))  
C     IF (IAGAIN.NE.2.AND.(IFLAT.NE.0.OR.FFLAT.GT.0.5))
C    1      DEN = -NXEIG*2.*M*M - NYEIG*2.*N*N -2.*NXYEIG*NMDIF 
C    1            -CS*BS**2*(FWORK(1) + FDEN(1,1))  
C    1            -CR*BR**2*(FWORK(2) + FDEN(1,2))  
            PREB = NXPRE*MSUM +NYPRE*NSUM +2.*NXYPRE*NMDIF
     1           + CS*FENGY(1)  +  CR*FENGY(2)
             DEN = -NXEIG*MSUM -NYEIG*NSUM -2.*NXYEIG*NMDIF
     1            -CS*BS**2*(FWORK(1) + FDEN(1,1))  
     1            -CR*BR**2*(FWORK(2) + FDEN(1,2))  
C BEG JAN 1996
      NEGDEN = 0
C BEG MAR 1998
C     IF (NPRNT.EQ.INDX) THEN
C        WRITE(8,'(A,1P,4E12.4)') ' DEN,NXEIG,NYEIG,NXYEIG=',
C    1                              DEN,NXEIG,NYEIG,NXYEIG
C        WRITE(8,'(A,1P,4E12.4)') ' PREB,MSUM,NSUM,NMDIF=',
C    1                              PREB,MSUM,NSUM,NMDIF
C        WRITE(8,'(A,1P,4E12.4)') ' CS,BS,FWORK(1),FDEN(1,1)=',
C    1                              CS,BS,FWORK(1),FDEN(1,1)
C        WRITE(8,'(A,1P,4E12.4)') ' CR,BR,FWORK(2),FDEN(1,2)=',
C    1                              CR,BR,FWORK(2),FDEN(1,2)
C     ENDIF
      IF (DEN.LE.0.0.AND.ISAND.EQ.0) THEN
C END MAR 1998
         NEGDEN = 1
         IF (NPRNT.EQ.INDX) WRITE(8,'(A,/,3I3,1P,4E10.2)')
     1    ' NEG.DEN: ISHEAR,IBAL,KOUNT,SLOPE,MBAR,NBAR,EIGVAL=',
     1               ISHEAR,IBAL,KOUNT,SLOPE,MBAR,NBAR,EIGVAL
C        IF (ISHEAR.EQ.0) GO TO 300 
         IF (ISHEAR.EQ.0.AND.IBAL.EQ.0) GO TO 300 
C        IF (ABS(SLOPE).GT.5.) GO TO 300  
         IF (ABS(SLOPE).GT.21.) GO TO 300
         IF (ITHRU.EQ.0.AND.ABS(SLOPE).GT.5.) GO TO 300  
C BEG APR 1998
         IF (IDESGN.EQ.1.AND.IBACK.EQ.0) GO TO 320
C END APR 1998
C        IF (KOUNT.GT.0)  GO TO 300
         IF (ITHRU.EQ.0.AND.KOUNT.GT.0)  GO TO 300
C        IF (ISHEAR.NE.0) GO TO 110 
         IF (ISHEAR.NE.0.OR.IBAL.NE.0) GO TO 110 
C END JAN 1996
      ENDIF
      EIGSVV = EIGSAV   
      EIGSAV = EIGVAL   
      KOUNT = KOUNT + 1 
      KOUNT2 = KOUNT2 + 1
C BEG JUL 1999
   14 CONTINUE
C END JUL 1999
      IF (ITRANS(INDX).EQ.0) GO TO 20     
C     
C      EIGENVALUE WITH TRANSVERSE SHEAR DEFORMATION OF STIFFENER WEB... 
C     
      CALL FILLLB(R,B,B1,B2,BS1,BS2,ASH,FFLAT,IAGAIN,B1ALT,B2ALT)
      IORDER = 5
      CALL EIGSHR(EIGV2,CC,B1ALT,B2ALT,BS1,BS2,ASH,IORDER,K,PREB,DEN,  
     1 NBAR,MBAR,SLOPE)
      EIGV1 = EIGV2
      RBB = ABS(R)/ABS(B)
      IF (IAGAIN.NE.2.AND.FFLAT.GT.0.5) RBB = 10000.
      IF (RBB.LT.10.)
     1   CALL EIGSHR(EIGV1,CC,B1,B2,BS1,BS2,ASH,IORDER,K,PREB,DEN,  
     1   NBAR,MBAR,SLOPE)
      EIGVAL = MIN(EIGV1,EIGV2)
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
      EIGVAL = DONNEL*EIGVAL
      GO TO 30    
C     
   20 CONTINUE    
C     
C      EIGENVALUE WITHOUT TRANSVERSE SHEAR DEFORMATION EFFECT...  
C
C BEG JULY 1995
C BEG AUG 2003
      NPRROL = 0
      CALL EIGREG(EIGVAL,PREB,DEN,B,FFLAT,IAGAIN,NBAR,MBAR,SLOPE,
     1            NPRROL,8)
C END AUG 2003)
C END JULY 1995
      CALL DONELL(A,B,NBAR,MBAR,NXEIG,NYEIG,NXYEIG,DONNEL,
C BEG JUNE 1995
     1           FFLAT,IAGAIN,INDX,RORIG)
C END JUNE 1995
      EIGVAL = DONNEL*EIGVAL
C     
   30 CONTINUE    
C     IF (NPRNT.EQ.INDX) WRITE(8,7010) NBAR,MBAR,SLOPE,EIGVAL
      IF (EIGVAL.LT.0.0) THEN
C BEG JUL 1999
         WRITE(8,'(/,A,/,A,I5,A)')' ********* WARNING ***********',
     1 ' Negative eigenvalue at location',ILABLY,' in STRUCT'
         IF (IEIGN2.EQ.0) THEN
C END JUL 1999
            DETTER = C11SVE**2*(C11*C22 - C12*C12)
            WRITE(8,15) INDX,A,B,NBAR,MBAR,SLOPE,EIGVAL,
     1                               NXFIX*C11SVE,NYFIX*C11SVE,
     1                               NXYFIX*C11SVE,NXEIG*C11SVE,
     1                               NYEIG*C11SVE,NXYEIG*C11SVE
            WRITE(8,151) C11*C11SVE,C22*C11SVE,C33*C11SVE,C44*C11SVE,
     1                   C55*C11SVE,C66*C11SVE,DETTER
C
   15    FORMAT(//' ************* NEGATIVE BUCKLING LOAD(S) **********'/
     1' We are now in the PANDA-type (closed form) analysis branch.'/
     1' We are now in SUBROUTINE EIGROL. Relevant parameters have the'/
     1' the following values:'/
     1'   Indicator for type of buckling, INDX               =',I10/
     1'    (1=local; 2=general; 3=smeared stringers; 4=smeared rings)'/
     1'   Axial length of part of panel being evaluated, a   =',1PE12.4/
     1'   Circ. length of part of panel being evaluated, b   =',1PE12.4/
     1'   Number of circumferential halfwaves in this part, n=',1PE12.4/
     1'   Number of      axial      halfwaves in this part, m=',1PE12.4/
     1'   Slope of the buckling nodal lines, SLOPE           =',1PE12.4/
     1'   Buckling load factor, EIGVAL                       =',1PE12.4/
     1'   Fixed axial resultant (Load Set B),         Nx(pre)=',1PE12.4/
     1'   Fixed hoop  resultant (Load Set B),         Ny(pre)=',1PE12.4/
     1'   Fixed shear resultant (Load Set B),        Nxy(pre)=',1PE12.4/
     1'   Eigenvalue axial resultant (Load Set A),    Nx(eig)=',1PE12.4/
     1'   Eigenvalue hoop  resultant (Load Set A),    Ny(eig)=',1PE12.4/
     1'   Eigenvalue shear resultant (Load Set A),   Nxy(eig)=',1PE12.4)
  151       FORMAT (/,   
     1' Tangent stiffness terms, CTAN...'/
     1'   Axial stiffness,                             C(1,1)=',1PE12.4/
     1'   Hoop  stiffness,                             C(2,2)=',1PE12.4/
     1'   In-plane shear stiffness,                    C(3,3)=',1PE12.4/
     1'   Axial bending  stiffness,                    C(4,4)=',1PE12.4/
     1'   Hoop  bending  stiffness,                    C(5,5)=',1PE12.4/
     1'   Torsional      stiffness,                    C(6,6)=',1PE12.4/
     1'   C11*C22 - C12**2 (must be positive!) C11*C22-C12**2=',1PE12.4)
C
            WRITE(8,16)
   16       FORMAT(/' CHECK FOR THE FOLLOWING:'/
     1'   1. Are the signs of your applied loads correct?'/
     1'   2. Do you have a Load Set B that is more than large enough'/
     1'      to cause buckling by itself? (If you suspect that the'/
     1'      pressure is causing this trouble, rerun with the pressure'/
     1'      in Load Set A instead of Load Set B.)'/
     1'   3. Are thermal resultants large enough to cause buckling by'/
     1'      themselves? (If so, move thermal loads to Load Set A).'/
     1'   4. Are any terms on the diagonal of the tangent stiffness'/
     1'      matrix CTAN negative? If so, there is something wrong'/
     1'      with the calculation of the constitutive law. (Contact'/
     1'      Dave Bushnell, (415) 424-3237 ).'/
     1'   5. Is C11*C22 - C12**2 negative? If so, there is something'/
     1'      wrong with the local postbuckling solution (contact Dave'/
     1'      Bushnell, (415) 424-3237).'//
     1' IF THE DIFFICULTY IS NOT ITEMS 4 OR 5, YOU MIGHT FIRST TRY TO'/
     1' AVOID THE PROBLEM BY INCREASING THE LOAD COMPONENTS IN'/
     1' LOAD SET A.'/)
C BEG JUL 1999
         ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NXFIX.LT.-0.0001.OR.NYFIX.LT.-0.0001) THEN
            IF (IEIGN2.EQ.0) WRITE(8,'(A,/,A,/,A)')
     1    ' Either Nx(fixed) or Ny(fixed) is significant and negative.',
     1    ' Therefore, the negative "fixed" loads (Load Set B) will be',
     1    ' included with the "eigenvalue" loads (Load Set A) for the',
     1    ' remainder of the execution of SUBROUTINE EIG1 in this case.'
            IBACKB = 1
            FNXMLT = 1.
            FNYMLT = 1.
            IF (NXFIX.GT.0.0) FNXMLT = 0.
            IF (NYFIX.GT.0.0) FNYMLT = 0.
            NXFIXS = NXFIX
            NYFIXS = NYFIX
            NXEIGS = NXEIG
            NYEIGS = NYEIG
            NXEIG = FNXMLT*NXFIXS + NXEIGS
            NYEIG = FNYMLT*NYFIXS + NYEIGS
            NXFIX = (1. - FNXMLT)*NXFIXS
            NYFIX = (1. - FNYMLT)*NYFIXS
            NXPRE = NXFIX/DONNEL    
            NYPRE = NYFIX/DONNEL    
            FXPRE = NXPRE
            FYPRE = NYPRE
            FXXEIG= NXEIG
            FYYEIG= NYEIG
            PREB = NXPRE*MSUM +NYPRE*NSUM +2.*NXYPRE*NMDIF
     1           + CS*FENGY(1)  +  CR*FENGY(2)
             DEN = -NXEIG*MSUM -NYEIG*NSUM -2.*NXYEIG*NMDIF
     1            -CS*BS**2*(FWORK(1) + FDEN(1,1))  
     1            -CR*BR**2*(FWORK(2) + FDEN(1,2))  
            IF (IEIGN2.EQ.0) WRITE(8,152) NXFIX*C11SVE,NYFIX*C11SVE,
     1                                    NXYFIX*C11SVE,NXEIG*C11SVE,
     1                                    NYEIG*C11SVE,NXYEIG*C11SVE
  152    FORMAT(/' ************* NEW LOADING **********'/
     1'   Fixed axial resultant (Load Set B),         Nx(pre)=',1PE12.4/
     1'   Fixed hoop  resultant (Load Set B),         Ny(pre)=',1PE12.4/
     1'   Fixed shear resultant (Load Set B),        Nxy(pre)=',1PE12.4/
     1'   Eigenvalue axial resultant (Load Set A),    Nx(eig)=',1PE12.4/
     1'   Eigenvalue hoop  resultant (Load Set A),    Ny(eig)=',1PE12.4/
     1'   Eigenvalue shear resultant (Load Set A),   Nxy(eig)=',1PE12.4)
            IEIGN2 = 1
            GO TO 14
         ENDIF
C END JUL 1999
C
C BEG FEB 1996
C BEG FEB 1999
         CALL LOADBA(12)
C END FEB 1999
         IF (IRESTY.EQ.1) THEN
            WRITE(8,*)' THIS MESSAGE PRINTED FROM SUBROUTINE EIGROL.'
            WRITE(8,7012) MBAR,NBAR,SLOPE,EIGVAL
 7012       FORMAT(
     1    ' PANDA-type (closed form) buckling mode and eigenvalue'/
     1    ' before loads switched from Load Set B to Load Set A:'/
     1    '   Number of axial halfwaves,      MBAR=',1PE12.4/
     1    '   Number of circ. halfwaves,      NBAR=',1PE12.4/
     1    '   Slope of buckling nodal lines, SLOPE=',1PE12.4/
     1    '   Buckling load factor,         EIGVAL=',1PE12.4)
            GO TO 2222
         ENDIF
C END FEB 1996
         CALL ERREX
      ENDIF
C
C     
C     IF (INDX.EQ.2.AND.KOUNT.EQ.1) WRITE(6,5105) 
C     IF (INDX.EQ.2) WRITE(6,5100) MBAR,NBAR,SLOPE,EIGVAL   
 5100 FORMAT(' M,N,C,EIG=',1P,4E11.3) 
 5105 FORMAT(1H0) 
C BEG APR 1998
      IF (IDESGN.EQ.1.AND.IBACK.EQ.0) GO TO 320    
C END APR 1998
C     
      IF (ISHEAR.EQ.0.AND.IBAL.EQ.0) GO TO 320  
      IF (EIGVAL.GE.EIGSAV.AND.KOUNT.GT.1.AND.ITHRU.EQ.0) GO TO 200  
      IF (ITHRU.EQ.1) THEN
         EIGALL(KOUNT2) = EIGVAL
         SLPALL(KOUNT2) = SLOPE
         IF (ICHECS.EQ.1.AND.SLOPE.GE.0.) FPROD = 1.2
      ENDIF
      IF (ABS(SLOPE).GT.SLPMAX) GO TO 300
      SLOPSV = SLOPE    
C     
C     ITERATE ON THE SLOPE OF THE BUCKLING PATTERN... 
C     
  110 CONTINUE
      SLOPC = SLOPE     
      IF (ABS(SLOPC).LE.0.1) SLOPE = SLOPE + FINCR    
      IF (ABS(SLOPC).GT.0.1) SLOPE = SLOPE*FPROD
C BEG JAN 1996
      IF (NEGDEN.EQ.1.AND.ABS(SLOPE).GT.ABS(SLOPC)) FPROD = 1.2
C     IF (NPRNT.EQ.INDX) WRITE(8,*)
C    1' ICHECS,EIGVAL,EIGSAV,FINCR,FPROD,SLOPE=',
C    1  ICHECS,EIGVAL,EIGSAV,FINCR,FPROD,SLOPE
C END JAN 1996
C     
      GO TO 10    
C     
  200 CONTINUE    
      IF (EIGVAL.EQ.EIGSAV.OR.KOUNT.GT.2) GO TO 300     
      SLOPE = SLOPSV    
      EIGVAL = EIGSAV   
      FINCR =  -FINCR   
      IF (ABS(SLOPE).GT.0.1) FPROD = 1./FPROD  
      GO TO 110   
C     
  300 CONTINUE    
C     
      SLOPE = SLOPSV    
      EIGVAL = EIGSAV   
C
      IF (ITHRU.EQ.1) THEN
         EIGALL(KOUNT2) = EIGVAL
         SLPALL(KOUNT2) = SLOPE
      ENDIF
      ICHECS = ICHECK
C BEG APR 1998
      IF (IBACK.EQ.1) ICHECS = 1
C END APR 1998
C BEG JAN 1996
C     IF (SLOP0.EQ.0.0.AND.FFLAT.LT.0.5) ICHECS=1
      IF (SLOP0.EQ.0.0.AND.FFLAT.LT.0.5
     1                .AND.(ISHEAR.NE.0.OR.IBAL.NE.0)) ICHECS=1
C END JAN 1996
C BEG JUNE 1995
      IF (ICHECS.EQ.1.AND.ITHRU.EQ.0) THEN
C     IF (ICHECS.EQ.1.AND.ITHRU.EQ.0
C    1    .OR.(IRMOD.NE.0.AND.D.NE.0.0.AND.FFLAT.LT.0.5)) THEN
C END JUNE 1995
         IF (NPRNT.EQ.INDX) WRITE(8,302)
  302    FORMAT(/' CHECK WIDE RANGE OF SLOPE FOR MINIMUM EIGENVALUE.')
         SLPMIN = -20.
         IF (SGN.GT.0.0.AND.NXYEIG.GT.0.1*ABS(NXEIG)
     1         .AND.C46.GE.0.) SLPMIN = 0.
         SLPMAX = 20.1
         ITHRU  = 1
         SLOP1  = SLOPE
         EIGEV1 = EIGVAL
         KOUNT  = 0
         KOUNT2 = 0
         SLOPE  = SLPMIN
         FINCR = 0.05  
         FPROD = 1./1.2 
         IF (SLOPE.GE.0.) FPROD = 1.2
         EIGVAL = 10.E16
         GO TO 10
      ENDIF
      IF (ICHECS.EQ.1.AND.ITHRU.EQ.1) THEN
         EIGMIN = EIGEV1
         DO 305 I = 1,KOUNT2
            EIGMIN = MIN(EIGMIN,EIGALL(I))
  305    CONTINUE
         DIFF = ABS(EIGEV1 - EIGMIN)/ABS(EIGEV1)
         IF (DIFF.LT.0.01) THEN
            EIGVAL = EIGEV1
            SLOPE  = SLOP1
            GO TO 320
         ELSE
            DO 310 I = 1,KOUNT2
             DIFF = ABS(EIGMIN - EIGALL(I))/ABS(EIGMIN)
             IF (DIFF.LT.0.0001) THEN
               EIGVAL = EIGALL(I)
               SLOPE  = SLPALL(I)
               IF (NPRNT.EQ.INDX) 
     1            WRITE(8,308) EIGEV1,SLOP1,EIGVAL,SLOPE
  308          FORMAT(' CRITICAL EIGENVALUE SMALLER THAN THAT FOUND'/
     1       ' BY INITIAL SEARCH:'/
     1       '  PREVIOUS VALUE AND SLOPE:  EIGEV1, SLOP1 =',1P,2E12.4/
     1       '  MINIMUM  VALUE AND SLOPE:  EIGVAL, SLOPE =',1P,2E12.4/)
               GO TO 320
             ENDIF
  310       CONTINUE
         ENDIF
      ENDIF
C 
  320 CONTINUE    
C BEG APR 1998
      NN = NBAR
      MM = MBAR
C BEG APR 1998
      IF (IBACK.EQ.0.AND.NN.EQ.1.AND.MM.EQ.1.AND.ABS(SLOPE).GT.0.2
     1              .AND.TEST.GE.0.95.AND.TEST.LE.1.05) THEN
C     IF (IBACK.EQ.0.AND.TEST.GE.0.95.AND.TEST.LE.1.05
C    1              .AND.(IBAL.NE.0.OR.ISHEAR.NE.0)
C    1              .AND.(IFLAT.EQ.0.OR.(NN.EQ.1.AND.MM.EQ.1))) THEN
C BEG APR 1998
         IBACK = 1
         TESTX = TEST
         SLOPX = SLOPE
         EIGX  = EIGVAL
         ICHECX= ICHECK
         IF (TESTX.GT.0.99) TEST = 0.9
         IF (TESTX.LE.0.99) TEST = 1.1
         ICHECK = 0
         KOUNT = 0   
         KOUNT2 = 0
         FINCR = 0.01*SGN
         FPROD0 = 1.2
         FPROD = FPROD0
         ITHRU = 0
         ICHECS = 0
         SLPMAX = 30.
         SLOPE = SLOP0
         SLOPSV = SLOPE
         EIGVAL = 10.E16
         EIGSAV = EIGVAL
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRNT.EQ.INDX) THEN
            WRITE(8,'(A,1P,E12.4,/,A,1P,3E12.4)')
     1    ' Must check results for "opposite" TEST. Orignl TEST=',TESTX,
     1    ' new TEST, old SLOPE, old EIGVAL=',TEST,SLOPX,EIGX
         ENDIF
         GO TO 10
      ENDIF
      IF (IBACK.EQ.1) THEN
         TEST = TESTX
         SLOPE = SLOPX
         EIGBAK = EIGVAL
         W1 = -10.0*TESTX + 10.5
         W2 =  10.0*TESTX -  9.5
         IF (TESTX.LE.0.99) THEN
            EIGVAL = W1*EIGX + W2*EIGBAK
         ELSE
            EIGVAL = W2*EIGX + W1*EIGBAK
         ENDIF
         ICHECK = ICHECX
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRNT.EQ.INDX) THEN
            WRITE(8,'(A,1P,E12.4,/,A,1P,3E12.4)')
     1    ' Just checked results for new TEST. Old eigenvalue=',EIGX,
     1    ' new eigenvalue, EIGNEW, weights W1,W2=',EIGBAK,W1,W2
            IF (TESTX.LE.0.99) WRITE(8,'(A,1P,E12.4)')
     1    ' Weighted average: W1*EIGOLD + W2*EIGNEW = EIGVAL=',EIGVAL
            IF (TESTX.GT.0.99) WRITE(8,'(A,1P,E12.4)')
     1    ' Weighted average: W2*EIGOLD + W1*EIGNEW = EIGVAL=',EIGVAL
         ENDIF
      ENDIF
C END APR 1998
         IF (NPRNT.EQ.INDX) WRITE(8,7010) NBAR,MBAR,SLOPE,EIGVAL
 7010    FORMAT(' NBAR,MBAR,SLOPE,EIGVAL=',1P,4E12.4)
C     
      IF (IRMOD.NE.0) THEN
         R = RSAVE
         NYEIG=FYEIG
      ENDIF
C BEG FEB 1996
 2222 CONTINUE
C END FEB 1996
C BEG JUL 1999
      IF (IBACKB.EQ.1) THEN
         WRITE(8,'(A,A,/,A,1P,4E12.4)')
     1 ' Load Set B Nx(fixed) and Ny(fixed) temporarily shifted',
     1 ' to Load Set A:',
     1 ' MBAR,NBAR,SLOPE,EIGVAL=', MBAR,NBAR,SLOPE,EIGVAL
         NXFIX = NXFIXS
         NYFIX = NYFIXS
         NXEIG = NXEIGS
         NYEIG = NYEIGS
      ENDIF
C END JUL 1999
      RETURN
      END   
C
C
C
C=DECK      STFROL
      SUBROUTINE STFROL(M,N,FENGY,FWORK,CS,CR,BS,BR,A,B,
     1                  INDX,MBAR,NBAR)
C
C      PURPOSE IS TO GENERATE ADDITIONAL TERMS FOR BUCKLING WITH
C      STIFFENER ROLLING. (ROLLING WITH SKIN PARTICIPATION)
C
      COMMON/RESLTP/RPRES(9),RPRER(9),TOTPS,TOTPR,RSKNXP,RSKNYP   
      COMMON/ROLLIT/NSTOT,NRTOT,IROLL(9,9,2),FNUM(9,2),FDEN(9,2)  
      COMMON/STR2/ NPARTS,NSEGS(9),NENDS(9)     
      COMMON/RNG2/ NPARTR,NSEGR(9),NENDR(9)     
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/STR/D11S(9),D12S(9),D22S(9),GJS(9),ALS(9),ASSM(9),ASSM3(9)
      COMMON/RNG/D11R(9),D12R(9),D22R(9),GJR(9),ALR(9),ARSM(9),ARSM3(9)
      COMMON/RESULX/RESLTS(9),RESLTR(9),TOTS,TOTR,RSKINX,RSKINY   
      COMMON/C11SAV/C11SVE    
      DIMENSION FENGY(2),FWORK(2)   
C BEG MAR 1998
      DOUBLE PRECISION M,N
C END MAR 1998
      COMMON/NDEBUG/NPRNT
      REAL MBAR,NBAR
      MWAVE = MBAR
      NWAVE = NBAR
      FM2 = M*M   
      FN2 = N*N   
C     
      FWORK(1) = 0.0    
      FWORK(2) = 0.0    
      FENGY(1) = 0.0    
      FENGY(2) = 0.0    
      BS = 0.     
      BR = 0.0    
      IF (NPARTS.EQ.0.OR.INDX.EQ.3) GO TO 3     
      ISEGS = FNUM(2,1) 
      BS = ALS(ISEGS)   
C     
      FWORK(1) = (RESLTS(ISEGS) - RPRES(ISEGS))*BS/3. 
C     
      FENGY(1) = FM2*BS**2*(FNUM(1,1) + D11S(ISEGS)*BS/3.)
     1 + 4.*BS*GJS(ISEGS) + BS**2*(FNUM(3,1) + RPRES(ISEGS)*BS/3.) 
    3 IF (NPARTR.EQ.0.OR.INDX.EQ.4) GO TO 4     
      ISEGR = FNUM(2,2) 
      BR = ALR(ISEGR)   
C     
      FWORK(2) = (RESLTR(ISEGR) - RPRER(ISEGR))*BR/3. 
C     
      FENGY(2) = FN2*BR**2*(FNUM(1,2) +D11R(ISEGR)*BR/3.)
     1 +4.*BR*GJR(ISEGR) + BR**2*(FNUM(3,2) + RPRER(ISEGR)*BR/3.) 
C     
    4 CONTINUE    
C     
      FM2N2 = FM2*FN2   
      CS = 2.*FM2N2/(B*C11SVE)
      CR = 2.*FM2N2/(A*C11SVE)
C     
C BEG JUN 2004
C     IF (NPRNT.EQ.INDX.AND.MWAVE.EQ.1.AND.NWAVE.EQ.1) THEN
C        WRITE(8,*)' ISEGS,ISEGR=        ',ISEGS,ISEGR
C        WRITE(8,*)' FM2,FN2,BS,BR=      ',FM2,FN2,BS,BR
C        WRITE(8,*)' CS,CR=              ',CS,CR
C        WRITE(8,*)' RESLTS, RPRES=      ',RESLTS(ISEGS),RPRES(ISEGS)
C        WRITE(8,*)' RESLTR, RPRER=      ',RESLTR(ISEGR),RPRER(ISEGR)
C        WRITE(8,*)' FNUM(1,1),FNUM(3,1)=',FNUM(1,1),FNUM(3,1)
C        WRITE(8,*)' FNUM(1,2),FNUM(3,2)=',FNUM(1,2),FNUM(3,2)
C        WRITE(8,*)' FDEN(1,1),FDEN(1,2)=',FDEN(1,1),FDEN(1,2)
C        WRITE(8,*)' D11S,GS*(ts)**3/12= ',D11S(ISEGS),GJS(ISEGS)
C        WRITE(8,*)' D11R,GR*(tr)**3/12= ',D11R(ISEGR),GJR(ISEGR)
C        WRITE(8,*)' FENGY(1),FENGY(2)=  ',FENGY(1),FENGY(2)
C        WRITE(8,*)' FWORK(1),FWORK(2)=  ',FWORK(1),FWORK(2)
C     ENDIF
C END JUN 2004
      RETURN
      END
C
C
C
C=DECK      LUFACS
        SUBROUTINE      LUFACS  
     $     (A, NA, NN, IPERM, V, ISING, DET)
C   
C BLOCK     PURPOSE 
C     TO PERFORM THE LU FACTORIZATION OF A REAL UNSYMMETRIC MATRIX  
C END       PURPOSE 
C   
C BLOCK     ABSTRACT
C***********************************************************************
C*                             L U F A C S                             *
C***********************************************************************
C*                                                                     *
C*    THIS SUBROUTINE IS A FORTRAN ADAPTATION OF THE ALGOL PROCEDURE   *
C*    'UNSYMDET' PUBLISHED IN:                                         *
C*                                                                     *
C*    H.J. BOWDLER, R.S. MARTIN, G.PETERS AND J.H.WILKINSON,           *
C*    'SOLUTION OF REAL AND COMPLEX SYSTEMS OF LINEAR EQUATIONS',      *
C*    HANDBOOK FOR AUTOMATIC COMPUTATION, VOL 2, ED. BY J.H. WILKINSON *
C*    AND C. REINSCH, SPRINGER-VERLAG, 1971                            *
C*                                                                     *
C*    THE UNSYMMETRIC MATRIX, A,  IS STORED IN THE ARRAY A(I,J),       *
C*    I=1(1)N, J=1(1)N. THE DECOMPOSITION A = L*U, WHERE L IS A LOWER  *
C*    TRIANGULAR MATRIX AND U IS A UNIT UPPER TRIANGULAR MATRIX, IS    *
C*    PERFORMED AND OVERWRITTEN ON A, OMITTING THE UNIT DIAGONAL OF U. *
C*    RECIPROCALS OF THE DIAGONAL OF L REPLACE THE ORIGINAL DIAGONAL.  *
C*    THE DECOMPOSITION IS CARRIED OUT WITH PARTIAL PIVOTING AND ROW   *
C*    EQUILIBRATION (I.E., ROWS ARE IMPLICITLY SCALED TO LENGTH 1).    *
C*    A RECORD OF ANY INTERCHANGES MADE TO THE ROWS OF A IS KEPT IN    *
C*    IPERM(I),I=1(1)N, SUCH THAT THE I-TH ROW AND THE IPERM(I)TH ROW  *
C*    WERE INTERCHANGED AT THE I-TH STEP. THE DETERMINANT OF A IS      *
C*    COMPUTED IN THE FORM  D1*(2**D2), WHERE D1 IS IN THE RANGE       *
C*    1/16 TO 1.  THE FACTORIZATION WILL FAIL IF A, MODIFIED BY THE    *
C*    ROUNDING ERRORS, IS SINGULAR OR ALMOST SINGULAR. SINGULARITY IS  *
C*    INDICATED BY ISING, WHICH RETURNS THE RANK DEFICIENCY OF A.      *
C*                                                                     *
C***********************************************************************
C END       ABSTRACT
C   
C BLOCK     USAGE   
C***********************************************************************
C*                             L U F A C S                             *
C***********************************************************************
C*                                                                     *
C*          CALL   LUFACS  (A, NA, N, IPERM, V, ISING, DET)            *
C*          -----------------------------------------------            *
C*                                                                     *
C*      A           ARRAY CONTAINING MATRIX TO BE FACTORED ON INPUT.   *
C*                  ON EXIT, A HAS THE COMPUTED FACTORS (CF. ABSTRACT) *
C*                                                                     *
C*      NA          FIRST DIMENSION OF ARRAY A IN CALLING PROGRAM.     *
C*                                                                     *
C*      N           MATRIX ORDER (N LE NR)                             *
C*                                                                     *
C*      IPERM       INTEGER ARRAY OF LENGTH N WHERE LUFACS RECORDS     *
C*                  PIVOTAL ROW INTERCHANGES (CF. ABSTRACT).           *
C*                                                                     *
C*      V           SCRATCH FLOATING-POINT ARRAY OF LENGTH GE N.       *
C*                  IMPORTANT -  ARRAYS V AND IPERM MAY BE EQUIVALENT  *
C*                  IN THE CALLING PROGRAM.                            *
C*                                                                     *
C*      ISING       SINGULARITY INDICATOR.  ISING = 0  MARKS A         *
C*                  SUCCESSFUL FACTORIZATION.  ELSE THE VALUE OF       *
C*                  ISING INDICATES THE APPARENT RANK DEFICIENCY.      *
C*                                                                     *
C*      DET         A TWO WORD ARRAY (REAL,INTEGER) RECEIVING THE      *
C*                  COMPUTED DETERMINANT (SEE ABSTRACT)                *
C*                                                                     *
C***********************************************************************
C END       USAGE   
C   
C                   T Y P E   A N D   D I M E N S I O N 
C   
      REAL          A(*),     DET(2),   V(*),     MACTOL,   MACEPS  
      INTEGER       IPERM(*), D2
      EQUIVALENCE   (D2,FD2)
      DATA          MACEPS /5.9605E-8/      
C   
C                   L O G I C   
C   
C              INITIALIZATION   
C   
      MACTOL =   8.*MACEPS  
      D1 =       1.0
      D2 =       0  
      ISING =    0  
      J1 =       0  
      N =        IABS(NN)   
      IF (N)                           1000,5000,1000   
 1000 CONTINUE  
      JN =       (N-1) * NA 
C   
C              CALCULATE THE EUCLIDEAN NORM OF EACH ROW OF A
C   
      DO 1500  I = 1,N  
        Y =        0.0  
        Y = SNRM2(N,A(I),NA)
        V(I) =     0.0  
        IF (Y .NE. 0.0)                V(I) = 1.0/Y   
 1500   CONTINUE
C   
C              MAIN LOOP
C   
      JK =       0  
      DO 4000  K = 1,N  
        IF (V(K) .EQ. 0.0)             GO TO 3800   
        L =        K
        KM1 =      L - 1
        X =        0.0  
        DO 2000  I = K,N
          Y =       0.0 
          IF (KM1 .EQ. 0)              GO TO 1700   
          M =        I - NA 
          DO 1600  J = 1,KM1
            Y =        Y +  A(NA*J+M) * A(JK+J) 
 1600       CONTINUE
 1700     CONTINUE  
          A(JK+I) =    A(JK+I) - Y  
          Y =      ABS(V(I)*A(JK+I))
          IF (Y - X)                   2000,2000,1800   
 1800     X =        Y  
          L =        I  
 2000     CONTINUE  
        IF (L .EQ. K)                  GO TO 2200   
C   
C              INTERCHANGE ROWS 
C   
        DO 2100  J = J1,JN,NA   
          Y =        A(J+K) 
          A(J+K) =   A(J+L) 
          A(J+L) =   Y  
 2100     CONTINUE  
        D1 =      -D1   
        V(L) =     V(K) 
 2200   IPERM(K) = L
C   
C              TEST FOR SINGULARITY 
C   
        IF (X - MACTOL)                6000,6000,2500   
C   
C              UPDATE DETERMINANT   
C   
 2500   CONTINUE
        Y =        A(JK+K)  
        D1 =       D1*Y 
        X =        1.0/Y
        A(JK+K) =  X
 2700   IF (ABS(D1) .LT. 1.0)          GO TO 2800   
        D1 =       D1*.0625 
        D2 =       D2 + 4   
        GO TO 2700  
 2800   IF (ABS(D1) .GE. 0.0625)       GO TO 3000   
        D1 =       D1*16.0  
        D2 =       D2 - 4   
        GO TO 2800  
C   
C              CALCULATE ELEMENTS OF STRICT UPPER TRIANGLE  
C   
 3000   CONTINUE
        IF (K .EQ. N)                  GO TO 4000   
        JK1 =    JK + NA
        M =        K - NA   
        DO 3600  J = JK1,JN,NA  
          Y =        0.0
          IF (KM1 .EQ. 0)              GO TO 3500   
          DO 3400  I = 1,KM1
            Y =        Y  +  A(NA*I+M) * A(J+I) 
 3400       CONTINUE
 3500     CONTINUE  
          A(K+J) =   (A(K+J)-Y) * X 
 3600     CONTINUE  
C   
        GO TO 3900  
 3800   CONTINUE
        IPERM(K) = K
 3900   CONTINUE
        JK =       JK + NA  
 4000   CONTINUE
C   
 4500 DET(1) =   D1 
      DET(2) =   FD2
 5000 CONTINUE  
      RETURN
C   
 6000 ISING =    N - KM1
      D1 =       0.0
      D2 =       0  
      GO TO 4500
      END   
C
C
C
C=DECK      SNRM2
C PURPOSE   S.P. SQRT OF SUM OF SQUARES OF X COMPONENTS -- FUNCTION 
C EQUIPMENT FORTRAN     UNIVAC      CDC         IBM 
C TEST      TBLAL   
C VERSION   02 JUL 79   15:11:38
C VALID     UNIVAC 02/78
C AUTHOR    BASIC LINEAR ALGEBRA (BLAL) SYSTEM  
C KEYWORDS  BLAL        NORM 2      VECTOR  
C BLOCK     USAGE   
C     CALLING SEQUENCE...    T= SNRM2(N,X,INCX) 
C   
C     NAME  TYPE   DESCRIPTION  
C     ------------------------------------------------------------------
C     T      R     VECTOR EUCLIDEAN NORM                               P
C     N      I     NUMBER OF TERMS TO BE REFERENCED                   U 
C     X      R     REFERENCED ARRAY                                   U 
C     INCX   I     INDEX INCREMENT FOR X ARRAY (SEE NOTE BELOW)       U 
C   
C     X(I) IMPLIES X(1+I*INCX-INCX  )  IF(INCX.GE.0)   (I=1,N)  
C     ...OR...     X(1+I*INCX-INCX*N)  IF(INCX.LT.0)   (I=1,N)  
C   
C     FOR DOUBLE PRECISION, SEE DNRM2   
C   
C     CODED BOTH IN FORTRAN AND ASSEMBLY LANGUAGES  
C END       USAGE   
C BLOCK     ABSTRACT
C     BASIC LINEAR ALGEBRA LIBRARY ROUTINE FOR  
C     DETERMINING THE NORM 2 OF A SINGLE PRECISION VECTOR IN SINGLE 
C     PRECISION.  SPECIAL PRECAUTIONS ARE TAKEN TO AVOID OVERFLOW   
C     OR UNDERFLOW. 
C END       ABSTRACT
      REAL FUNCTION SNRM2 ( N, SX, INCX)
      INTEGER          NEXT 
      REAL   SX(*),  CUTLO, CUTHI, HITEST, SUM, XMAX, ZERO, ONE 
      DATA   ZERO, ONE /0.0E0, 1.0E0/   
C   
C     EUCLIDEAN NORM OF THE N-VECTOR STORED IN SX() WITH STORAGE
C     INCREMENT INCX .  
C     IF    N .LE. 0 RETURN WITH RESULT = 0.
C     IF N .GE. 1 THEN INCX MUST BE .GE. 1  
C   
C           C.L.LAWSON, 1978 JAN 08 
C   
C     FOUR PHASE METHOD     USING TWO BUILT-IN CONSTANTS THAT ARE   
C     HOPEFULLY APPLICABLE TO ALL MACHINES. 
C         CUTLO = MAXIMUM OF  SQRT(U/EPS)  OVER ALL KNOWN MACHINES. 
C         CUTHI = MINIMUM OF  SQRT(V)      OVER ALL KNOWN MACHINES. 
C     WHERE 
C         EPS = SMALLEST NO. SUCH THAT EPS + 1. .GT. 1. 
C         U   = SMALLEST POSITIVE NO.   (UNDERFLOW LIMIT)   
C         V   = LARGEST  NO.            (OVERFLOW  LIMIT)   
C   
C     BRIEF OUTLINE OF ALGORITHM..  
C   
C     PHASE 1    SCANS ZERO COMPONENTS. 
C     MOVE TO PHASE 2 WHEN A COMPONENT IS NONZERO AND .LE. CUTLO
C     MOVE TO PHASE 3 WHEN A COMPONENT IS .GT. CUTLO
C     MOVE TO PHASE 4 WHEN A COMPONENT IS .GE. CUTHI/M  
C     WHERE M = N FOR X() REAL AND M = 2*N FOR COMPLEX. 
C   
C     VALUES FOR CUTLO AND CUTHI..  
C     FROM THE ENVIRONMENTAL PARAMETERS LISTED IN THE IMSL CONVERTER
C     DOCUMENT THE LIMITING VALUES ARE AS FOLLOWS.. 
C     CUTLO, S.P.   U/EPS = 2**(-102) FOR  HONEYWELL.  CLOSE SECONDS ARE
C                   UNIVAC AND DEC AT 2**(-103) 
C                   THUS CUTLO = 2**(-51) = 4.44089E-16 
C     CUTHI, S.P.   V = 2**127 FOR UNIVAC, HONEYWELL, AND DEC.  
C                   THUS CUTHI = 2**(63.5) = 1.30438E19 
C     CUTLO, D.P.   U/EPS = 2**(-67) FOR HONEYWELL AND DEC. 
C                   THUS CUTLO = 2**(-33.5) = 8.23181D-11   
C     CUTHI, D.P.   SAME AS S.P.  CUTHI = 1.30438D19
C     DATA CUTLO, CUTHI / 8.232D-11,  1.304D19 /
C     DATA CUTLO, CUTHI / 4.441E-16,  1.304E19 /
      DATA CUTLO, CUTHI / 4.441E-16,  1.304E19 /
C   
      IF(N .GT. 0) GO TO 10 
         SNRM2  = ZERO  
         GO TO 300  
C   
   10 CONTINUE
*     ASSIGN 30 TO NEXT
      NEXT = 1 
      SUM  = ZERO
      NN   = N * INCX 
C                                                 BEGIN MAIN LOOP   
      I = 1 

*  20    GO TO NEXT,(30, 50, 70, 110)   
   20 IF (NEXT .EQ. 1) GOTO  30 
      IF (NEXT .EQ. 2) GOTO  50 
      IF (NEXT .EQ. 3) GOTO  70 
      IF (NEXT .EQ. 4) GOTO 110 
      WRITE(6,3000) NEXT
 3000 FORMAT(/,'SNRM2 ** ERROR ** assign goto NEXT not = 1,2,3 OR 4',
     $         ',  NEXT = ',I12)
      STOP 'ERROR'

   30 IF( ABS(SX(I)) .GT. CUTLO) GO TO 85   
*     ASSIGN 50 TO NEXT 
      NEXT = 2 
      XMAX = ZERO   
C   
C                        PHASE 1.  SUM IS ZERO  
C   
   50 IF( SX(I) .EQ. ZERO) GO TO 200
      IF( ABS(SX(I)) .GT. CUTLO) GO TO 85   
C   
C                                PREPARE FOR PHASE 2.   
*     ASSIGN 70 TO NEXT 
      NEXT = 3 
      GO TO 105 
C   
C                                PREPARE FOR PHASE 4.   
C   
  100 I = J 
*     ASSIGN 110 TO NEXT
      NEXT = 4 
      SUM = (SUM / SX(I)) / SX(I)   
  105 XMAX = ABS(SX(I)) 
      GO TO 115 
C   
C                   PHASE 2.  SUM IS SMALL. 
C                             SCALE TO AVOID DESTRUCTIVE UNDERFLOW. 
C   
   70 IF( ABS(SX(I)) .GT. CUTLO ) GO TO 75  
C   
C                     COMMON CODE FOR PHASES 2 AND 4.   
C                     IN PHASE 4 SUM IS LARGE.  SCALE TO AVOID OVERFLOW.
C   
  110 IF( ABS(SX(I)) .LE. XMAX ) GO TO 115  
         SUM = ONE + SUM * (XMAX / SX(I))**2
         XMAX = ABS(SX(I))  
         GO TO 200  
C   
  115 SUM = SUM + (SX(I)/XMAX)**2   
      GO TO 200 
C   
C   
C                  PREPARE FOR PHASE 3. 
C   
   75 SUM = (SUM * XMAX) * XMAX 
C   
C   
C     FOR REAL OR D.P. SET HITEST = CUTHI/N 
C     FOR COMPLEX      SET HITEST = CUTHI/(2*N) 
C   
   85 HITEST = CUTHI/FLOAT( N ) 
C   
C                   PHASE 3.  SUM IS MID-RANGE.  NO SCALING.
C   
      DO 95 J =I,NN,INCX
      IF(ABS(SX(J)) .GE. HITEST) GO TO 100  
   95    SUM = SUM + SX(J)**2   
      SNRM2 = SQRT( SUM )   
      GO TO 300 
C   
  200 CONTINUE  
      I = I + INCX  
      IF ( I .LE. NN ) GO TO 20 
C   
C              END OF MAIN LOOP.
C   
C              COMPUTE SQUARE ROOT AND ADJUST FOR SCALING.  
C   
      SNRM2 = XMAX * SQRT(SUM)  
  300 CONTINUE  
      RETURN
      END   
C
C
C
C=DECK      DONELL
      SUBROUTINE DONELL(A,B,NBAR,MBAR,PX,PY,PXY,DONNEL,FFLAT,IAGAIN,
C BEG JUNE 1995
     1                  INDX,R)
C END JUNE 1995
C
C  PURPOSE IS TO CALCULATE REDUCTION FACTOR TO COMPENSATE FOR
C  INACCURACY OF DONNELL'S SHALLOW SHELL APPROXIMATION.
C
C BEG AUG 1995
      COMMON/NDEBUG/NPRNT
C END AUG 1995
C BEG MAR 2005
      COMMON/NPRNTX/NPREIG
C END MAR 2005
C BEG JUNE 1995
C     COMMON/DESVAR/ISPACS(4),R
C END JUNE 1995
C BEG JAN 1994
      COMMON/DONNSW/IDONNL(10)
      COMMON/DONWVE/EIGN1(10),EIGN2(10),EIGN3(10),EIGN4(10)
C END JAN 1994
C BEG AUG 1994
C BEG JUN 1996
      COMMON/ISANDR/ISAND,ISANDS
C END JUN 1996
C END AUG 1994
      REAL NBAR,MBAR,NCYL
      PI = 3.14159
      NCYL = ABS(NBAR*PI*R/B)
      DONNEL = 1.0
C BEG MAR 2005
C     IF (NPREIG.EQ.3) WRITE(8,'(A,1PE12.4,2I5)')
C    1 ' In DONELL: NCYL,INDX,IDONNL(INDX)=',
C    1              NCYL,INDX,IDONNL(INDX)
C END MAR 2005
      IF (IDONNL(INDX).EQ.0) RETURN
      IF (MBAR.LE.0.) RETURN
      AMBAR = A/MBAR
      IF (IAGAIN.NE.2.AND.FFLAT.GT.0.5) RETURN
      PTEST = ABS(PY) - ABS(PX)
      IF (AMBAR.LT.ABS(R)) RETURN
C BEG JAN 1994
C     IF (NBAR.LT.2.) RETURN
      IF (NCYL.LT.1.9) RETURN
      IF (MBAR.GT.1.9) RETURN
C END JAN 1994
C BEG MAR 1998
      IF (ISAND.GE.1) RETURN
C END MAR 1998
      IF (NCYL.GT.1.5.AND.NCYL.LT.20.) DONNEL = (NCYL*NCYL-1.)/NCYL**2
C BEG AUG 1996
C BEG MAR 2005
C     IF (NPREIG.EQ.3) WRITE(8,*)' MBAR,NBAR,NCYL,DONNEL=',
C    1                             MBAR,NBAR,NCYL,DONNEL
C END MAR 2005
C END AUG 1996
      ARG = 10.
      DIN = 1./DONNEL
      IF (ABS(PX).GT.0.) ARG = SQRT(PY**2 + PXY**2)/ABS(PX)
      IF (ARG.GE.0.5) DFACT = 1.0
      IF (ARG.LT.0.5) DFACT = 2.*(1.-DIN)*ARG + DIN
      IF (DFACT.LT.1.0) DFACT = 1.0
C BEG MAR 2005 
C     IF (NPREIG.EQ.3) WRITE(8,*)' PX,PY,PXY=',PX,PY,PXY
C     IF (NPREIG.EQ.3) WRITE(8,*)' ARG,DIN,DFACT=',ARG,DIN,DFACT
C END MAR 2005 
      DONNEL = DFACT*DONNEL
C BEG MAR 2005 
C     IF (NPREIG.EQ.3) WRITE(8,*)' EIGN2,EIGN3,EIGN4=',
C    1                   EIGN2(INDX),EIGN3(INDX),EIGN4(INDX)
C     IF (NPREIG.EQ.3) WRITE(8,*)' 1.INSIDE DONNEL:DONNEL=',DONNEL
C END MAR 2005 
C BEG JAN 1994
      IF (DONNEL.GT.1.0) DONNEL = 1.0
      IF (DFACT.GT.9./8.) DFACT = 9./8.
      IF (DONNEL.GE.(DFACT*8./9.)) RETURN
      IF (NCYL.GE.2.9) RETURN
      IF (EIGN2(INDX).EQ.0.0.OR.EIGN3(INDX).EQ.0.0
     1                      .OR.EIGN4(INDX).EQ.0.0) RETURN
C     DFACT2 = 1.0
C     IF (EIGN2(INDX).LE.DFACT2*EIGN3(INDX)) RETURN
C     IF (EIGN2(INDX).GE.EIGN4(INDX)
C    1                     .OR.DFACT2*EIGN3(INDX).GE.EIGN4(INDX)) THEN
C        DONNEL = DFACT*(8./9.)
C        RETURN
C     ENDIF
C     DSTAR = DFACT*(8./9.)/DONNEL
C     R2 = EIGN2(INDX)/(DFACT2*EIGN3(INDX)) - 1.0
C     R4 = EIGN4(INDX)/(DFACT2*EIGN3(INDX)) - 1.0
C     FACT3 = (DSTAR-1.0)*R2/R4 + 1.0
C     IF (FACT3.LT.1.0) FACT3 = 1.0
C END JAN 1994
C BEG FEB 1994
      IF (EIGN2(INDX).LT.0.75*EIGN3(INDX)) RETURN
      IF (EIGN2(INDX).GT.EIGN3(INDX)) THEN
         DONNEL = DFACT*(8./9.)
         IF (DONNEL.GT.1) DONNEL = 1.0
C BEG MAR 2005
C        IF (NPREIG.EQ.3) WRITE(8,*)' 2.INSIDE DONNEL:DONNEL=',DONNEL
C END MAR 2005
         RETURN
      ENDIF
      FACT3 = .740741*EIGN2(INDX)/EIGN3(INDX) + .444444
      IF (FACT3.LT.1.0) FACT3 = 1.0
      DONNEL = FACT3*DONNEL
      IF (DONNEL.GT.1.0) DONNEL = 1.0
C END FEB 1994
C     
C     WRITE(8,*)' R,A,B,NBAR,MBAR,NCYL,PX,PY,DONNEL=',
C    1            R,A,B,NBAR,MBAR,NCYL,PX,PY,DONNEL
      RETURN
      END   
C
C
C
C BEG JUN 1998
C=DECK       ALTSOL     
      SUBROUTINE ALTSOL(XLONG,YLONG,RADIUS,CSTIFF,NX,NY,NXY,NX0,NY0,
     1            NXY0,NPRT,IFLAT,MWAVE,NWAVE,SLOPE,EIGOLD,
     1            ISANDQ,IREDUC,EIGVAL,TX,TY,G1323,IFILE,
     1            MWAVEX,EIGMNC,ILABEL,IQUICK,SPSTR,SPRNG,
     1            EAS,EIXS,EIYS,GJS,ECCS,EAR,EIXR,EIYR,GJR,ECCR,
     1            FNXSTR,FX0STR,ZNXSTR,FNXRNG,FX0RNG,ZNXRNG,IDISCT,
     1            IDESGN,ILCGLB,NUMSTR,NUMRNG,ASPSVX,ASPSVY,ISIGNL,
     1            ILOCAL,GTX5,TY5,ISTIF2,MWHIGH,ICASE,KLAYER)
C
C Purpose is to find buckling of a rectangular panel simply supported
C on all four edges and subjected to the in-plane load combinations:
C   Load Set A (eigenvalue loads): NX,  NY,  NXY
C   LOAD Set B (fixed loads):      NX0, NY0, NXY0
C
C The cylindrical panel has radius RADIUS, axial length XLONG, 
C hoop (arc) length YLONG. The 6x6 symmetric matrix representing the
C integrated constitutive law is CSTIFF.
C
C Meanings of some other input/output variables:
C  IFLAT = 0 means the panel is curved; 1 means the panel is flat.
C  MWAVE,NWAVE,SLOPE = axial halfwaves, circumferential halfwaves, slope
C                      of buckling nodal lines in the critical buckling
C                      mode determined from the original PANDA-type
C                      closed form solution.
C  EIGOLD = buckling load factor from original PANDA-type solution
C  ISANDQ = index for shell theory: 0 = Donnell, 1 = Sanders, 2 = Marlowe
C  IREDUC = index for t.s.d.: 0 = no t.s.d.; 1 = yes t.s.d. (call SHRRED)
C  EIGVAL = buckling load factor from ALTSOL (alternative solution).
C  TX,TY,G1323 = thicknesses and t.s.d. moduli used in SHRRED.
C  MWAVEX = number of axial halfwaves in "high-m" buckling mode from the
C           original PANDA-type closed form solution.
C  EIGMNC = buckling load factor corresponding to MWAVEX.
C  ILABEL = label number in SUBROUTINE STRUCT from which SUBROUTINE BUCPAN
C           is called.
C  IQUICK = 0 if discretized single module model is used for local buckling
C           1 if the discretized single module model is not used.
C  SPSTR, SPRNG = stringer spacing, ring spacing used for alternative soln
C                 in which the stiffeners are treated as discrete (see ITEM
C                 444).
C There may be discrete stringers with EAS,EIXS,GJS,ECCS, and
C there may be discrete rings     with EAR,EIXR,GJR,ECCR, in which
C EAS,EAR    = axial stiffness, "EA", of the stringer,ring
C EIXS,EIXR  = bending stiffness, "EI", of the stringer,ring
C              (bending normal to the plane of the panel skin at attachment)
C EIYS,EIYR  = bending stiffness, "EI", of the stringer,ring
C              (bending parallel to the plane of the panel skin at attachment)
C GJS,GJR    = torsional rigidity, "GJ", of the stringer,ring
C ECCS,ECCR  = eccentricity, "e", of the stringer, ring shear center
C              with respect to the reference surface of the panel skin.
C
C IDISCT = 1 means there are one or more sets of discrete stiffeners.
C
C ILCGLB = 1 means local buckling between major stiffeners with smeared
C                  substiffeners.
C          2 means general buckling of patch with N x M bays of major
C                  stiffeners. Substiffeners are smeared.
C          3 means inter-major-ring buckling with smeared substiffeners
C                  and N bays of discrete major stringers.
C          4 means buckling of patch between major stiffeners with discrete
C                  substiffeners with use of N x M bays of substiffeners.
C          5 means local buckling of panel skin between substiffeners with use
C                  of discrete substiffeners along boundaries.
C          6 means inter-subring buckling with N bays of discrete substringers.
C                  Discrete subrings are used along the two curved boundaries.
C
C NUMSTR = number of discrete stringers
C NUMRNG = number of discrete rings
C FNXSTR,FNXRNG = prebuckling loads (e.g. lbs) in stringer, ring (load set A)
C FX0STR,FX0RNG = prebuckling loads (e.g. lbs) in stringer, ring (load set B)
C ZNXSTR,ZNXRNG = eccentricities of stringer, ring web and outstanding
C                 flange with respect to the skin reference surface.
C IDISCT = index: 0 means no discrete stiffeners; 1 means yes discrete stiff.
C IDESGN = index: 0 means current design; 1 means perturbed design.
C
C ASPSVX, ASPSVY = ratios of original (axial, hoop) lengths, (XLONG, YLONG),
C                  to critical sublengths (XLSAVE, YLSAVE) determined for the
C                  current (unperturbed) design.
C ISIGNL = output index: 0 means the alternative solution is critical,
C                        1 means the "high-m" eigenvalue from the original
C                          PANDA-type (closed form) solution is critical.
C ILOCAL = output index: 0 means the alternative solution was obtained.
C                        1 means the alternative solution was not obtained.
C
C The assumed buckling modal displacement field is:
C   axial displacement, u = sum-over-m{sum-over-n{A(m,n)cos(mx)sin(ny)
C                                                +D(m,n)sin(mx)sin(ny)}}
C    hoop displacement, v = sum-over-m{sum-over-n{B(m,n)sin(mx)cos(ny)
C                                                +E(m,n)sin(mx)sin(ny)}}
C  normal displacement, w = sum-over-m{sum-over-n{C(m,n)sin(mx)sin(ny)}}
C
C in which the following definitions hold:
C
C     MAMAX = number of trig terms in the x-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     MDMAX = number of trig terms in the x-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     MBMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     MEMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     MCMAX = number of trig terms in the x-coord. expansion for displ. w
C     NAMAX = number of trig terms in the y-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     NDMAX = number of trig terms in the y-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     NBMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     NEMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     NCMAX = number of trig terms in the y-coord. expansion for displ. w
C
C BEG OCT 2006
      COMMON/ICONSX/ICONSV
C END OCT 2006
C BEG DEC 2001
      COMMON/RADM14/IICURV
C END DEC 2001
      COMMON/IODEVX/IODEVS(10),ISHRGN,ISHRSN
C BEG NOV 2003
C BEG OCT 2004
C     COMMON/EIGALX/EIGALS(130,3)
C BEG JAN 2005
C     COMMON/EIGALX/EIGALS(130,6)
      COMMON/EIGALX/EIGALS(400,6)
      COMMON/NCHNGX/NCHNG3,NCHNG6
C END JAN 2005
C END OCT 2004
C END NOV 2003
C BEG JUN 2006
      DIMENSION NCRITM(11),MCRITN(11),ISTEIG(2,6)
      COMMON/IALTSP/IALTSK(6)
C END JUN 2006
C BEG JAN 2005 (dimensions increased: 400 was 130; 100000 was 16000)
      DIMENSION EVECT1(400),EVECT2(400)
      COMMON/IALTSX/IALTSN,IALTSV
      DIMENSION A(100000),B(100000),EVECT(100000),CSTIFF(6,6),C(6,6)
      DIMENSION WORKSP(400),EIGALT(400),G1323(*)
C END JAN 2005
C BEG MAR 2005
      COMMON/GEOM2/BB(2),BB2(2),HH(2),WW(2),WW2(2)
      COMMON/GENALT/EODDBB,EEVNBB,BSTRNG,BRINGS
      COMMON/GENALX/EVGEN1(400),EVGEN2(400)
C END MAR 2005
C BEG OCT 2001
      DIMENSION GTX5(*),GINPUT(2),TINPUT(2)
C  GTX5(1),GTX5(2)=G13,G23 for panel with smeared stringers (between rings)
C  TY5            =Teff(2) for panel with smeared stringers (between rings)
C  GINPUT(1),(2)= G13,G23 used in SUB. SHRRED, either G1323 or GTX5.
C  TINPUT(1),(2)= Teff(1),Teff(2) used in SUB. SHRRED.
C END OCT 2001
C More definitions:
C  IODEVS(1)=index: 
C        1 means (m+n)=odd  eigenvalue for local buckling (smeared substif.) is critical
C        2 means (m+n)=even eigenvalue for local buckling (smeared substif.) is critical
C  IODEVS(2)=index: 
C        1 means (m+n)=odd  eigenvalue for general buckling is critical
C        2 means (m+n)=even eigenvalue for general buckling is critical
C  IODEVS(3)=index:
C        1 means (m+n)=odd  eigenvalue for inter-majorring buckling is critical
C        2 means (m+n)=even eigenvalue for inter-majorring buckling is critical
C  IODEVS(4)=index:
C        1 means (m+n)=odd  eigenvalue for inter-majorstiffeners buckling with
C          discrete substiffeners is critical
C        2 means (m+n)=even eigenvalue for inter-majorstiffeners buckling with
C          discrete substiffeners is critical
C  IODEVS(5)=index:
C        1 means (m+n)=odd  eigenvalue for local buckling betw. substiffeners is critical
C        2 means (m+n)=even eigenvalue for local buckling betw. substiffeners is critical
C  IODEVS(6)=index:
C        1 means (m+n)=odd  eigenvalue for inter-subring buckling is critical
C        2 means (m+n)=even eigenvalue for inter-subring buckling is critical
C
C EIGALS(i,j) = critical eigenvectors for unperturbed design, as follows:
C
C  EIGALS(i,1) = critical eigenvector for inter-major-stiffener buckling with smeared
C                                     substiffeners. The axial dimension is the major
C                                     ring spacing; the hoop dimension is the major
C                                     stringer spacing.
C
C  EIGALS(i,2) = critical eigenvector for general buckling. A "patch" is used with
C                                     which includes up to three major stiffener bays in
C                                     each coordinate direction. Smeared substiffeners.
C
C  EIGALS(i,3) = critical eigenvector for inter-major-ring buckling, smeared substiffeners.
C                                     Axial dimension is major ring spacing; hoop
C                                     dimension is some integral multiple of major
C                                     stringer spacing, maximum of three bays.
C
C  EIGALS(i,4) = critical eigenvector for inter-major-stiffener buckling, discrete
C                                     substiffeners. A "patch" is used which includes
C                                     up to six substiffener bays in each coordinate
C                                     direction. 
C
C  EIGALS(i,5) = critical eigenvector for local buckling between substiffeners. The axial
C                                     dimension is the subring spacing; hoop dimension is
C                                     the substringer spacing. Discrete substiffeners at
C                                     the boundaries.
C
C  EIGALS(i,6) = critical eigenvector for inter-subring buckling with discrete substringers.
C                                     The axial dimension is the major ring spacing. The
C                                     hoop dimension is some integral multiple of the
C                                     substringer spacing, maxumum of 3 substringer bays.
C
C  IALTSN = index: 1 means "user wants the alternative solution"
C                  0 means "user does not want the alternative solution"
C  A,B = stiffness, load-geometric matrices (full and symmetric)
C  EVECT = complete set of eigenvalues of Ax = lambda*Bx
C  EIGALT= eigenvector that corresponds to lowest positive eigenvalue.
C
      DIMENSION WDISP(11,11),WMAXM(11),WMAXN(11),EIGTRY(20),XLG(20)
      DIMENSION WDISPS(11,11),WMAXMS(11)
C BEG JAN 2005
      DIMENSION WDISP1(11,11),WDISP2(11,11)
C END JAN 2005
      DIMENSION FNXSTR(2),FX0STR(2),ZNXSTR(2)
      DIMENSION FNXRNG(2),FX0RNG(2),ZNXRNG(2)
      DIMENSION DNXSTR(2),DX0STR(2),ZDXSTR(2)
      DIMENSION DNXRNG(2),DX0RNG(2),ZDXRNG(2),LUPPR1(2),LUPPR2(2)
      DOUBLE PRECISION DNXSTR,DX0STR,ZDXSTR,DNXRNG,DX0RNG,ZDXRNG
      DOUBLE PRECISION XMAX,YMAX,A,B,C,EVECT,WORKSP,EIGALT,CUR
      DOUBLE PRECISION FNX,FNY,FNXY,FNX0,FNY0,FNXY0,FISAND
      DOUBLE PRECISION EASTR,EIXSTR,EIYSTR,GJSTR,ECCSTR,SPCSTR
      DOUBLE PRECISION EARNG,EIXRNG,EIYRNG,GJRNG,ECCRNG,SPCRNG
      DOUBLE PRECISION EIGALS,EVECT1,EVECT2,EIGRAY
C BEG MAR 2005
      DOUBLE PRECISION EVGEN1,EVGEN2
C END MAR 2005
      REAL NX,NY,NXY,NX0,NY0,NXY0
      CHARACTER*8 WORD1,WORD2
C BEG NOV 2003
      LOGICAL IDISCX,IDISCZ
C
C BEG OCT 2004
C     IDISCX = IDISCT.EQ.0.OR.ILCGLB.EQ.1
C     IDISCZ = IDISCT.EQ.1.AND.(ILCGLB.EQ.2.OR.ILCGLB.EQ.3)
      IDISCX = IDISCT.EQ.0.OR.ILCGLB.EQ.1.OR.ILCGLB.EQ.5
      IDISCZ = IDISCT.EQ.1.AND.
     1        (ILCGLB.EQ.2.OR.ILCGLB.EQ.3.OR.ILCGLB.EQ.4.OR.ILCGLB.EQ.6)
C END OCT 2004
C END NOV 2003
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG NOV 2003
      IF (NPRT.GE.0) THEN
         WRITE(IFILE,'(/,A,1P,3E12.4,/,A,/,A,/,A)')
     1' Entering ALTSOL: radius, axial, circ. dimensions =',
     1                                         RADIUS,XLONG,YLONG,
     1' See ITEMs 438, 444  in the file ..panda2/doc/panda2.news .',
     1' and AIAA paper 99-1233, Proc. 40th AIAA SDM Meeting, 1999',
     1' pp 302-345, especially pp 304-316 and associated figures.'
C BEG OCT 2004
         IF (ILCGLB.EQ.1) WRITE(IFILE,'(A)')
     1 ' *** BUCKLING BETW MAJOR STIFFENERS, SMEARED SUBSTIFFENERS ***'
C BEG FEB 2005
         IF (ILCGLB.EQ.2) WRITE(IFILE,'(A)')
     1 ' *** GENERAL BUCKLING, N x M BAY PATCH, SMEARED SUBSTIFFRS ***'
C END FEB 2005
         IF (ILCGLB.EQ.3) WRITE(IFILE,'(A)')
     1' ***INTER-RING BUCKLING, N-STRINGER-BAY PATCH, SMEARED SUBSTF **'
         IF (ILCGLB.EQ.4) WRITE(IFILE,'(A,/,A)')
     1' ***BUCKLING BETWEEN MAJOR STIFFENERS, DISCRETE SUBSTIFFENERS**',
     1' ***N x M SUBSTIFFENER-BAY PATCH IS USED                    ***'
         IF (ILCGLB.EQ.5) WRITE(IFILE,'(A,/,A)')
     1' ***BUCKLING BETWEEN SUBSTIFFENERS, DISCRETE SUBSTIFFENERS  ***',
     1' ***AT THE BOUNDARIES.                                      ***'
         IF (ILCGLB.EQ.6) WRITE(IFILE,'(A)')
     1' ***INTER-SUBRING BUCKLING, N-SUBSTRINGER-BAY PATCH IS USED ***'
         WRITE(IFILE,'(A,2I3)')
     1'         Number of discrete stringers, rings: NUMSTR, NUMRNG=',
     1          NUMSTR,NUMRNG
C END OCT 2004
C BEG NOV 2003
         IF (NPRT.GE.1) WRITE(IFILE,'(A,/,1P,4E12.4)')
     1 ' Membrane stiffnesses, C11,C12,C22,C33=',
     1   CSTIFF(1,1),CSTIFF(1,2),CSTIFF(2,2),CSTIFF(3,3)
C END NOV 2003
      ENDIF
C BEG AUG 2003
      IF (IDESGN.EQ.0) MWHIGH = MWAVEX
      MWCOMP = MWHIGH
      EIGCMP = EIGMNC
      IF (MWCOMP.EQ.MWAVE) EIGCMP = EIGOLD
C END AUG 2003
      WORD1 = '(CURVED)'
      IF (IFLAT.NE.0) WORD1 = ' (FLAT) '
      WORD2 = '(CURVED)'
C BEG DEC 2001
      IF (IQUICK.EQ.0.AND.ILABEL.EQ.9140.AND.IICURV.EQ.0)
     1                WORD2 = ' (FLAT) '
C END DEC 2001
      IF (IFLAT.NE.0) WORD2 = ' (FLAT) '
      ILOOP = 0
      ILOOP2 = 0
      EIGVAL = 10.E+16
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (IALTSN.EQ.0) THEN
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A)')
     1 ' No alternative solution sought because user did not want one.',
     1 ' (IALTSN was set equal to zero in MAINSETUP)'
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
      CS16M = MAX(ABS(CSTIFF(1,6)),ABS(CSTIFF(2,6)))
      CS1166 = SQRT(CSTIFF(1,1)*CSTIFF(6,6))
      CS2266 = SQRT(CSTIFF(2,2)*CSTIFF(6,6))
      C2266M = MAX(CS1166,CS2266)
      ISPLIT = 1
C
C  ISPLIT = 1 means split A*x = lambda*B*x into two subsets, one for
C             (m+n)=odd and the other for (m+n)=even.
C  ISPLIT = 0 means do not split. (The equation system A*x=lambda*B*x
C             cannot be split into "odd" and "even" subsets if there
C             exist significant C16 or C26 (usually called B16,B26 in
C             the literature on composite materials)).
C
      FLONG = 10.0
      IF (IFLAT.EQ.0) FLONG = 1000.
      IF (CS16M.GT.0.1*C2266M) THEN
         FLONG = 1000.
         ISPLIT = 0
C The alternate solution is needed even for long, narrow panels if
C there exit significant C16 or C26 terms (called B16, B26 in the
C literature on composite plates and shells).
      ENDIF
      FACT = 6.4
C BEG JUN 2007
      PI = 3.1415927
      IF (IFLAT.EQ.0.AND.NUMSTR.EQ.0.AND.NUMRNG.EQ.0) FACT=0.8*PI
C END JUN 2007
C BEG NOV 2003
C     IF (IFLAT.EQ.0.AND.((NWAVE.GT.3.AND.IDISCT.EQ.0).OR.
C    1                    (NWAVE.GT.1000.AND.IDISCT.EQ.1))) THEN
      IF (IFLAT.EQ.0.AND.((NWAVE.GT.3.AND.IDISCX).OR.
     1                    (NWAVE.GT.1000.AND.IDISCZ))) THEN
C END NOV 2003
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,/,A)')
     1 ' No alternative solution sought because there are more than 3',
     1 ' circumferential halfwaves in the hoop direction according to',
     1 ' the original PANDA-type closed-form theory.'
C  The original PANDA-type closed form theory is given in the paper,
C  "Theoretical basis...", COMPUTERS AND STRUCTURES, vol. 27, no. 4,
C  pp 541-563, 1987, especially see Eqs (50) and (57) therein. If the
C  panel is curved and if the original PANDA-type buckling theory yields
C  a critical buckling mode with more than 3 circumferential halfwaves,
C  then do NOT do the alternate solution because, given the rather small
C  upper limit on the circ. index for the y-coordinate trigonometric
C  series expansions, the alternative solution may lead to a buckling
C  load factor that is unacceptably unconservative.
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
      IF (IFLAT.EQ.0.AND.YLONG.GT.FACT*RADIUS) THEN
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,1P,E12.4,A,1P,E12.4)')
     1 ' No alternative solution sought because hoop arc length is',
     1 ' greater than FACT*RADIUS: FACT=',FACT,', RADIUS=',RADIUS
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
      IF (XLONG.GT.FLONG*YLONG) THEN
C BEG NOV 2003
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,1P,E12.4,A)')
     1 ' No alternative solution sought because the axial length of',
     1 ' the panel is greater than',FLONG,' times the hoop arc length.'
C END NOV 2003
C If the panel has a very high a/b aspect ratio, do NOT do the alternate
C solution. The original PANDA-type one-term solution is good enough.
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
      IF (YLONG.GT.FLONG*XLONG) THEN
C BEG NOV 2003
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,1P,E12.4,A)')
     1 ' No alternative solution sought because the hoop arc length of',
     1 ' the panel is greater than',FLONG,' times the axial length.'
C BEG NOV 2003
C If the panel has a very high b/a aspect ratio, do NOT do the alternate
C solution. The original PANDA-type one-term solution is good enough.
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (CS16M.LT.0.1*C2266M.AND.
     1    (ABS(SLOPE).LE.0.02.OR.ABS(SLOPE).GE.50.)
C BEG NOV 2003
C    1                       .AND.IDISCT.EQ.0) THEN
     1                       .AND.IDISCX) THEN
C END NOV 2003
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,/,A,/,A,1P,E12.4,A)')
     1 ' No alternative solution sought because the B16 coeff. is',
     1 ' small and, according to the original PANDA-type model, the',
     1 ' slope of the buckling nodal lines is either very small or',
     1 ' very large. (SLOPE =',SLOPE,').'
C The quantity SLOPE is the slope of the buckling nodal lines in the
C critical buckling mode obtained from the original PANDA-type theory.
C See Fig. 9 on p 554 of the "Theoretical basis..." reference cited above
C for a picture of the sloping buckling nodal lines.
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
C
C     ESTABLISH WHETHER SKEWED BUCKLE ANALYSIS IS REQUIRED...     
C     
      ISHEAR = 0  
      ANORM = SQRT(NX**2 +NY**2)
      IF (ABS(NXY).GT.0.10*ANORM) ISHEAR = 1    
      IF (ABS(NXY0).GT.0.10*ANORM) ISHEAR = 1
      IF (ISHEAR.EQ.0.AND.NX.GT.0.0.AND.NY.GT.0.0) THEN
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,/,A)')
     1 ' No alternative solution sought because there is no',
     1 ' significant in-plane shear loading Nxy (ISHEAR=0) and both',
     1 ' axial and hoop loading components, Nx and Ny, are positive.'
         IF (IDESGN.EQ.0) ILOCAL = 1
         RETURN
      ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
      IBAL = 0
      IF (ABS(CSTIFF(1,3)).GT.0.05*CSTIFF(1,1)) IBAL = 1  
      IF (ABS(CSTIFF(2,3)).GT.0.05*CSTIFF(2,2)) IBAL = 1  
      IF (ABS(CSTIFF(1,6)).GT.CSTIFF(6,6)) IBAL = 1  
      IF (ABS(CSTIFF(2,6)).GT.CSTIFF(6,6)) IBAL = 1  
C  GAMMAB and DELTAB are from Eqs(11c,d), p 666, of M. P. Nemeth's paper
C  "Nondimensional parameters and equations for buckling of anisotropic
C  shallow shells", J. Appl. Mech, Vol. 61, pp 664-669, 1994.
      GAMMAB = ABS(CSTIFF(4,6))/SQRT(SQRT(CSTIFF(5,5)*CSTIFF(4,4)**3))
      DELTAB = ABS(CSTIFF(5,6))/SQRT(SQRT(CSTIFF(4,4)*CSTIFF(5,5)**3))
      IF (GAMMAB.GT.0.1.OR.DELTAB.GT.0.1) IBAL = 1
C BEG NOV 2003
C     IF (ISHEAR.EQ.0.AND.IBAL.EQ.0.AND.IDISCT.EQ.0) THEN
      IF (ISHEAR.EQ.0.AND.IBAL.EQ.0.AND.IDISCX) THEN
C END NOV 2003
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,/,A)')
     1 ' No alternative solution sought because there is no',
     1 ' significant in-plane shear loading Nxy (ISHEAR=0) and there',
     1 ' is no significant anisotropy (IBAL=0).'
         ILOCAL = 1
         IF (IDESGN.EQ.0) ILOCAL = 1
      ENDIF
C
C  Test for whether or not u and v must be included, or is just w
C  sufficient?
      IUV = 0
C  u and v buckling modal displacement components must be included if the
C  panel is curved.
      IF (IFLAT.EQ.0) IUV = 1
      IF (ABS(CSTIFF(1,6)).GT.CSTIFF(6,6)) IUV = 1  
      IF (ABS(CSTIFF(2,6)).GT.CSTIFF(6,6)) IUV = 1
C  u and v buckling modal displacement components must be included if there
C  exist significant anisotropic terms, C16 or C26, such as is the case in
C  a two-layered panel with [+theta,-theta] layup, even if the panel is flat.
C
      IIMAX = 5
C BEG NOV 2003
C     IF (ISPLIT.EQ.1.AND.(IDISCT.EQ.1.OR.IDESGN.EQ.1)) IIMAX = 7
      IF (ISPLIT.EQ.1.AND.(IDISCZ.OR.IDESGN.EQ.1)) IIMAX = 7
C END NOV 2003
C BEG JAN 2005
C BEG FEB 2005
      IF (ISPLIT.EQ.1.AND.
     1    (ILCGLB.EQ.2.OR.ILCGLB.EQ.3.OR.ILCGLB.EQ.4.OR.ILCGLB.EQ.6))
     1                                                  IIMAX = 11
C END FEB 2005
C END JAN 2005
      IF (IUV.EQ.0) THEN
         MAMAX = 0
         NAMAX = 0
         MBMAX = 0
         NBMAX = 0
         MDMAX = 0
         NDMAX = 0
         MEMAX = 0
         NEMAX = 0
         IIMAX  = 11
      ENDIF
C  The upper limit IIMAX on all (u,v,w) trig. series expansions is 5 if
C  u,v displacement components are present and 11 if only the w displacement
C  component is present in the alternate solution buckling mode. (NOTE: the
C  "5" is increased to 7 later in the calculations, provided that ISPLIT = 1).
      II = IIMAX
C     DO 999 II = IIMAX,IIMAX
      MCMAX = II
      NCMAX = II
      IF (IUV.EQ.1) THEN
         MAMAX = II
         NAMAX = II
         MBMAX = II
         NBMAX = II
         MDMAX = II
         NDMAX = II
         MEMAX = II
         NEMAX = II
      ENDIF
C
      FLATMT = 1.
      IF (IFLAT.NE.0) FLATMT = 0.
C23456789012345678901234567890123456789012345678901234567890123456789012
C
      FISAND = 0.
      IF (ISANDQ.EQ.1.OR.ISANDQ.EQ.2) FISAND = 1.
      CUR  = FLATMT/RADIUS
      FNX = NX
      FNY = NY
      FNXY= NXY
      FNX0 = NX0
      FNY0 = NY0
      FNXY0= NXY0
      FNYTST = 0.
      IF (FNY.LT.0.0) FNYTST = FNY
      FNXTST = 0.
      IF (FNX.LT.0.0) FNXTST = FNX
      FNNORM = SQRT(FNXTST**2 + FNYTST**2 + FNXY**2)
      FNNRM0 = SQRT(FNX0**2 + FNY0**2 + FNXY0**2)
      DO 20 I = 1,6
      DO 10 J = 1,6
      C(I,J) = CSTIFF(I,J)
   10 CONTINUE
   20 CONTINUE
      DO 22 I = 1,2
       DNXSTR(I) = FNXSTR(I)
       DX0STR(I) = FX0STR(I)
       ZDXSTR(I) = ZNXSTR(I)
       DNXRNG(I) = FNXRNG(I)
       DX0RNG(I) = FX0RNG(I)
       ZDXRNG(I) = ZNXRNG(I)
   22 CONTINUE
      LUPPR1(1) = 2
      LUPPR2(1) = 2     
      IF (ABS(DNXSTR(2)).LT.0.00001*ABS(DNXSTR(1))) LUPPR1(1) = 1
      IF (ABS(DX0STR(2)).LT.0.00001*ABS(DNXSTR(1))) LUPPR2(1) = 1
      IF (ABS(DX0STR(1)).LT.0.00001*ABS(DNXSTR(1))) LUPPR2(1) = 0
      LUPPR1(2) = 2
      LUPPR2(2) = 2
      IF (ABS(DNXRNG(2)).LT.0.00001*ABS(DNXRNG(1))) LUPPR1(2) = 1
      IF (ABS(DX0RNG(2)).LT.0.00001*ABS(DNXRNG(1))) LUPPR2(2) = 1
      IF (ABS(DX0RNG(1)).LT.0.00001*ABS(DNXRNG(1))) LUPPR2(1) = 0
      EASTR  = EAS
      EIXSTR = EIXS
      EIYSTR = EIYS
      GJSTR  = GJS
      ECCSTR = ECCS
      SPCSTR = SPSTR
      EARNG  = EAR
      EIXRNG = EIXR
      EIYRNG = EIYR
      GJRNG  = GJR
      ECCRNG = ECCR
      SPCRNG = SPRNG
C
C  ASPCTX and ASPCTY are factors which modify the axial length (ASPCTX)
C  and circumferential length (ASPCTY) of panel to be analyzed with the
C  alternative theory. These factors become different from unity for
C  panels in which there are many more buckling halfwaves in one
C  coordinate direction than in the other coordinate direction.
C
      ASPCTX = 1.0
      ASPCTY = 1.0
      MCOMPR = 3
      IF (IUV.EQ.0) MCOMPR = 6
      IF (IFLAT.EQ.0) MCOMPR = 6
      NCOMPR = 3
      IF (IUV.EQ.0) NCOMPR = 6
      IF ((IFLAT.EQ.0.AND.NX.LT.0.0.AND.ABS(NXY).LT.0.2*ABS(NX)).OR.
     1    (IFLAT.NE.0.AND.(NX.LT.0.0.OR.NY.LT.0.0)))             THEN
C BEG NOV 2003
C        IF (IDISCT.EQ.0.AND.MWAVE.GT.MCOMPR.AND.NWAVE.LE.1)
C    1                                       ASPCTX = MWAVE/MCOMPR
C        IF (IDISCT.EQ.0.AND.NWAVE.GT.NCOMPR.AND.MWAVE.LE.1)
C    1                                       ASPCTY = NWAVE/NCOMPR
         IF (IDISCX.AND.MWAVE.GT.MCOMPR.AND.NWAVE.LE.1) 
     1                                       ASPCTX = MWAVE/MCOMPR
         IF (IDISCX.AND.NWAVE.GT.NCOMPR.AND.MWAVE.LE.1)
     1                                       ASPCTY = NWAVE/NCOMPR
C END NOV 2003
      ENDIF
C
      IBACK = 0
      XMIN = 0.
      IFINAL = 1
      IF (IDESGN.EQ.0) IFINAL = 0
C BEG NOV 2003
C     IF (IDISCT.EQ.0.AND.IDESGN.EQ.1) THEN
      IF (IDISCX.AND.IDESGN.EQ.1) THEN
C END NOV 2003
         ASPCTX = ASPSVX
         AXPCTY = ASPSVY
      ENDIF
   25 CONTINUE
      KOUNT = 0
      CALL MOVER(10.E+16,0,EIGTRY,1,20)
      CALL MOVER(XLONG,0,XLG,1,20)
   30 CONTINUE
      KOUNT = KOUNT + 1
C BEG DEC 2003
      IF (NPRT.GE.2) WRITE(IFILE,'(/,/,A,/,A,I2,/,A)')
     1' *******************************************************',
     1' In loop for sublength evaluation, Trial No. ',KOUNT,
     1' *******************************************************'
C END DEC 2003
C                                (KOUNT is a loop index that keeps track of
C                                 the number of times re-analysis of a new
C                                 sublength of panel is required in the search
C                                 for the most critical buckling load factor
C                                 from the alternate solution. Eigenvalues
C                                 from each re-analysis are stored in the
C                                 vector, EIGTRY(KOUNT), and the corresponding
C                                 sublength of panel is stored in XLG(KOUNT).)
      IF (KOUNT.GT.1) THEN
         XMAXS = XMAX
         YMAXS = YMAX
      ENDIF
C  XMAX = current axial sublength being analyzed with alternate solution.
C  YMAX = current hoop  sublength being analyzed with alternate solution.
      XMAX = XLONG/ASPCTX
      YMAX = YLONG/ASPCTY
      IF (IBACK.EQ.1.AND.XMAX.LE.XMIN) THEN
         EIGTRY(KOUNT) = EIGBCK
         XLG(KOUNT) = XMIN
         KOUNT = KOUNT + 1
         EIGTRY(KOUNT) = EIGBK2
         XLG(KOUNT) = XMIN2
         XMAX = XMIN2
         GO TO 305
      ENDIF
      IF (KOUNT.EQ.1) THEN
         XMAXS = XMAX
         YMAXS = YMAX
      ENDIF
C
      IODLOW = 1
      IODHI  = 2
      EIGODD = 10.E+16
      EIGEVN = 10.E+16
      IF (ISPLIT.EQ.0) IODHI = 1
      IF (IDESGN.EQ.1.AND.ISPLIT.EQ.1) THEN
         IODLOW = IODEVS(ILCGLB)
         IODHI  = IODLOW
C BEG NOV 2003
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRT.GE.2) WRITE(IFILE,'(A,I3)')' IODEVS=',IODEVS(ILCGLB)
C END NOV 2003
      ENDIF
C BEG MAR 2005
      IBACK2 = 0
   27 CONTINUE
C END MAR 2005
C  The "DO 162.." loop corresponds to the (m+n)=odd (IODEVN=1) and
C  (m+n)=even (IODEVN=2) subsets of the equation system Ax = lambda*Bx.
      DO 162 IODEVN = IODLOW,IODHI
       NDEL = 1
       IF (IODEVN.EQ.2) NDEL = -1
C  MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX = total numbers of "A", "B", "C",
C                                       "D", and "E" trig. terms in the
C                                       series expansions given in Eq.(438.1)
       IF (ISPLIT.EQ.0) THEN
        NDEL = 0
        MNAMAX = MAMAX*NAMAX
        MNBMAX = MBMAX*NBMAX
        MNCMAX = MCMAX*NCMAX
        MNDMAX = MDMAX*NDMAX
        MNEMAX = MEMAX*NEMAX
       ELSE
        MNAMAX = ((MAMAX+1)/2)*(NAMAX-NDEL)/2 +(MAMAX/2)*(NAMAX+NDEL)/2
        MNBMAX = ((MBMAX+1)/2)*(NBMAX-NDEL)/2 +(MBMAX/2)*(NBMAX+NDEL)/2
        MNCMAX = ((MCMAX+1)/2)*(NCMAX-NDEL)/2 +(MCMAX/2)*(NCMAX+NDEL)/2
        MNDMAX = ((MDMAX+1)/2)*(NDMAX-NDEL)/2 +(MDMAX/2)*(NDMAX+NDEL)/2
        MNEMAX = ((MEMAX+1)/2)*(NEMAX-NDEL)/2 +(MEMAX/2)*(NEMAX+NDEL)/2
       ENDIF
C      MNTOT = rank of the stiffness/load-geometric matrices.
       MNTOT  = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C BEG DEC 2003
       IF (NPRT.GE.2) WRITE(IFILE,'(/,A,I3,/,A,I5,A,I5)')
     1' "Do 162" index: Sublength Trial No.=',KOUNT,
     1' "Do 162" index, IODEVN=',IODEVN,'; system rank, MNTOT=',MNTOT
C END DEC 2003
       IF (NPRT.GE.2.AND.
     1 (NPRT.GE.3.OR.IODEVN.EQ.2.OR.IDESGN.EQ.1.OR.ISPLIT.EQ.0)) THEN
         IF (KOUNT.EQ.1.AND.IBACK.EQ.0) THEN
         WRITE(IFILE,'(/,A,I4,/,A,/,10I5,/,A,/,A,/,A,/,A,/,A,/,A,/,A)')
     1 ' Entering ALTSOL. MNTOT=',MNTOT,
     1 ' MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,MEMAX,NEMAX=',
     1   MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,
     1 ' Here we find the buckling load factor from the "alternative',
     1 ' solution": double trigonometric series expansions for the',
     1 ' buckling modal displacment components, u, v, w, in contrast',
     1 ' to the simple "one term" Rayleigh method of the original',
     1 ' PANDA analysis leading to Eq.(57) of the paper, "Theoretical',
     1 ' basis of the PANDA computer program...", Computers and',
     1 ' Structures, Vol. 27, No. 4, pp 541-563, 1987'
         WRITE(IFILE,'(A,/,A,/,A,/,A,/,A)')
     1 ' **** NOTE: The shell is PERFECT ****',
     1 ' Imperfections are accounted for via knockdown factors',
     1 ' generated from the original PANDA-type theory as described',
     1 ' in the paper, "Approximate method...", Computers and',
     1 ' Structures, Vol. 59, No. 3, pp 489-527, 1996'
         WRITE(IFILE,'(/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A)')
     1 ' NOMENCLATURE:',
     1 '  MNTOT = rank of the stiffness and load geometric matrices',
     1 '  XMAX      = axial length of panel included in the model',
     1 '  YMAX      = "hoop" (circumferential arc) length of model',
     1 '  RADIUS    = radius of curvature of the panel',
     1 '  M         = number of axial halfwaves',
     1 '  N         = number of "hoop" (circumferential) halfwaves',
     1 '  Nx,Ny,Nxy = in-plane resultants in Load Set A',
     1 '  Nx0,Ny0,Nxy0 = in-plane resultants in Load Set B',
     1 '  t.s.d.    = transverse shear deformation effect',
     1 '  ISANDQ    = 0=Donnell, 1=Sanders, 2=Marlowe theory'
         WRITE(IFILE,'(/,A,I2)')' Shell theory indicator, ISANDQ=',
     1                                                    ISANDQ
         IF (IREDUC.NE.0) WRITE(IFILE,'(A,A,/,A,I6,1P,E12.4,A)')
     1 ' critical wave no. and eigenvalue from PANDA-type analysis',
     1 ' (with t.s.d.)=',
     1 '                                ',  MWAVE,EIGOLD,WORD2
         IF (IREDUC.EQ.0) WRITE(IFILE,'(A,A,/,A,I6,1P,E12.4,A)')
     1 ' critical wave no. and eigenvalue from PANDA-type analysis',
     1 ' (without t.s.d.)=',
     1 '                                ',  MWAVE,EIGOLD,WORD2
C BEG AUG 2003
         WRITE(IFILE,'(A,A,/,A,I6,1P,E12.4,A)')
     1 ' High-m wavenumber and eigenvalue from PANDA-type analysis',
     1 ' (without t.s.d.)=',
     1 '                                ',  MWCOMP,EIGCMP,WORD2
C END AUG 2003
         ENDIF
         WRITE(IFILE,'(/,A,1P,5E11.3)')' XMAX,YMAX,NX,NY,NXY=',
     1                                   XMAX,YMAX,FNX,FNY,FNXY
         WRITE(IFILE,'(A,1P,3E11.3)')' NX0,NY0,NXY0=',NX0,NY0,NXY0
       ENDIF
C BEG JAN 2005
       ISTORE = 2*MNTOT*MNTOT
       ISTOR2 = 2*MNTOT
C      ISTORE = 200000
C      ISTOR2 = 800
C END JAN 2005
       CALL MOVER(0.,0,A,1,ISTORE)
       CALL MOVER(0.,0,B,1,ISTORE)
       CALL MOVER(0.,0,EVECT,1,ISTORE)
       IF (IDESGN.EQ.0) CALL MOVER(0.,0,EIGALT,1,ISTOR2)
       IF (IDESGN.EQ.1) THEN
          EIGVAL = 0.
C BEG MAR 2005
          IF (IBACK2.EQ.0)
     1    CALL MOVER(EIGALS(1,ILCGLB),1,EIGALT,1,ISTOR2)
C END MAR 2005
C BEG JAN 2005
          IF (NPRT.GE.3) THEN
C END JAN 2005
             WRITE(IFILE,'(/,A,I2,A,1P,E12.4)')
     1     ' Eigenvalue for IODEVS =',IODEVS(ILCGLB),' =',EIGVAL
             WRITE(IFILE,145) (EIGALT(I),I=1,MNTOT)
          ENDIF
       ENDIF
       CALL MOVER(0.,0,WORKSP,1,ISTOR2)
C
       IF (NX.LT.0.0.OR.NY.LT.0.0.OR.NXY.NE.0.0) THEN
C  Compute stiffness matrix, A:
C BEG DEC 2003
       IF (NPRT.GE.3) WRITE(IFILE,'(A)')' Enter Subroutine  TRIGU'
C END DEC 2003
         CALL TRIGU(A,C,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,
     1        MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1        MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C
C  "A" is the MNTOT X MNTOT stiffness matrix.
C  "C" is the 6 x 6 integrated constitutive matrix.
C  "CUR" is the curvature (1/RADIUS) of the panel.
C  "XMAX" is the current axial sublength of panel.
C  "YMAX" is the current circ. sublength of panel.
C  FISAND is an index for which shell theory to use:
C         FISAND = 0. for Donnell theory
C         FISAND = 1. for either Sanders or Marlowe theory.
C
C  Add discrete stiffeners (See ITEM 444 in ...panda2/doc/panda2.news)
C BEG DEC 2003
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (IDISCT.EQ.1) THEN
            IF (NPRT.GE.3) WRITE(IFILE,'(A)')' Enter Subroutine  TRIGST'
            CALL TRIGST(A,B,EASTR,EIXSTR,EIYSTR,GJSTR,ECCSTR,
     1                    EARNG,EIXRNG,EIYRNG,GJRNG,ECCRNG,
     1        SPCSTR,SPCRNG,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,
     1        NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1        DNXSTR,DX0STR,ZDXSTR,DNXRNG,DX0RNG,ZDXRNG,LUPPR1,LUPPR2,
     1        MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,NUMSTR,NUMRNG,
     1        ISPLIT)
         ENDIF
C END DEC 2003
C
C  Add contribution of load set B to the stiffness matrix, A:
         IF (FNNRM0.GT.0.001*FNNORM) THEN
C BEG DEC 2003
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGW or TRIGWM, Loadset B'
C END DEC 2003
            IF (ISANDQ.EQ.0.OR.ISANDQ.EQ.1)
C             TRIGW is for either Donnell theory or Sanders theory.
     1        CALL TRIGW(A,FNX0,FNY0,FNXY0,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C
            IF (ISANDQ.EQ.2)
C             TRIGWM is for Marlow theory.
     1        CALL TRIGWM(A,FNX0,FNY0,FNXY0,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
         ENDIF
C
C  Compute load-geometric matrix, B:
C BEG DEC 2003
         IF (ISANDQ.EQ.0.OR.ISANDQ.EQ.1) THEN
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGW, Load Set A'
C           TRIGW is for either Donnell theory or Sanders theory.
            CALL TRIGW(B,FNX,FNY,FNXY,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
         ENDIF
C
         IF (ISANDQ.EQ.2) THEN
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGWM, Load Set A'
C           TRIGWM is for Marlow theory.
            CALL TRIGWM(B,FNX,FNY,FNXY,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
         ENDIF
C END DEC 2003
C
C  Find eigenvalues and eigenvectors:
         IF (IDESGN.EQ.0) THEN
C  Use generalized Jacobi iteration for current design computations...
            CALL GSEIG (MNTOT, A, B, EIGALT, EVECT, WORKSP, IPRINT)
         ELSE
C  Use Rayleigh quotient for perturbed design computations...
C BEG MAR 2005
C23456789012345678901234567890123456789012345678901234567890123456789012
            IF (IBACK2.EQ.0) THEN
               CALL RAYQUO(MNTOT,EIGALT,A,B,EIGRAY)
C
C Following commented-out section is now included so you can use
C it instead of using RAYQUO to find the eigenvalue for the perturbed
C design. If you want to use GSEIG instead of RAYQUO, simply "comment
C out" the statement above, "CALL RAYQUO...", and "un-comment" the following.
C However, in doing this I have found RAYQUO to be very accurate.
C
            ELSE
               CALL GSEIG (MNTOT, A, B, EIGALT, EVECT, WORKSP, IPRINT)
               IF (MNTOT.LT.0) THEN
                 WRITE(IFILE,'(A,/,A,I4,/,A)')
     1      ' ***** WARNING ********** WARNING ********* WARNING *****',
     1      ' SUB. GSEIG FAILED TO OBTAIN EIGENVALUE: MNTOT=',MNTOT,
     1      ' ***** WARNING ********** WARNING ********* WARNING *****'
                 CALL ERREX
               ENDIF
               EIGVAL = 10.E+16
               DO 118 I = 1,MNTOT
                 EIGTST = -EIGALT(I)
                 IF (EIGTST.GT.0.0) EIGVAL = MIN(EIGVAL,EIGTST)
C  The critical eigenvalue is the minimum positive eigenvalue.
  118          CONTINUE
               EIGRAY = EIGVAL 
            ENDIF
C END MAR 2005
C BEG JUN 2006
            IF (IALTSK(ILCGLB).EQ.1) EIGRAY = 10.E+17
C END JUN 2006
            EIGVAL = EIGRAY
C BEG NOV 2003
            IF (NPRT.GE.2) WRITE(IFILE,'(A,1P,E12.4)')
     1    ' Eigenvalue from Rayleigh Quotient, EIGRAY=',EIGRAY
C BEG OCT 2004
            IF (ISIGNL.EQ.1.AND.(ILCGLB.EQ.1.OR.ILCGLB.EQ.5)
     1             .AND.EIGCMP.LT.0.95*EIGVAL) EIGVAL = EIGCMP/0.95
C END OCT 2004
            IF (NPRT.GE.2) WRITE(IFILE,'(A,1P,E12.4)')
     1    ' Final eigenvalue from this section,EIGVAL=',EIGVAL
C END NOV 2003
C BEG MAR 2005
            IF (IBACK2.EQ.1) THEN
               WRITE(IFILE,'(A,1P,E12.4,/,A,E12.4)')
     1       ' New eigenvalue, EIGVAL=',EIGVAL,
     1       ' Old eigenvalue, EIGSVG=',EIGSVG
               IF (EIGVAL.GT.EIGSVG) THEN
                  WRITE(IFILE,'(A,/,A,1P,E12.4)')
     1          ' The old eigenvalue is smaller than the new.',
     1          ' Therefore, use the old eigenvalue, EIGSVG=',EIGSVG
                  EIGVAL = EIGSVG
               ENDIF
            ENDIF
C
            IF (IBACK2.EQ.0.AND.ILCGLB.EQ.2) THEN
               EIGUNP = MIN(EODDBB,EEVNBB)
               IF ((BB(1).GT.1.001*BSTRNG.OR.BB(2).GT.1.001*BRINGS)
     1                                      .AND.EIGVAL.GT.EIGUNP) THEN
                 IF (BB(1).GT.1.001*BSTRNG) WRITE(IFILE,'(/,A,/,A)')
     1         ' ******** NOTE FROM ALTSOL, GENERAL BUCKLING ********',
     1         ' Stringer spacing is the decision variable and the'
                 IF (BB(2).GT.1.001*BRINGS) WRITE(IFILE,'(/,A,/,A)')
     1         ' ******** NOTE FROM ALTSOL, GENERAL BUCKLING ********',
     1         ' Ring spacing is the decision variable and the'
                 WRITE(IFILE,'(A,/,A,/,A,1P,E12.4,/,A,E12.4)')
     1         ' perturbed design has a higher buckling load than the',
     1         ' unperturbed design:',
     1         ' Buckling load for UNPERTURBED design, EIGUNP=',EIGUNP,
     1         ' Buckling load for   PERTURBED design, EIGPER=',EIGVAL
                 IF (IODEVS(ILCGLB).EQ.1) THEN
                    WRITE(IFILE,'(A,/,A,/,A,/,A)')
     1            ' Critical eigenvalue for the UNPERTURBED design',
     1            ' corresponds to (m+n) = ODD. We must next check to',
     1            ' see if (m+n) = EVEN yields a smaller buckling load',
     1            ' for the PERTURBED design than does (m+n) = ODD.'
                    CALL MOVER(EVGEN2,1,EIGALT,1,ISTOR2)
                    IODLOW = 2
                    IODHI  = IODLOW
                 ENDIF
                 IF (IODEVS(ILCGLB).EQ.2) THEN
                    WRITE(IFILE,'(A,/,A,/,A,/,A)')
     1            ' Critical eigenvalue for the UNPERTURBED design',
     1            ' corresponds to (m+n) = EVEN. We must next check to',
     1            ' see if (m+n) = ODD yields a smaller buckling load',
     1            ' for the PERTURBED design than does (m+n) = EVEN.'
                    CALL MOVER(EVGEN1,1,EIGALT,1,ISTOR2)
                    IODLOW = 1 
                    IODHI  = IODLOW
                 ENDIF
                 IBACK2 = 1
                 EIGSVG = EIGVAL
               ENDIF
               IF (IBACK2.EQ.1) GO TO 27
            ENDIF
C END MAR 2005
            GO TO 1001
         ENDIF
       ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
C  The following computations (up to Statement No. 1001) are performed
C  only for the current design (IDESGN = 0):
       IF (MNTOT.LT.0) THEN
          WRITE(IFILE,'(A,/,A,I4,A,I2/,A)')
     1  ' ***** WARNING ********** WARNING ********* WARNING *****',
     1  ' SUB. GSEIG FAILED TO OBTAIN EIGENVALUE: MNTOT=',MNTOT,
     1  '; IODEVN=',IODEVN,
     1  ' ***** WARNING ********** WARNING ********* WARNING *****'
          GO TO 162
       ENDIF
       IF (NPRT.GE.3)
C BEG DEC 2003
     1   WRITE(IFILE,100) KOUNT,XMAX,IODEVN,(-EIGALT(I),I=1,MNTOT)
  100  FORMAT(/,' Trial No. ',I3,', Sublength,XMAX=',1P,E12.4,
     1' Odd-Even Index, IODEVN=',I2,/,
     1' Eigenvalues from GSEIG, EIGALT(i),i=1,MNTOT:',/,
     1 1P,(5E12.4))
C END DEC 2003
       EIGVAL = 10.E+16
       DO 120 I = 1,MNTOT
         EIGTST = -EIGALT(I)
         IF (EIGTST.GT.0.0) EIGVAL = MIN(EIGVAL,EIGTST)
C  The critical eigenvalue is the minimum positive eigenvalue.
  120  CONTINUE
       IF (IODEVN.EQ.1) EIGODD = EIGVAL
       IF (IODEVN.EQ.2) EIGEVN = EIGVAL
C
C  Begin logic for inspecting the eigenvector to see if the dimensions
C  XMAX, YMAX of the panel must be changed in order accurately to capture
C  the critical buckling mode.
C  
       DO 130 I = 1,MNTOT
         ICRIT = I
         DIFF = ABS(EIGVAL+EIGALT(I))/ABS(EIGVAL)
         IF (DIFF.LT.0.0001) GO TO 140
  130  CONTINUE
  140  CONTINUE
       ISTART = (ICRIT-1)*MNTOT + 1
       IEND   = ISTART + MNTOT - 1
C BEG OCT 1998
C      IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCT.EQ.1)) THEN
       IF (NPRT.GE.3) THEN
C END OCT 1998
         WRITE(IFILE,'(A,I2,A,1P,E12.4)')
     1 ' Eigenvalue for IODEVN =',IODEVN,' =',EIGVAL
         WRITE(IFILE,145) (EVECT(I),I=ISTART,IEND)
       ENDIF
  145  FORMAT(/' Critical eigenvector from GSEIG,EVECT(i),i=1,MNTOT:',/,
     1  1P,(5E12.4))
C23456789012345678901234567890123456789012345678901234567890123456789012
       III = 0
       DO 146 I = ISTART,IEND
C  Extract the critical eigenvector corresponding to the critical
C  eigenvalue, EIGVAL:
          III = III + 1
          IF (IODEVN.EQ.1) EVECT1(III) = EVECT(I)
          IF (IODEVN.EQ.2) EVECT2(III) = EVECT(I)
  146  CONTINUE
       IF (NPRT.GE.3) THEN
         WRITE(IFILE,'(/,A,I2,A,1P,E12.4)')
     1 ' Eigenvalue for IODEVN =',IODEVN,' =',EIGVAL
         IF (IODEVN.EQ.1) WRITE(IFILE,145) (EVECT1(I),I=1,MNTOT)
         IF (IODEVN.EQ.2) WRITE(IFILE,145) (EVECT2(I),I=1,MNTOT)
       ENDIF
       CALL MOVER(0.,0,WDISP,1,121)
       CALL MOVER(0.,0,WMAXM,1,MCMAX)
       K = ISTART - 1
C BEG JUN 2006
       WMAXAL = 0.0
C END JUN 2006
       DO 160 I = 1,MCMAX
       NSTART = 1
       NINCR = 1
       IF (ISPLIT.EQ.1) THEN
          NINCR = 2
          IMOD = MOD(I,2)
          IF (IODEVN.EQ.1) THEN
            NSTART = 2
            IF (IMOD.EQ.0) NSTART = 1
          ELSE
            NSTART = 1
            IF (IMOD.EQ.0) NSTART = 2
          ENDIF
       ENDIF
       DO 150 J = NSTART,NCMAX,NINCR
C  Extract the normal displacement component from the critical eigenvector.
         K = K + 1
         WDISP(I,J) = EVECT(K)
         WMAXM(I) = MAX(WMAXM(I),ABS(WDISP(I,J)))
  150  CONTINUE
C BEG JUN 2006
       WMAXAL = MAX(WMAXAL,WMAXM(I))
C END JUN 2006
  160  CONTINUE
C BEG JUN 2006
       IF ((ILCGLB.EQ.2.OR.ILCGLB.EQ.3).AND.IDESGN.EQ.0) THEN
          DO 1602 I = 1,MCMAX
          NCRITM(I) = 0
          DO 1502 J = 1,NCMAX
             DIFFM = 1.0
             IF (WMAXM(I).GT.0.05*WMAXAL)
     1          DIFFM = ABS((WMAXM(I) - ABS(WDISP(I,J)))/WMAXM(I))
             IF (DIFFM.LT.0.001) THEN
                NCRITM(I) = J
                GO TO 1503
             ENDIF
 1502     CONTINUE
 1503     CONTINUE
 1602     CONTINUE
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG MAY 2007
C         IF (NPRT.GE.2) WRITE(IFILE,'(/,A,I3,A,1P,E12.4,/,A,/,11I3)')
          IF (NPRT.GE.0) WRITE(IFILE,'(/,A,I3,A,1P,E12.4,/,A,/,11I3)')
C END MAY 2007
     1  ' IODEVN=',IODEVN,'; Eigenvalue=',EIGVAL,
     1  ' Number of circumferential halfwaves for largest M-component:',
     1                   (NCRITM(I),I=1,MCMAX)
          IF (NUMSTR.GT.0) THEN
             DO 1603 I = 1,MCMAX
                IF (NCRITM(I).NE.0.AND.NCRITM(I).NE.(NUMSTR-1))
     1                                                GO TO 1605
 1603        CONTINUE
C BEG NOV 2006
C23456789012345678901234567890123456789012345678901234567890123456789012
             IF (ILCGLB.EQ.2.AND.NPRT.GE.0) WRITE(IFILE,
     1     '(/,A,I3,/,A,I3,/,A,1P,E12.4,/,A,/,A,/,A,/,A,/,A,/)')
     1     ' In ALTSOL: Index for type of buckling, ILCGLB=',ILCGLB,
     1     ' (m+n)=odd or (m+n)=even: IODEVN=',IODEVN,
     1     ' Buckling load factor (eigenvalue), EIGVAL =',EIGVAL,
     1     ' All significant buckling components represent buckling',
     1     ' between adjacent stringers. Therefore, this mode is',
     1     ' inter-stringer buckling, not general buckling.',
     1     ' Accordingly, the eigenvalue will be set to a high number.',
     1     ' It will therefore not constrain the design.'
C
             IF (ILCGLB.EQ.3.AND.NPRT.GE.0) WRITE(IFILE,
     1     '(/,A,I3,/,A,I3,/,A,1P,E12.4,/,A,/,A,/,A,/,A,/,A,/)')
     1     ' In ALTSOL: Index for type of buckling, ILCGLB=',ILCGLB,
     1     ' (m+n)=odd or (m+n)=even: IODEVN=',IODEVN,
     1     ' Buckling load factor (eigenvalue), EIGVAL =',EIGVAL,
     1     ' All significant buckling components represent buckling',
     1     ' between adjacent stringers. Therefore, this mode is local',
     1     ' buckling, not general buckling. Accordingly, the eigen-',
     1     ' value will be set to a high number. It will therefore',
     1     ' not constrain the design.'
C
C END NOV 2006
             EIGVAL = 10.E+17
             IF (IODEVN.EQ.1) EIGODD = EIGVAL
             IF (IODEVN.EQ.2) EIGEVN = EIGVAL
             ISTEIG(IODEVN,ILCGLB) = 1
 1605        CONTINUE
          ENDIF
C
          DO 1608 I = 1,NCMAX
          WMAXN(I) = 0.
          DO 1607 J = 1,MCMAX
             WMAXN(I) = MAX(WMAXN(I),ABS(WDISP(J,I)))
 1607     CONTINUE
 1608     CONTINUE
C
          DO 1609 I = 1,NCMAX
          MCRITN(I) = 0
          DO 1508 J = 1,MCMAX
             DIFFN = 1.0
             IF (WMAXN(I).GT.0.05*WMAXAL)
     1          DIFFN = ABS((WMAXN(I) - ABS(WDISP(J,I)))/WMAXN(I))
             IF (DIFFN.LT.0.001) THEN
                MCRITN(I) = J
                GO TO 1509
             ENDIF
 1508     CONTINUE
 1509     CONTINUE
 1609     CONTINUE
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG MAY 2007
C         IF (NPRT.GE.2) WRITE(IFILE,'(/,A,I3,A,1P,E12.4,/,A,/,11I3)')
          IF (NPRT.GE.0) WRITE(IFILE,'(/,A,I3,A,1P,E12.4,/,A,/,11I3)')
C END MAY 2007
     1  ' IODEVN=',IODEVN,'; Eigenvalue=',EIGVAL,
     1  ' Number of axial halfwaves for largest N-component:',
     1                   (MCRITN(I),I=1,NCMAX)
C BEG OCT 2006
C         IF (NUMRNG.GT.0) THEN
          IF (NUMRNG.GT.0.AND.ILCGLB.EQ.2) THEN
C END OCT 2006
             DO 1611 I = 1,NCMAX
                IF (MCRITN(I).NE.0.AND.MCRITN(I).NE.(NUMRNG-1))
     1                                                GO TO 1613
 1611        CONTINUE
             WRITE(IFILE,'(A,I3,/A,/,A,/,A,/,A,/,A,/)')
     1     ' Index for type of buckling, ILCGLB=',ILCGLB,
     1     ' All significant buckling components represent buckling',
     1     ' between adjacent rings. Therefore, this mode is interring',
     1     ' buckling, not general buckling. Accordingly, the eigen-',
     1     ' value will be set to a high number. It will therefore',
     1     ' not constrain the design.'
             EIGVAL = 10.E+17
             IF (IODEVN.EQ.1) EIGODD = EIGVAL
             IF (IODEVN.EQ.2) EIGEVN = EIGVAL
             ISTEIG(IODEVN,ILCGLB) = 1
 1613        CONTINUE
          ENDIF
C
       ENDIF
C End of ((ILCGLB.EQ.2.OR.ILCGLB.EQ.3).AND.IDESGN.EQ.0) condition
C END JUN 2006
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG OCT 1998
C      IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCT.EQ.1)) THEN
       IF (NPRT.GE.3) THEN
C END OCT 1998
         WRITE(IFILE,'(/,A,I2,/,A,/,A,A)') 
     1 '  M  Normal buckling modal displacement, w    Trial No.', KOUNT,
     1 '         number of circumferential halfwaves, N',
     1 '         1         2         3         4         5         6',
     1 '         7         8         9         10       11'
         DO 161 I = 1,MCMAX
            WRITE(IFILE,'(I3,1P,11E10.2)') I,(WDISP(I,J),J=1,NCMAX)
  161    CONTINUE
       ENDIF
C BEG OCT 1998
C      IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCT.EQ.1)) 
       IF (NPRT.GE.3) 
C END OCT 1998
     1   WRITE(IFILE,170) (WMAXM(I),I=1,MCMAX)
       IF (IODEVN.EQ.1) THEN
         CALL MOVER(WDISP,1,WDISPS,1,121)
C BEG JAN 2005
         IF (IDESGN.EQ.0) CALL MOVER(WDISP,1,WDISP1,1,121)
C END JAN 2005
         CALL MOVER(WMAXM,1,WMAXMS,1,MCMAX)
       ENDIF
C BEG JAN 2005
       IF (IODEVN.EQ.2) THEN
         IF (IDESGN.EQ.0) CALL MOVER(WDISP,1,WDISP2,1,121)
       ENDIF
C END JAN 2005
  162 CONTINUE
C BEG MAR 2005
C End of the loop over IODEVN = 1 and 2
      IF (IDESGN.EQ.0.AND.ILCGLB.EQ.2) THEN
         BSTRNG = BB(1)
         BRINGS = BB(2)
         EODDBB = EIGODD
         EEVNBB = EIGEVN
      ENDIF
C END MAR 2005
C
C BEG MAY 2007
C     IF (NPRT.GE.2) WRITE(IFILE,'(A,1P,2E12.4)')
      IF (NPRT.GE.0) WRITE(IFILE,'(A,1P,2E12.4)')
C END MAY 2007
     1 ' EIGODD,EIGEVN=',EIGODD,EIGEVN
C  The critical eigenvalue, EIGVAL, is the minimum from the two sets of
C  equations, that corresponding to (m+n)=odd and that corresponding to
C  (m+n)=even.
      EIGVAL = MIN(EIGODD,EIGEVN)
C BEG JUN 2006
      IF (IDESGN.EQ.0.AND.EIGVAL.GE.10.E16
     1 .AND.(ILCGLB.EQ.2.OR.ILCGLB.EQ.3)) IALTSK(ILCGLB) = 1 
C END JUN 2006
      IF (NPRT.GE.0) WRITE(IFILE,'(A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL before t.s.d.=',EIGVAL,
     1'(PERFECT)'
C  Store the critical eigenvalue EIGVAL for the current sublength in the
C  vector, EIGTRY(KOUNT) and the current axial sublength XMAX in XLG(KOUNT).
      EIGTRY(KOUNT) = EIGVAL
      XLG(KOUNT) = XMAX
      DIFF = ABS(EIGODD - EIGVAL)/EIGVAL
C  Move the critical eigenvector (EVECT1 or EVECT2) to EIGALS for later
C  use (perturbed design: IDESGN=1) for computation of the Rayleigh quotient
C  in SUBROUTINE RAYQUO...
C BEG MAR 2005
      IF (IDESGN.EQ.0.AND.ILCGLB.EQ.2) THEN
         CALL MOVER(EVECT1,1,EVGEN1,1,ISTOR2)
         CALL MOVER(EVECT2,1,EVGEN2,1,ISTOR2)
      ENDIF
C END MAR 2005
      IF (DIFF.LT.0.0001) THEN
         IODEVS(ILCGLB) = 1
         CALL MOVER(EVECT1,1,EIGALS(1,ILCGLB),1,ISTOR2)
         CALL MOVER(WDISPS,1,WDISP,1,121)
C BEG JAN 2005
         IF (IDESGN.EQ.0) CALL MOVER(WDISP1,1,WDISP,1,121)
C END JAN 2005
         CALL MOVER(WMAXMS,1,WMAXM,1,MCMAX)
      ELSE
         IODEVS(ILCGLB) = 2
         CALL MOVER(EVECT2,1,EIGALS(1,ILCGLB),1,ISTOR2)
C BEG JAN 2005
         IF (IDESGN.EQ.0) CALL MOVER(WDISP2,1,WDISP,1,121)
C END JAN 2005
      ENDIF
C BEG JAN 2005
      IF (NPRT.GE.3) THEN
C END JAN 2005
         WRITE(IFILE,'(/,A,I2,A,1P,E12.4)')
     1 ' Eigenvalue for IODEVS =',IODEVS(ILCGLB),' =',EIGVAL
         WRITE(IFILE,145) (EIGALS(I,ILCGLB),I=1,MNTOT)
      ENDIF
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG OCT 1998
C BEG NOV 2003
C     IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCT.EQ.1)) THEN
C     IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCZ)) THEN
      IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IIMAX.GT.5)) THEN
C END NOV 2003
C END OCT 1998
C BEG JULY 2006
         IF (ILCGLB.EQ.1) WRITE(IFILE,'(/,A,A)')
     1 ' Eigenvector from ALTSOL model of local buckling with smeared',
     1 ' substiffeners follows.'
         IF (ILCGLB.EQ.2) WRITE(IFILE,'(/,A,A)')
     1 ' Eigenvector from ALTSOL "patch" model of general buckling',
     1 ' follows'
         IF (ILCGLB.EQ.3) WRITE(IFILE,'(/,A)')
     1 ' Eigenvector from ALTSOL model of inter-ring buckling follows.'
         IF (ILCGLB.EQ.4) WRITE(IFILE,'(/,A,A)')
     1 ' Eigenvector from ALTSOL model of patch with discrete',
     1 ' substiffeners follows'
         IF (ILCGLB.EQ.5) WRITE(IFILE,'(/,A,A)')
     1 ' Eigenvector from ALTSOL model of local buckling between',
     1 ' substiffeners follows.'
         IF (ILCGLB.EQ.6) WRITE(IFILE,'(/,A,A)')
     1 ' Eigenvector from ALTSOL model of inter-subring buckling',
     1 ' with discrete substringers follows.'
         WRITE(IFILE,'(A,I2)')
     1 ' Eigenvector for IODEVN =',IODEVS(ILCGLB)
C23456789012345678901234567890123456789012345678901234567890123456789012

C END JULY 2006
C BEG JAN 2006
         IF (NCMAX.LE.7) WRITE(IFILE,'(A,I2,/,A,/,A,A)') 
     1 '  M  Normal buckling modal displacement, w    Trial No.', KOUNT,
     1 '         number of circumferential halfwaves, N',
     1 '         1         2         3         4         5         6',
     1 '         7'
         IF (NCMAX.GT.7) WRITE(IFILE,'(A,I2,/,A,/,A,A)')
     1 '  M  Normal buckling modal displacement, w    Trial No.', KOUNT,
     1 '         number of circumferential halfwaves, N',
     1 '      1     2     3     4     5     6',
     1 '     7     8     9    10    11'
         DO 164 I = 1,MCMAX
            IF (NCMAX.LE.7)
     1       WRITE(IFILE,'(I3,1P,11E10.2)') I,(WDISP(I,J),J=1,NCMAX)
            IF (NCMAX.GT.7)
     1      WRITE(IFILE,'(I3,11F6.3)') I,(WDISP(I,J),J=1,NCMAX)
  164    CONTINUE
C END JAN 2006
      ENDIF
C BEG JAN 2005
      IF (IDESGN.EQ.0.AND.ILCGLB.EQ.3) THEN
         NCHNG3 = 0
         IF (NUMSTR.GT.2) THEN
            NLOCAL = NUMSTR - 1
            IF (NLOCAL.GT.0.AND.NLOCAL.LE.NCMAX) THEN
               DO 165 I = 1,MCMAX
                  IF (ABS(WDISP(I,NLOCAL)).GT.0.7) GO TO 166
  165          CONTINUE
               NCHNG3 = 1
  166          CONTINUE
            ENDIF
         ENDIF
      ENDIF
C
      IF (IDESGN.EQ.0.AND.ILCGLB.EQ.6) THEN
         NCHNG6 = 0
         IF (NUMSTR.GT.2) THEN
            NLOCAL = NUMSTR - 1
            IF (NLOCAL.GT.0.AND.NLOCAL.LE.NCMAX) THEN
               DO 167 I = 1,MCMAX
                  IF (ABS(WDISP(I,NLOCAL)).GT.0.7) GO TO 168
  167          CONTINUE
               NCHNG6 = 1
  168          CONTINUE
            ENDIF
         ENDIF
      ENDIF
C END JAN 2005
C BEG OCT 1998
C BEG NOV 2003
C     IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCT.EQ.1))
C     IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IDISCZ))
      IF (NPRT.GE.3.OR.(NPRT.GE.2.AND.IIMAX.GT.5))
C END NOV 2003
C END OCT 1998
     1   WRITE(IFILE,170) (WMAXM(I),I=1,MCMAX)
  170 FORMAT(/' Maximum normal displacement harmonic w.r.t M=',/,
     1 (1P,5E12.4))
      WMAX = 0.
      DO 180 I=1,MCMAX
         WMAX = MAX(WMAX,WMAXM(I))
  180 CONTINUE
      DO 190 I = 1,MCMAX
         MSPCT  = I
         IF (WMAXM(I).GT.0.5*WMAX) GO TO 200
  190 CONTINUE
  200 CONTINUE
C23456789012345678901234567890123456789012345678901234567890123456789012
C
C BEG NOV 2003
C     IF (IDISCT.EQ.1.OR.IFINAL.EQ.1) GO TO 305
      IF (IDISCZ.OR.IFINAL.EQ.1) GO TO 305
C END NOV 2003
C  Next, decide if a new sublength should be explored. This is only done
C  for the unperturbed design, and only when there are no discrete
C  stiffeners.
      IF (IFLAT.EQ.0.OR.XMAXS.GT.3.*YMAXS) THEN
         IF ((KOUNT.EQ.1.AND.IFLAT.EQ.0).OR.MSPCT.GT.1.OR.
     1    (KOUNT.GT.1.AND.EIGTRY(KOUNT).LT.EIGTRY(KOUNT-1)).OR.
     1 (IFLAT.EQ.0.AND.(MWAVEX.GT.5*MWAVE.OR.FLOAT(MWAVE).GT.3.0*ASPCTX)
     1               .AND.FLOAT(MWAVEX).GT.3.0*ASPCTX
     1               .AND.EIGMNC.LT.3.0*EIGOLD)) THEN
            ASPFCT = 2
            IAGAIN = 0
C  ASPFCT is a factor to be multiplied by the current value of the
C  factor called ASPCTX, which changes the axial length of the portion of
C  panel to be analyzed via the alternate solution.
C  IAGAIN is a switch, which if equal to unity, calls for a buckling analysis
C  of a panel with yet another axial sublength. The buckling load factors from
C  the buckling analyses of panels of various axial sublengths are stored in
C  EIGTRY.
            IF (KOUNT.EQ.1) IAGAIN = 1
            IF (KOUNT.GT.1.AND.EIGTRY(KOUNT).LT.EIGTRY(KOUNT-1))
     1                                                     IAGAIN = 1
            IF (IFLAT.EQ.0.AND.IAGAIN.EQ.0.AND.
     1         (MWAVEX.GT.5*MWAVE.OR.FLOAT(MWAVE).GT.3.0*ASPCTX)
     1        .AND.ILOOP.LT.5.AND.EIGMNC.LT.3.0*EIGOLD
     1        .AND.KOUNT.GT.1.AND.FLOAT(MWAVEX).GT.3.0*ASPCTX
     1        .AND.EIGTRY(KOUNT).GT.EIGTRY(KOUNT-1)) THEN
               ILOOP = ILOOP + 1
               FACTOR = (XMAX/XLONG)*FLOAT(MWAVEX/MCOMPR)
               IF (FACTOR.GT.2.0*ASPCTX) ASPFCT = FACTOR/ASPCTX
               IAGAIN = 1
            ENDIF
C           IF (IFLAT.EQ.0.AND.MWAVEX.GT.5*MWAVE.AND.IAGAIN.EQ.0
C    1        .AND.MSPCT.EQ.MCMAX.AND.EIGMNC.LT.3.0*EIGOLD
C    1        .AND.KOUNT.GT.1.AND.FLOAT(MWAVEX).GT.3.0*ASPCTX
C    1        .AND.EIGTRY(KOUNT).GT.EIGTRY(KOUNT-1)
C    1        .AND.ILOOP2.LT.5) THEN
C              ILOOP2 = ILOOP2 + 1
C              IAGAIN = 1
C           ENDIF
            IF (IAGAIN.EQ.0.AND.KOUNT.GT.2.AND.NPRT.GE.2
     1        .AND.IFLAT.EQ.0.AND.FLOAT(MWAVEX).GT.3.0*ASPCTX)
     1         WRITE(IFILE,'(A,2I3,1PE12.4)')' MSPCT,MCMAX,ASPCTX=',
     1                                         MSPCT,MCMAX,ASPCTX
            IF (IAGAIN.EQ.1.AND.KOUNT.LT.20) THEN
               ASPCTX = ASPFCT*ASPCTX
               GO TO 30
            ENDIF
         ENDIF
      ENDIF
  240 CONTINUE
C
C  The following section is for changing the circumferential sublength
C  of the panel to be re-analyzed.
      IF (IFLAT.NE.0.AND.YMAXS.GT.3.*XMAXS) THEN
         DO 260 I = 1,MCMAX
         DO 250 J = 1,NCMAX
            K = K + 1
            WDISP(I,J) = EVECT(K)
  250    CONTINUE
  260    CONTINUE
C
         DO 263 I = 1,NCMAX
         WMAXN(I) = 0.
         DO 262 J = 1,MCMAX
            WMAXN(I) = MAX(WMAXN(I),ABS(WDISP(J,I)))
  262    CONTINUE
  263    CONTINUE
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRT.GE.3) THEN
            WRITE(IFILE,'(A,I2,/,A,/,A,A)') 
     1 '  N  Normal buckling modal displacement, w    Trial No.', KOUNT,
     1 '             number of axial halfwaves, M',
     1 '         1         2         3         4         5         6',
     1 '         7         8         9         10       11'
            DO 264 I = 1,NCMAX
               WRITE(IFILE,'(I3,1P,11E10.2)') I,(WDISP(J,I),J=1,MCMAX)
  264       CONTINUE
         ENDIF
         IF (NPRT.GE.3) WRITE(IFILE,270) (WMAXN(I),I=1,NCMAX)
  270    FORMAT(/' Maximum normal displacement harmonic w.r.t N=',/,
     1    (1P,5E12.4))
         WMAX = 0.
         DO 280 I=1,NCMAX
            WMAX = MAX(WMAX,WMAXN(I))
  280    CONTINUE
         DO 290 I = 1,NCMAX
            ASPFCT = I
            IF (WMAXN(I).GT.0.5*WMAX) GO TO 300
  290    CONTINUE
  300    CONTINUE
         IF (ASPFCT.GT.1.5.OR.
     1    (KOUNT.GT.1.AND.EIGTRY(KOUNT).LT.EIGTRY(KOUNT-1))) THEN
            ASPFCT = 2
            IAGAIN = 0
            IF (KOUNT.EQ.1) IAGAIN = 1
            IF (KOUNT.GT.1.AND.EIGTRY(KOUNT).LT.EIGTRY(KOUNT-1))
     1                                                     IAGAIN = 1
            IF (IAGAIN.EQ.1.AND.KOUNT.LT.20) THEN
               ASPCTY = ASPFCT*ASPCTY
               GO TO 30
            ENDIF
         ENDIF
      ENDIF
C
  305 CONTINUE
      IF (NPRT.GE.2) WRITE(IFILE,'(A,/,1P,(5E12.4))')
     1' Axial lengths:  (XMAX(i),i=1,KOUNT)=',(XLG(I),I=1,KOUNT)
      IF (NPRT.GE.2) WRITE(IFILE,'(A,/,1P,(5E12.4))')
     1' Load factors: (EIGTRY(i),i=1,KOUNT)=',(EIGTRY(I),I=1,KOUNT)
C
C  Determine the most critical sublength...
      EIGMIN = EIGTRY(1)
      IMIN = 1
      IF (KOUNT.GT.1) THEN
         DO 310 I = 2,KOUNT
            EIGMIN = MIN(EIGMIN,EIGTRY(I))
  310    CONTINUE
         EIGMN1 = EIGMIN
         IF (KOUNT.GT.2) THEN
            DO 320 I = 1,KOUNT
               IMIN = I
               DIFF = ABS(EIGTRY(I)-EIGMIN)/EIGMIN
               IF (DIFF.LT.0.00001) GO TO 330
  320       CONTINUE
  330       CONTINUE
            IF (IMIN.GT.1.AND.IMIN.LT.KOUNT) THEN
C       Do parabolic interpolation to get minimum eigenvalue... (voided)
               X1 = XLG(IMIN) - XLG(IMIN-1)
               Y1 = EIGTRY(IMIN-1) - EIGTRY(IMIN)
               X3 = XLG(IMIN) - XLG(IMIN+1)
               Y3 = EIGTRY(IMIN+1) - EIGTRY(IMIN)
               H  = 0.5*(Y1*X3**2 - Y3*X1**2)/(X3*Y1 - X1*Y3)
               DELEIG = Y1*H**2/(2.*X1*H - X1**2)
               IF (DELEIG.GT.0.) DELEIG = 0.
C  The next statement voids the parabolic interpolation. It was decided
C  that the parabolic interpolation is often counter-productive, and it
C  cannot easily be incorporated into the constraint gradient computations.
               DELEIG = 0.
               EIGMIN = EIGMIN + DELEIG
            ENDIF
         ENDIF
      ENDIF
C BEG NOV 2003
C     IF (IFINAL.EQ.0.AND.IDESGN.EQ.0.AND.IDISCT.EQ.0) THEN
      IF (IFINAL.EQ.0.AND.IDESGN.EQ.0.AND.IDISCX) THEN
C END NOV 2003
         XLSAVE = XLG(IMIN)
         YLSAVE = YMAX
C  The ratios ASPSVX and ASPSVY are used later in the computations
C  for the perturbed design (IDESGN=1)
         ASPSVX = XLONG/XLSAVE
         ASPSVY = YLONG/YLSAVE
      ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (IFINAL.EQ.0.AND.IDESGN.EQ.0.AND.IFLAT.EQ.0
     1               .AND.IBACK.EQ.0.AND.IMIN.EQ.1
     1               .AND.XLG(1).LT.0.7*XLONG) THEN
C  This section is entered if PANDA2 finds that possibly critical longer
C  sublengths may yield more critical buckling load factors than those
C  determined so far.
         IF (NPRT.GE.2) WRITE(IFILE,'(/,A,1P,E12.4,A,E12.4,/,A,1P,E12.4,
     1                                /,A,/,A,1P,E12.4,A,1P,E12.4)')
     1 ' Axial length was reduced initially from',XLONG,' to',XLG(1),
     1 ' and the minimum buckling load is that corresponding to',XLG(1),
     1 ' Therefore, we must next explore the range of axial lengths',
     1 ' from',XLONG,' to',XLG(1)
         IBACK = 1
         ASPCTX = 1.0
         XMIN = XLG(1)
         EIGBCK = EIGTRY(1)
         XMIN2 = XLG(2)
         EIGBK2 = EIGTRY(2)
         GO TO 25
      ENDIF
C
      EIGMLT = 4.0
      IF (KOUNT.GE.3.AND.IFLAT.EQ.0.AND.IMIN.EQ.(KOUNT-1).AND.
     1 ((EIGTRY(IMIN-1)-EIGTRY(IMIN)).GT.
     1       EIGMLT*(EIGTRY(IMIN+1)-EIGTRY(IMIN)).OR.
     1  (EIGTRY(IMIN+1)-EIGTRY(IMIN)).GT.
     1       EIGMLT*(EIGTRY(IMIN-1)-EIGTRY(IMIN)))) THEN
         IF (NPRT.GE.2) WRITE(IFILE,'(A,/,A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL before t.s.d. and',
     1' after parabolic interpolation but before final ALTSOL= ',EIGMIN,
     1'(PERFECT)'
         IF ((EIGTRY(IMIN-1)-EIGTRY(IMIN)).GT.
     1       EIGMLT*(EIGTRY(IMIN+1)-EIGTRY(IMIN))) THEN
            ICOND = 1
            XMAX = 0.5*(XLG(IMIN) + XLG(IMIN+1))
         ENDIF
         IF ((EIGTRY(IMIN+1)-EIGTRY(IMIN)).GT.
     1       EIGMLT*(EIGTRY(IMIN-1)-EIGTRY(IMIN))) THEN
            ICOND = 2
            XMAX = 0.5*(XLG(IMIN) + XLG(IMIN-1))
         ENDIF
         IF (NPRT.GE.2) WRITE(IFILE,'(A,/,A,1P,E12.4)')
     1' It is judged necessary to use ALTSOL one more time, for the',
     1' axial length, XMAX = ',XMAX
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
         DO 362 IODEVN = IODLOW,IODHI
          NDEL = 1
          IF (IODEVN.EQ.2) NDEL = -1
          IF (ISPLIT.EQ.0) THEN
           NDEL = 0
           MNAMAX = MAMAX*NAMAX
           MNBMAX = MBMAX*NBMAX
           MNCMAX = MCMAX*NCMAX
           MNDMAX = MDMAX*NDMAX
           MNEMAX = MEMAX*NEMAX
          ELSE
           MNAMAX=((MAMAX+1)/2)*(NAMAX-NDEL)/2 +(MAMAX/2)*(NAMAX+NDEL)/2
           MNBMAX=((MBMAX+1)/2)*(NBMAX-NDEL)/2 +(MBMAX/2)*(NBMAX+NDEL)/2
           MNCMAX=((MCMAX+1)/2)*(NCMAX-NDEL)/2 +(MCMAX/2)*(NCMAX+NDEL)/2
           MNDMAX=((MDMAX+1)/2)*(NDMAX-NDEL)/2 +(MDMAX/2)*(NDMAX+NDEL)/2
           MNEMAX=((MEMAX+1)/2)*(NEMAX-NDEL)/2 +(MEMAX/2)*(NEMAX+NDEL)/2
          ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
          MNTOT  = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C BEG JAN 2005
          ISTORE = 2*MNTOT*MNTOT
          ISTOR2 = 2*MNTOT
C         ISTORE = 200000
C         ISTOR2 = 800
C END JAN 2005
          CALL MOVER(0.,0,A,1,ISTORE)
          CALL MOVER(0.,0,B,1,ISTORE)
          CALL MOVER(0.,0,EVECT,1,ISTORE)
          CALL MOVER(0.,0,EIGALT,1,ISTOR2)
          CALL MOVER(0.,0,WORKSP,1,ISTOR2)
C
C BEG DEC 2003
          IF (NPRT.GE.3) WRITE(IFILE,'(A)')' Enter Sub. TRIGU'
C END DEC 2003
C  Compute stiffness matrix, A:
          CALL TRIGU(A,C,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,
     1      MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1      MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C
C  Add discrete stiffeners:
C BEG DEC 2003
          IF (IDISCT.EQ.1) THEN
C BEG DEC 2003
             IF (NPRT.GE.3) WRITE(IFILE,'(A)')' Enter Sub. TRIGST'
C END DEC 2003
            CALL TRIGST(A,B,EASTR,EIXSTR,EIYSTR,GJSTR,ECCSTR,
     1                    EARNG,EIXRNG,EIYRNG,GJRNG,ECCRNG,
     1        SPCSTR,SPCRNG,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,
     1        NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1        DNXSTR,DX0STR,ZDXSTR,DNXRNG,DX0RNG,ZDXRNG,LUPPR1,LUPPR2,
     1        MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,NUMSTR,NUMRNG,
     1        ISPLIT)
          ENDIF
C END DEC 2003
C
C  Add contribution of load set B to the stiffness matrix, A:
          IF (FNNRM0.GT.0.001*FNNORM) THEN
C BEG DEC 2003
C23456789012345678901234567890123456789012345678901234567890123456789012
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGW or TRIGWM, Load Set B'
C END DEC 2003
            IF (ISANDQ.EQ.0.OR.ISANDQ.EQ.1)
     1        CALL TRIGW(A,FNX0,FNY0,FNXY0,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C
            IF (ISANDQ.EQ.2)
     1        CALL TRIGWM(A,FNX0,FNY0,FNXY0,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
          ENDIF
C
C  Compute load-geometric matrix, B:
C BEG DEC 2003
          IF (ISANDQ.EQ.0.OR.ISANDQ.EQ.1) THEN
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGW, Load Set A'
            CALL TRIGW(B,FNX,FNY,FNXY,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
          ENDIF
C
          IF (ISANDQ.EQ.2) THEN
            IF (NPRT.GE.3)
     1       WRITE(IFILE,'(A)')' Enter Sub. TRIGWM, Load Set A'
            CALL TRIGWM(B,FNX,FNY,FNXY,MNTOT,
     1         MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,
     1         MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1         MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
          ENDIF
C END DEC 2003
C
C  Find eigenvalues and eigenvectors:
          CALL GSEIG (MNTOT, A, B, EIGALT, EVECT, WORKSP, IPRINT)
C
          EIGVAL = 10.E+16
          DO 340 I = 1,MNTOT
          EIGTST = -EIGALT(I)
          IF (EIGTST.GT.0.0) EIGVAL = MIN(EIGVAL,EIGTST)
  340     CONTINUE
          IF (IODEVN.EQ.1) EIGODD = EIGVAL
          IF (IODEVN.EQ.2) EIGEVN = EIGVAL
  362    CONTINUE
         EIGVAL = MIN(EIGODD,EIGEVN)
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (NPRT.GE.0) WRITE(IFILE,'(A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL before t.s.d.=',EIGVAL,
     1'(PERFECT)'
C  The next section is for parabolic interpolation (now voided)
         IF (ICOND.EQ.1) THEN
            IF (EIGVAL.LE.EIGTRY(IMIN)) THEN
               X1 = XMAX - XLG(IMIN)
               Y1 = EIGTRY(IMIN) - EIGVAL
               X3 = XMAX - XLG(IMIN+1)
               Y3 = EIGTRY(IMIN+1) - EIGVAL
            ELSE
               X1 = XLG(IMIN) - XLG(IMIN-1)
               Y1 = EIGTRY(IMIN-1) - EIGTRY(IMIN)
               X3 = XLG(IMIN) - XMAX
               Y3 = EIGVAL - EIGTRY(IMIN)
               EIGVAL = EIGTRY(IMIN)
            ENDIF
         ELSE
            IF (EIGVAL.LE.EIGTRY(IMIN)) THEN
               X1 = XMAX - XLG(IMIN-1)
               Y1 = EIGTRY(IMIN-1) - EIGVAL
               X3 = XMAX - XLG(IMIN)
               Y3 = EIGTRY(IMIN) - EIGVAL
            ELSE
               X1 = XLG(IMIN) - XMAX
               Y1 = EIGVAL - EIGTRY(IMIN)
               X3 = XLG(IMIN) - XLG(IMIN+1)
               Y3 = EIGTRY(IMIN+1) - EIGTRY(IMIN)
               EIGVAL = EIGTRY(IMIN)
            ENDIF
         ENDIF
         H  = 0.5*(Y1*X3**2 - Y3*X1**2)/(X3*Y1 - X1*Y3)
         DELEIG = Y1*H**2/(2.*X1*H - X1**2)
         IF (DELEIG.GT.0.) DELEIG = 0.
C  The next statement voids the parabolic interpolation. It was decided
C  that the parabolic interpolation is often counter-productive, and it
C  cannot easily be incorporated into the constraint gradient computations.
         DELEIG = 0.
         EIGMN2 = EIGVAL + DELEIG
C23456789012345678901234567890123456789012345678901234567890123456789012
C        IF (NPRT.GE.2) WRITE(IFILE,'(A,/,3I3,1P,3E12.4,A,1P,E12.4)')
C    1 ' IFLAT,IMIN,KOUNT,EIGTRY(IMIN-1),EIGTRY(IMIN),EIGTRY(IMIN+1)=',
C    1   IFLAT,IMIN,KOUNT,EIGTRY(IMIN-1),EIGTRY(IMIN),EIGTRY(IMIN+1),
C    1 '; EIGVAL=',EIGVAL
C        IF (NPRT.GE.2) WRITE(IFILE,'(A,/,I2,1P,6E12.4)')
C    1 ' ICOND,X1,Y1,X3,Y3,H,DELEIG=',ICOND,X1,Y1,X3,Y3,H,DELEIG
         IF (NPRT.GE.2) WRITE(IFILE,'(A,/,A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL before t.s.d. and',
     1' after parabolic interpolation and after final ALTSOL=  ',EIGMN2,
     1'(PERFECT)'
         EIGMIN = MIN(EIGMN1,EIGMN2)
         IF (EIGMN2.LT.EIGMN1) THEN
            XLSAVE = XMAX
            YLSAVE = YMAX
            ASPSVX = XLONG/XLSAVE
            ASPSVY = YLONG/YLSAVE
         ENDIF
      ENDIF
C BEG NOV 2003
C     IF (IFINAL.EQ.0.AND.IDESGN.EQ.0.AND.IDISCT.EQ.0) THEN
      IF (IFINAL.EQ.0.AND.IDESGN.EQ.0.AND.IDISCX) THEN
C END NOV 2003
C  Now we have the critical sublength from the theory in which IIMAX = 5,
C  that is, 5 terms were used in the trig. series expansions for u,v,w.
C  Next, reset IIMAX to 7 (if u and v are needed), and do the alternative
C  solution one more time, this time only for the critical sublengths,
C  XLSAVE and YLSAVE:
         IBACK = 0
         IFINAL = 1
         IF (KOUNT.GT.1.OR.(IUV.EQ.1.AND.ISPLIT.EQ.1)) THEN
           ASPCTX = XLONG/XLSAVE
           ASPCTY = YLONG/YLSAVE
           ASPSVX = ASPCTX
           ASPSVY = ASPCTY
           IF (IUV.EQ.1.AND.ISPLIT.EQ.1) IIMAX = 7
           II = IIMAX
           MCMAX = II
           NCMAX = II
           IF (IUV.EQ.1) THEN
              MAMAX = II
              NAMAX = II
              MBMAX = II
              NBMAX = II
              MDMAX = II
              NDMAX = II
              MEMAX = II
              NEMAX = II
           ENDIF
           GO TO 25
         ENDIF
      ENDIF
C
      IF (IDESGN.EQ.0.AND.IDISCT.EQ.0) ISIGNL = 0
C BEG AUG 2003
C     IF (IDESGN.EQ.0.AND.IDISCT.EQ.0.AND.MWCOMP.GT.3.AND.IFLAT.EQ.0
      IF (                IDISCT.EQ.0.AND.MWCOMP.GT.3.AND.IFLAT.EQ.0
     1               .AND.XLONG/FLOAT(MWCOMP).LT.0.9*XLSAVE) THEN
         IF (EIGCMP.LT.0.95*EIGMIN) THEN
C END AUG 2003
C  Use the "high-m" buckling mode and load factor from the original
C  PANDA-type analysis, rather than that from the alternative solution, if the
C  "high-m" buckling load factor, EIGMNC, is less than the lowest buckling
C  load factor just determined from the alternative solution.
C BEG AUG 2003
           IF (IDESGN.EQ.0) ISIGNL = 1
C END AUG 2003
           IF (NPRT.GE.2)
     1     WRITE(IFILE,'(/,A,/,A,/,A,/,A,/,A,/,A,1P,E12.4,/A,1P,E12.4)')
     1' *** NOTE **** NOTE **** NOTE **** NOTE **** NOTE **** NOTE ***',
     1' The "high-m" original PANDA-type load factor is lower than the',
     1' load factor from the alternative solution. Since the "high-m"',
     1' factor is deemed accurate enough to use for preliminary design',
     1' it will be used instead of the "alternative soln" load factor:',
     1' "High-m" load factor from original PANDA-type theory,  EIGHIM=',
     1  EIGCMP,
     1' Load factor from the double-trig alternative solution, EIGALT=',
     1  0.95*EIGMIN
           IF (NPRT.GE.2) WRITE(IFILE,'(A,/,A,/,A,/,A)')
     1' NOTE:  In the list of margins, the "high-m" load factor will',
     1' be called "(0.95*altsol)" even though in this particular case',
     1' it is not the factor derived from the alternative solution.',
     1' **** END NOTE **** END NOTE **** END NOTE **** END NOTE ****'
C BEG AUG 2003
           EIGMIN = EIGCMP/0.95
C END AUG 2003
         ENDIF
      ENDIF
C
      EIGVAL = EIGMIN
 1001 CONTINUE
C23456789012345678901234567890123456789012345678901234567890123456789012
C BEG OCT 2001
      GINPUT(1) = G1323(1)
      GINPUT(2) = G1323(2)
      TINPUT(1) = TX
      TINPUT(2) = TY
      IF (ISTIF2.NE.0.AND.ILCGLB.EQ.2) THEN
         IF (IDESGN.EQ.0) THEN
            ISHRGN = 0
            WDIFF1 = ABS(WMAXM(1)-WMAX)/ABS(WMAX)
            WDIFF2 = ABS(WMAXM(2)-WMAX)/ABS(WMAX)
            IF (WDIFF1.GT.0.5.AND.WDIFF2.GT.0.5) ISHRGN = 1
         ENDIF
         IF (ISHRGN.EQ.1) THEN
            GINPUT(1) = GTX5(1)
            GINPUT(2) = GTX5(2)
            TINPUT(2) = TY5
         ENDIF
      ENDIF
      IF (NPRT.GE.2) WRITE(IFILE,'(A,1P,4E12.4)')
     1' Teff(1),Teff(2),G13,G23=',TX,TINPUT(2),GINPUT(1),GINPUT(2)
C END OCT 2001
      IF (NPRT.GE.2) WRITE(IFILE,'(A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL before t.s.d.=',EIGVAL,
     1'(PERFECT)'
C
C   The alternative solution does not DIRECTLY include t.s.d. (transverse
C   shear deformation) effects. t.s.d. is included by "knockdown" according
C   to a theory analogous to Timoshenko beam theory. The "knocked down"
C   eigenvalue, EIGVAL, is computed in SHRRED. This is the same strategy
C   used in the rest of PANDA2.
C
C BEG OCT 2001
      CALL SHRRED(IREDUC,NX,NY,NXY,TX,TINPUT(2),GINPUT,EIGVAL,0,1,0,
     1            0.,0.,1,NX0,NY0,24)
C END OCT 2001
C
      IF (NPRT.GE.0) WRITE(IFILE,'(A,1P,E12.4,A)')
     1' Critical bucklng load factor from ALTSOL after  t.s.d.=',EIGVAL,
     1'(PERFECT)'
C
      RFACT = 0.95
C BEG JAN 2005
      IF (ILCGLB.EQ.1.AND.KLAYER.NE.0) RFACT = 0.9
C END JAN 2005
C                    (The alternative solution may be reduced by 0.95 in
C                     order to compensate for truncation of the trig.
C                     series expansion and the fact that the Ritz method
C                     converges from above.)
C
C                     The "knockdown" factor, RFACT = 0.85, is used in the
C                     case of alternative solution models with discrete
C                     stiffeners (IDISCT=1) because these models have modes
C                     that are often "wavier" than those for an unstiffened
C                     panel or the unstiffened portion of a panel between
C                     adjacent stiffeners.
C
C BEG NOV 2003
C     IF (IDISCT.EQ.1) RFACT = 0.85
      IF (IDISCZ) RFACT = 0.85
C END NOV 2003
C BEG SEP 2004
C  NOTE: For inter-ring buckling, RFACT = 1.0 is used. This is because the
C        general instability alternative 3 x 3 bay "patch" model will usually
C        also capture inter-ring buckling if inter-ring buckling is critical.
C BEG OCT 2004
      IF (ILCGLB.EQ.3.OR.ILCGLB.EQ.6) RFACT = 1.0
C END OCT 2004
C END SEP 2004
C BEG JAN 2005
      IF (ILCGLB.EQ.6.AND.NCHNG6.EQ.1) RFACT = 0.85
      IF (ILCGLB.EQ.3.AND.NCHNG3.EQ.1) RFACT = 0.85
      IF (KLAYER.NE.0) THEN
         IF (ILCGLB.EQ.6.AND.NCHNG6.EQ.0) RFACT = 0.90
         IF (ILCGLB.EQ.3.AND.NCHNG3.EQ.0) RFACT = 0.90
      ENDIF
C
C END JAN 2005
C BEG OCT 2006
C BEG FEB 2009
C     IF (ICONSV.EQ.-1) RFACT = 0.95
      IF (ICONSV.LT.1) RFACT = 0.95
C END FEB 2009
C END OCT 2006
      EIGVAL = RFACT*EIGVAL
      IF (NPRT.GE.0)
     1 WRITE(IFILE,'(A,/,A,1P,E12.4,A,/,A,A,/,A,1P,E12.4,A,A,/,
     1                                          A,A,/,A,1P,E12.4,A,A)')
     1' Critical buckling load factor from ALTSOL after  t.s.d.',
     1' and after reduction by a factor of',RFACT,' to compensate for',
     1' truncation of double trigonometric series expansion',
     1' (perfect shell)=',
     1'                                             ',EIGVAL,WORD1,
     1'(PERFECT)',
     1' Critical buckling load factor from orig. PANDA theory',
     1' (perfect shell)=',
     1'                                             ',EIGOLD,WORD2,
     1'(PERFECT)'
C BEG JAN 2005
C BEG JUN 2006
      IF (ILABEL.EQ.9260.AND.ILCGLB.EQ.3.AND.WORD1.EQ.WORD2
     1             .AND.EIGOLD.LT.EIGVAL.AND.EIGVAL.LT.10.E+16) THEN
C END JUN 2006
         EIGVAL = EIGOLD
         IF (NPRT.GE.0) WRITE(IFILE,'(/,A,/,A,/,A,/,A,1P,E12.4)')
     1 ' PANDA-theory buckling load factor is less than that',
     1 ' computed from the double-trig-expansion theory. Therefore,',
     1 ' the double-trig-expansion value is being replaced by the',
     1 ' value from PANDA-theory. Now used: EIGVAL =',EIGVAL
      ENDIF
C END JAN 2005
      IF (IQUICK.EQ.0.AND.WORD1.EQ.'(CURVED)'.AND.WORD2.EQ.' (FLAT) ')
     1 WRITE(IFILE,'(/,A,/,A,/,A,/,A,1P,E12.4,A,/,A,/,A,/,A,/,A,/)')
     1 ' **** NOTE **** NOTE **** NOTE **** NOTE **** NOTE ****',
     1 ' Because IQUICK = 0 (PANDA2 uses discretized module model) the',
     1 ' alternate (double trig. series) solution is obtained for the',
     1 ' curved panel with radius of curvature, R=',RADIUS,', whereas',
     1 ' the orig. PANDA theory solution (Eq.(57),p553,Comp.Struct.87)',
     1 ' is obtained for a flat segment between stringers because the',
     1 ' BOSOR4-type (discretized) module model is for a flat panel.',
     1 ' *** END NOTE *** END NOTE *** END NOTE *** END NOTE ***'
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C 999 CONTINUE
      IF (NPRT.GE.2) WRITE(IFILE,'(A,A,1P,E9.3)')
     1' Ratio of ALTSOL eigenvalue to PANDA-type eigenvalue,',
     1' EIGALT/EIGPAN = ', EIGVAL/EIGOLD
C BEG DEC 1998
      IF (NPRT.GE.2.AND.IQUICK.EQ.0.AND.ILABEL.EQ.9140)
     1 WRITE(IFILE,'(/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/,A,/)')
     1' ******** NOTE ******* NOTE ******* NOTE ******* NOTE *********',
     1' This ratio is used to modify the local buckling margin',
     1' generated from the discretized skin-stringer module model. The',
     1' wording, "Local buckling from discrete model", in the phrase',
     1' associated with this margin contains no phrase, such as',
     1' "0.95*altsol", which gives the user a clue that the alternate',
     1' solution has actually been used. However, it has, through the',
     1' ratio just listed above.',
     1' ***** END NOTE **** END NOTE ***** END NOTE **** END NOTE *****'
C END DEC 1998
C BEG MAR 2005
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (IDESGN.EQ.0.AND.NPRT.GE.0) WRITE(IFILE,'(A,/,A,I2,/,A)')
     1' ******* LEAVING SUBROUTINE ALTSOL: UNPERTURBED DESIGN ********',
     1' MODEL INDEX, ILCGLB = 1 or 2 or 3 or 4 or 5 or 6 =',ILCGLB,
     1' ******* STILL IN SUBROUTINE BUCPAN:UNPERTURBED DESIGN ********'
      IF (IDESGN.EQ.1.AND.NPRT.GE.0) WRITE(IFILE,'(A,/,A,I2,/,A)')
     1' ******* LEAVING SUBROUTINE ALTSOL: PERTURBED DESIGN ********',
     1' MODEL INDEX, ILCGLB = 1 or 2 or 3 or 4 or 5 or 6 =',ILCGLB,
     1' ******* STILL IN SUBROUTINE BUCPAN:PERTURBED DESIGN ********'
C END MAR 2005
      RETURN
      END
C
C
C
C=DECK      TRIGU
      SUBROUTINE TRIGU(A,C,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,
     1        MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,FISAND,IFILE,
     1        MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C
C  PURPOSE IS TO FILL THE STIFFNESS MATRIX FOR LINEAR BUCKLING OF PANEL
C  SKIN BETWEEN STIFFENERS.
C
C  The theory is based on the following:
C   1. The assumed displacement field is:
C   axial displacement, u = sum-over-m{sum-over-n{A(m,n)cos(mx)sin(ny)
C                                                +D(m,n)sin(mx)sin(ny)}}
C    hoop displacement, v = sum-over-m{sum-over-n{B(m,n)sin(mx)cos(ny)
C                                                +E(m,n)sin(mx)sin(ny)}}
C  normal displacement, w = sum-over-m{sum-over-n{C(m,n)sin(mx)sin(ny)}}
C      
C   2. The kinematic (strain-displacement) relations are:
C       epsx    = u,x
C       epsy    = v,y + w/R
C       epsxy   = u,y + v,x
C       kappax  = -w,xx
C       kappay  = -wyy  + v,y/R
C       kappaxy = 2.(-w,xy + v,x/R)
C
C   3. The strain energy is given by:
C
C       U = 0.5*int-over-x{int-over-y{eps(transpose)*[C]*eps}dy}dx
C
C      in which eps = [epsx, epsy, epsxy, kappax, kappay, kappaxy]
C      and [C] is the usual 6x6 matrix of stiffness coefficients that
C      represents the constitutive law as integrated through the
C      wall thickness.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION COEFMN(2,6),COEFIJ(2,6),MNPOS(2,6),IJPOS(2,6),ITERMS(6)
      DIMENSION C(6,6),ITRIG(6)
      DIMENSION ITRIGD(6,2),COFDMN(6),COFEMN(6),MNPOSD(6),MNPOSE(6)
      DIMENSION ITRIGE(6,2),COFDIJ(6),COFEIJ(6),IJPOSD(6),IJPOSE(6)
      DIMENSION A(MNTOT,MNTOT)
C
C     MAMAX = number of trig terms in the x-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     MDMAX = number of trig terms in the x-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     MBMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     MEMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     MCMAX = number of trig terms in the x-coord. expansion for displ. w
C     NAMAX = number of trig terms in the y-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     NDMAX = number of trig terms in the y-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     NBMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     NEMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     NCMAX = number of trig terms in the y-coord. expansion for displ. w
C
C
      PI = 3.1415927
C     MNTOT  = rank of the stiffness matrix 
C            = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C
C     ITERMS(i) = number of terms in the ith kinematic expression
      ITERMS(1) = 1
      ITERMS(2) = 2
      ITERMS(3) = 2
      ITERMS(4) = 1
      ITERMS(5) = 2
      ITERMS(6) = 2
C
C     ITRIG(i) = 1 means sine, 2 means cosine
C
      ITRIG(1) = 1
      ITRIG(2) = 1
      ITRIG(3) = 2
      ITRIG(4) = 1
      ITRIG(5) = 1
      ITRIG(6) = 2
C
      IF (MNDMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGD,1,12)
C        ITRIGD(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGD(1,1) = 2
         ITRIGD(1,2) = 1
         ITRIGD(3,1) = 1
         ITRIGD(3,2) = 2
      ENDIF
      IF (MNEMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGE,1,12)
C        ITRIGE(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGE(2,1) = 1
         ITRIGE(2,2) = 2
         ITRIGE(3,1) = 2
         ITRIGE(3,2) = 1
         ITRIGE(5,1) = 1
         ITRIGE(5,2) = 2
         ITRIGE(6,1) = 2
         ITRIGE(6,2) = 1
      ENDIF
C
C     COEFMN(i,j), i=1,2; j=1,6: coefficients of the undetermined
C                  coefficients, A(m,n), B(m,n), C(m,n) in the kinematic
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to strain/curv. component.
C     MNPOS(i,j),  i=1,2; j=1,6: row or column number in stiffness matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to strain/curv. component.
C
      DO 2000 M = 1,MCMAX
        FM = FLOAT(M)*PI/XMAX
        GM = M
        NSTART = 1
        NINCR  = 1
        IF (ISPLIT.EQ.1) THEN
           NINCR = 2
           IMOD = MOD(M,2)
           IF (NDEL.EQ.1) THEN
            NSTART = 2
            IF (IMOD.EQ.0) NSTART = 1
           ELSE
            NSTART = 1
            IF (IMOD.EQ.0) NSTART = 2
           ENDIF
        ENDIF
      DO 1900 N = NSTART,NCMAX,NINCR
         FN = FLOAT(N)*PI/YMAX
         GN = N
         CALL MOVER(0.,0,COEFMN,1,24)
         CALL MOVER(0,0,MNPOS,1,12)
         IF (M.LE.MAMAX.AND.N.LE.NAMAX) THEN
            COEFMN(1,1) = -FM
            COEFMN(1,3) = FN
            IF (ISPLIT.EQ.1) MNPOS(1,1) = MNCMAX +(M/2)*(NAMAX-NDEL)/2 
     1                             +((M-1)/2)*(NAMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0) MNPOS(1,1) = MNCMAX + (M-1)*NAMAX + N
            MNPOS(1,3)  = MNPOS(1,1)
         ENDIF
         IF (N.LE.NBMAX.AND.M.LE.MBMAX) THEN
            COEFMN(1,2) = -FN
            COEFMN(2,3) = FM
            COEFMN(2,5) = -FISAND*FN*CUR
            COEFMN(2,6) =  2.*FISAND*FM*CUR
            IF (ISPLIT.EQ.1)
     1             MNPOS(1,2)  = MNCMAX + MNAMAX +(M/2)*(NBMAX-NDEL)/2 
     1                             +((M-1)/2)*(NBMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0) 
     1             MNPOS(1,2) = MNCMAX + MNAMAX + (M-1)*NBMAX + N
            MNPOS(2,3)  = MNPOS(1,2)
            MNPOS(2,5)  = MNPOS(1,2)
            MNPOS(2,6)  = MNPOS(1,2)
         ENDIF
         COEFMN(2,2) = CUR
         COEFMN(1,4) = FM**2
         COEFMN(1,5) = FN**2
         COEFMN(1,6) = -2.*FM*FN
         IF (ISPLIT.EQ.1) MNPOS(2,2)  = (M/2)*(NCMAX-NDEL)/2 
     1                             +((M-1)/2)*(NCMAX+NDEL)/2 + (N+1)/2
         IF (ISPLIT.EQ.0) MNPOS(2,2) = (M-1)*NCMAX + N
         MNPOS(1,4)  = MNPOS(2,2)
         MNPOS(1,5)  = MNPOS(2,2)
         MNPOS(1,6)  = MNPOS(2,2)
C        WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFMN(1,L),L=1,6=',
C    1                                  (COEFMN(1,L),L=1,6)
C        WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFMN(2,L),L=1,6=',
C    1                                  (COEFMN(2,L),L=1,6)
C
C  Add the "D" and "E" terms, if any:
C     COFDMN(i), i=1,6 = coefficients of the undetermined coefficients
C     D(m,n) of the u-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..6).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNDMAX.GT.0) THEN
            CALL MOVER(0.,0,COFDMN,1,12)
            CALL MOVER(0,0,MNPOSD,1,6)
            IF (M.LE.MDMAX.AND.N.LE.NDMAX) THEN
               COFDMN(1) = FM
               COFDMN(3) = FN
               IF (ISPLIT.EQ.1) MNPOSD(1) = MNCMAX + MNAMAX + MNBMAX
     1                           +(M/2)*(NDMAX-NDEL)/2 
     1                           +((M-1)/2)*(NDMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0) MNPOSD(1) = MNCMAX + MNAMAX + MNBMAX
     1                           + (M-1)*NDMAX + N
               MNPOSD(3) = MNPOSD(1)
            ENDIF
         ENDIF
C     COFEMN(i), i=1,6 = coefficients of the undetermined coefficients
C     E(m,n) of the v-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..6).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNEMAX.GT.0) THEN
            CALL MOVER(0.,0,COFEMN,1,12)
            CALL MOVER(0,0,MNPOSE,1,6)
            IF (M.LE.MEMAX.AND.N.LE.NEMAX) THEN
               COFEMN(2) = FN
               COFEMN(3) = FM
               COFEMN(5) = FN*CUR
               COFEMN(6) = 2.*FM*CUR
               IF (ISPLIT.EQ.1) 
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(M/2)*(NEMAX-NDEL)/2 
     1                           +((M-1)/2)*(NEMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0) 
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           + (M-1)*NEMAX + N
               MNPOSE(3) = MNPOSE(2)
               MNPOSE(5) = MNPOSE(2)
               MNPOSE(6) = MNPOSE(2)
            ENDIF
         ENDIF
C
C     COEFIJ(i,j), i=1,2; j=1,6: coefficients of the undetermined
C                  coefficients, A(i,j), B(i,j), C(i,j) in the kinematic
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to strain/curv. component.
C     IJPOS(i,j),  i=1,2; j=1,6: column or row number in stiffness matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to strain/curv. component.
C
         DO 1800 I = 1,MCMAX
           FI = FLOAT(I)*PI/XMAX
           GI = I
           JSTART = 1
           JINCR  = 1
           IF (ISPLIT.EQ.1) THEN
              JINCR = 2
              IMOD = MOD(I,2)
              IF (NDEL.EQ.1) THEN
               JSTART = 2
               IF (IMOD.EQ.0) JSTART = 1
              ELSE
               JSTART = 1
               IF (IMOD.EQ.0) JSTART = 2
              ENDIF
           ENDIF
         DO 1700 J = JSTART,NCMAX,JINCR
            FJ = FLOAT(J)*PI/YMAX
            GJ = J
            CALL MOVER(0.,0,COEFIJ,1,24)
            CALL MOVER(0,0,IJPOS,1,12)
            IF (I.LE.MAMAX.AND.J.LE.NAMAX) THEN
               COEFIJ(1,1) = -FI
               COEFIJ(1,3) = FJ
               IF (ISPLIT.EQ.1) 
     1                      IJPOS(1,1)  = MNCMAX +(I/2)*(NAMAX-NDEL)/2 
     1                             +((I-1)/2)*(NAMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0) IJPOS(1,1) = MNCMAX + (I-1)*NAMAX + J
               IJPOS(1,3)  = IJPOS(1,1)
            ENDIF
            IF (J.LE.NBMAX.AND.I.LE.MBMAX) THEN
               COEFIJ(1,2) = -FJ
               COEFIJ(2,3) = FI
               COEFIJ(2,5) = -FISAND*FJ*CUR
               COEFIJ(2,6) =  2.*FISAND*FI*CUR
               IF (ISPLIT.EQ.1) 
     1              IJPOS(1,2) = MNCMAX + MNAMAX +(I/2)*(NBMAX-NDEL)/2 
     1                             +((I-1)/2)*(NBMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0)
     1              IJPOS(1,2) = MNCMAX + MNAMAX + (I-1)*NBMAX + J
               IJPOS(2,3)  = IJPOS(1,2)
               IJPOS(2,5)  = IJPOS(1,2)
               IJPOS(2,6)  = IJPOS(1,2)
            ENDIF
            COEFIJ(2,2) = CUR
            COEFIJ(1,4) = FI**2
            COEFIJ(1,5) = FJ**2
            COEFIJ(1,6) = -2.*FI*FJ
            IF (ISPLIT.EQ.1) IJPOS(2,2) = (I/2)*(NCMAX-NDEL)/2 
     1                      +((I-1)/2)*(NCMAX+NDEL)/2 + (J+1)/2
            IF (ISPLIT.EQ.0) IJPOS(2,2) = (I-1)*NCMAX + J
            IJPOS(1,4)  = IJPOS(2,2)
            IJPOS(1,5)  = IJPOS(2,2)
            IJPOS(1,6)  = IJPOS(2,2)
C           WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFIJ(1,L),L=1,6=',
C    1                                     (COEFIJ(1,L),L=1,6)
C           WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFIJ(2,L),L=1,6=',
C    1                                     (COEFIJ(2,L),L=1,6)
C
C  Add the "D" and "E" terms, if any:
C     COFDIJ(k), k=1,6 = coefficients of the undetermined coefficients
C     D(i,j) of the u-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..6).
C     IJPOSD(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
            IF (MNDMAX.GT.0) THEN
               CALL MOVER(0.,0,COFDIJ,1,12)
               CALL MOVER(0,0,IJPOSD,1,6)
               IF (I.LE.MDMAX.AND.J.LE.NDMAX) THEN
                  COFDIJ(1) = FI
                  COFDIJ(3) = FJ
                  IF (ISPLIT.EQ.1) IJPOSD(1) = MNCMAX + MNAMAX + MNBMAX
     1                                 +(I/2)*(NDMAX-NDEL)/2 
     1                              +((I-1)/2)*(NDMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0) IJPOSD(1) = MNCMAX + MNAMAX + MNBMAX
     1                                         + (I-1)*NDMAX + J
                  IJPOSD(3) = IJPOSD(1)
               ENDIF
            ENDIF
C     COFEIJ(k), k=1,6 = coefficients of the undetermined coefficients
C     E(i,j) of the v-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..6).
C     IJPOSE(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
            IF (MNEMAX.GT.0) THEN
               CALL MOVER(0.,0,COFEIJ,1,12)
               CALL MOVER(0,0,IJPOSE,1,6)
               IF (I.LE.MEMAX.AND.J.LE.NEMAX) THEN
                  COFEIJ(2) = FJ
                  COFEIJ(3) = FI
                  COFEIJ(5) = FJ*CUR
                  COFEIJ(6) = 2.*FI*CUR
                  IF (ISPLIT.EQ.1)
     1                   IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                             +(I/2)*(NEMAX-NDEL)/2 
     1                             +((I-1)/2)*(NEMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0)
     1                   IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                                         + (I-1)*NEMAX + J
                  IJPOSE(3) = IJPOSE(2)
                  IJPOSE(5) = IJPOSE(2)
                  IJPOSE(6) = IJPOSE(2)
               ENDIF
            ENDIF
C
C  Process the IEPS terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients A, B, C:
C
            DO 300 IEPS = 1,6
            ITIEND = ITERMS(IEPS)
            DO 250 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IEPS).EQ.0.0) GO TO 250
               MN = MNPOS(ITERMI,IEPS)
            DO 200 JEPS = 1,6
            ITJEND = ITERMS(JEPS)
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 200
            DO 150 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JEPS).EQ.0.0) GO TO 150
               IJ = IJPOS(ITERMJ,JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COEFMN(ITERMI,IEPS)*COEFIJ(ITERMJ,JEPS)
C     Find integral:
               XINTEG = 0.
               YINTEG = 0.
               IF (ITRIG(IEPS).EQ.ITRIG(JEPS)) THEN
                  IF (M.EQ.I.AND.N.EQ.J) THEN
                     XINTEG = 0.5*XMAX
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 150
                  ENDIF
                  GO TO 10
               ELSE
                  IMOD1 = MOD(M-I,2)
                  IMOD2 = MOD(N-J,2)
C                 WRITE(IFILE,'(A,8I3)') 
C    1             ' M,I,N,J,IMOD1,IMOD2,ITRIG(IEPS),ITRIG(JEPS)=',
C    1               M,I,N,J,IMOD1,IMOD2,ITRIG(IEPS),ITRIG(JEPS)
                  IF (IMOD1.EQ.0.OR.IMOD2.EQ.0) GO TO 150
                  IF (ITRIG(IEPS).EQ.1.AND.ITRIG(JEPS).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
   10          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  150       CONTINUE
  200       CONTINUE
  250       CONTINUE
  300       CONTINUE
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 400 IEPS = 1,6
            ITIEND = ITERMS(IEPS)
            DO 350 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IEPS).EQ.0.0) GO TO 350
               MN = MNPOS(ITERMI,IEPS)
            DO 325 JEPS = 1,6
               IF (C(IEPS,JEPS).EQ.0.0) GO TO 325
               IF (COFDIJ(JEPS).EQ.0.0) GO TO 325
               IJ = IJPOSD(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COEFMN(ITERMI,IEPS)*COFDIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IEPS).EQ.ITRIGD(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 310
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IEPS).EQ.1.AND.ITRIGD(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  310          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IEPS).EQ.ITRIGD(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 320
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IEPS).EQ.1.AND.ITRIGD(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  320          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  325       CONTINUE
  350       CONTINUE
  400       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 500 IEPS = 1,6
            ITIEND = ITERMS(IEPS)
            DO 450 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IEPS).EQ.0.0) GO TO 450
               MN = MNPOS(ITERMI,IEPS)
            DO 425 JEPS = 1,6
               IF (C(IEPS,JEPS).EQ.0.0) GO TO 425
               IF (COFEIJ(JEPS).EQ.0.0) GO TO 425
               IJ = IJPOSE(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COEFMN(ITERMI,IEPS)*COFEIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IEPS).EQ.ITRIGE(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 410
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IEPS).EQ.1.AND.ITRIGE(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  410          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IEPS).EQ.ITRIGE(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 420
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IEPS).EQ.1.AND.ITRIGE(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  420          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  425       CONTINUE
  450       CONTINUE
  500       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients D, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNDMAX.GT.0) THEN
            DO 600 IEPS = 1,6
               IF (COFDMN(IEPS).EQ.0.0) GO TO 600
               MN = MNPOSD(IEPS)
            DO 550 JEPS = 1,6
            ITJEND = ITERMS(JEPS)
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 550
            DO 525 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JEPS).EQ.0.0) GO TO 525
               IJ = IJPOS(ITERMJ,JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFDMN(IEPS)*COEFIJ(ITERMJ,JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IEPS,1).EQ.ITRIG(JEPS)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 510
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IEPS,1).EQ.1.AND.ITRIG(JEPS).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  510          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IEPS,2).EQ.ITRIG(JEPS)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 520
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IEPS,2).EQ.1.AND.ITRIG(JEPS).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  520          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  525       CONTINUE
  550       CONTINUE
  600       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients E, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNEMAX.GT.0) THEN
            DO 700 IEPS = 1,6
               IF (COFEMN(IEPS).EQ.0.0) GO TO 700
               MN = MNPOSE(IEPS)
            DO 650 JEPS = 1,6
            ITJEND = ITERMS(JEPS)
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 650
            DO 625 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JEPS).EQ.0.0) GO TO 625
               IJ = IJPOS(ITERMJ,JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFEMN(IEPS)*COEFIJ(ITERMJ,JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IEPS,1).EQ.ITRIG(JEPS)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 610
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IEPS,1).EQ.1.AND.ITRIG(JEPS).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  610          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IEPS,2).EQ.ITRIG(JEPS)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 620
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IEPS,2).EQ.1.AND.ITRIG(JEPS).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  620          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  625       CONTINUE
  650       CONTINUE
  700       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients D, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 800 IEPS = 1,6
               IF (COFDMN(IEPS).EQ.0.0) GO TO 800
               MN = MNPOSD(IEPS)
            DO 750 JEPS = 1,6
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 750
               IF (COFDIJ(JEPS).EQ.0.0) GO TO 750
               IJ = IJPOSD(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFDMN(IEPS)*COFDIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IEPS,1).EQ.ITRIGD(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 710
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IEPS,1).EQ.1.AND.ITRIGD(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  710          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IEPS,2).EQ.ITRIGD(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 720
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IEPS,2).EQ.1.AND.ITRIGD(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  720          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  750       CONTINUE
  800       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients D, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 900 IEPS = 1,6
               IF (COFDMN(IEPS).EQ.0.0) GO TO 900
               MN = MNPOSD(IEPS)
            DO 850 JEPS = 1,6
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 850
               IF (COFEIJ(JEPS).EQ.0.0) GO TO 850
               IJ = IJPOSE(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFDMN(IEPS)*COFEIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IEPS,1).EQ.ITRIGE(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 810
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IEPS,1).EQ.1.AND.ITRIGE(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  810          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IEPS,2).EQ.ITRIGE(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 820
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IEPS,2).EQ.1.AND.ITRIGE(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  820          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  850       CONTINUE
  900       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients E, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 1000 IEPS = 1,6
               IF (COFEMN(IEPS).EQ.0.0) GO TO 1000
               MN = MNPOSE(IEPS)
            DO 950 JEPS = 1,6
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 950
               IF (COFDIJ(JEPS).EQ.0.0) GO TO 950
               IJ = IJPOSD(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFEMN(IEPS)*COFDIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IEPS,1).EQ.ITRIGD(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 910
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IEPS,1).EQ.1.AND.ITRIGD(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  910          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IEPS,2).EQ.ITRIGD(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 920
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IEPS,2).EQ.1.AND.ITRIGD(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  920          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
  950       CONTINUE
 1000       CONTINUE
          ENDIF
C
C  Next, process the IEPS terms corresponding to the
C  undetermined coefficients E, and
C  Process the JEPS terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 1100 IEPS = 1,6
               IF (COFEMN(IEPS).EQ.0.0) GO TO 1100
               MN = MNPOSE(IEPS)
            DO 1050 JEPS = 1,6
            IF (C(IEPS,JEPS).EQ.0.0) GO TO 1050
               IF (COFEIJ(JEPS).EQ.0.0) GO TO 1050
               IJ = IJPOSE(JEPS)
               COEF = 
     1           C(IEPS,JEPS)*COFEMN(IEPS)*COFEIJ(JEPS)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IEPS,1).EQ.ITRIGE(JEPS,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1010
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IEPS,1).EQ.1.AND.ITRIGE(JEPS,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
 1010          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IEPS,2).EQ.ITRIGE(JEPS,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1020
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IEPS,2).EQ.1.AND.ITRIGE(JEPS,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
 1020          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               A(MN,IJ) = A(MN,IJ) + FINTEG*COEF
               A(IJ,MN) = A(IJ,MN) + FINTEG*COEF
 1050       CONTINUE
 1100       CONTINUE
          ENDIF
C
 1700    CONTINUE
 1800    CONTINUE
 1900 CONTINUE
 2000 CONTINUE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (MNTOT.LE.0) THEN
        WRITE(IFILE,60)
   60   FORMAT(/' STIFFNESS MATRIX, A:',/,
     1' A(I,1)   A(I,2)   A(I,3)   A(I,4)   A(I,5)   A(I,6)   A(I,7)  ',
     1' A(I,8)   A(I,9)   A(I,10)  A(I,11)  A(I,12)')
        DO 70 I = 1,MNTOT
         WRITE(IFILE,65) (A(I,J),J=1,MNTOT)
   65    FORMAT(1P12E9.2)
   70   CONTINUE
      ENDIF
C
      RETURN
      END       
C
C
C
C=DECK      TRIGST
      SUBROUTINE TRIGST(A,B,EASTR,EIXSTR,EIYSTR,GJSTR,ECCSTR,
     1                    EARNG,EIXRNG,EIYRNG,GJRNG,ECCRNG,
     1        SPCSTR,SPCRNG,MNTOT,MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,
     1        NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,XMAX,YMAX,CUR,IFILE,
     1        DNXSTR,DX0STR,ZDXSTR,DNXRNG,DX0RNG,ZDXRNG,LUPPR1,LUPPR2,
     1        MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,NUMSTR,NUMRNG,
     1        ISPLIT)
C
C  PURPOSE IS TO FILL THE STIFFNESS MATRIX FOR LINEAR BUCKLING OF PANEL
C  WITH DISCRETE STIFFENERS. THIS SUBROUTINE COMPUTES THE CONTRIBUTION
C  OF THE DISCRETE STIFFENERS (STRINGERS AND OR RINGS) TO THE STIFFNESS
C  MATRIX, A.
C
C  The theory is based on the following:
C   1. The assumed displacement field is:
C   axial displacement, u = sum-over-m{sum-over-n{A(m,n)cos(mx)sin(ny)
C                                                +D(m,n)sin(mx)sin(ny)}}
C    hoop displacement, v = sum-over-m{sum-over-n{B(m,n)sin(mx)cos(ny)
C                                                +E(m,n)sin(mx)sin(ny)}}
C  normal displacement, w = sum-over-m{sum-over-n{C(m,n)sin(mx)sin(ny)}}
C      
C   2. The strain energy is given by:
C
C       U = 0.5*int-over-x{int-over-y{eps(transpose)*[G]*eps}dy}dx
C
C      in which [G] is the matrix,
C
C                EA    0     0    0
C                 0   EIx    0    0
C                 0    0    EIy   0
C                 0    0     0   GJ
C
C      where EA is the axial stiffness of the stiffener, EIx is the
C      bending stiffness of the stiffener with use of the stiffener
C      axis of centroids as a reference (bending in a plane
C      normal to the plane of the panel skin), EIy is the bending
C      stiffness of the stiffener in a plane parallel to the plane of
C      the panel skin at the stiffener attachment, and GJ is the torsional
C      rigidity of the stiffener. The strain energy associated with 
C      non-zero polar moment of inertia, Ixy, of the stiffener cross
C      section is ignored. For STRINGER contribution only the integration
C      over axial length x is performed; for RING contribution only the
C      integration over circ. arc length y is performed.
C
C   3. The strain vector, eps, is given by
C      
C               e, kappa1, kappa2, twist
C
C      in which e is the axial strain, kappa1 is the change in curvature
C      in the plane normal to the panel skin at the attachment point of
C      the stiffener to the skin, kappa2 is the change in curvature in
C      the plane parallel  to the panel skin at the attachment point of
C      the stiffener to the skin, and twist is the twisting of the stiffener.
C
C      For stringers:
C
C               e  = u,x -w,xx*ecc(str)
C           kappa1 = -w,xx
C           kappa2 = v,xx -w,yxx*ecc(str)
C           twist  = wxy                       (shallow shell theory is used)
C
C      For rings:
C
C               e  = v,y + w/r -w,yy*ecc(rng)  (shallow shell theory is used)
C           kappa1 = -w,yy                     (shallow shell theory is used)
C           kappa2 = u,yy -w,xyy*ecc(rng)      (shallow shell theory is used)
C           twist  = wxy                       (shallow shell theory is used)
C
C      in which ecc(str) is the distance from the stringer shear
C      center to the reference surface of the panel skin, positive for
C      external stringers, and ecc(rng) is the distance from the ring
C      shear center to the reference surface of the panel skin, positive
C      for external rings. A term, -w,x/R, is neglected in the expression
C      for kappa2 for the rings. It is felt that in cases for which there
C      is a significant difference between the buckling load predicted from
C      a model in which the stiffeners are smeared vs that predicted from a
C      model in which the stiffeners are discrete, the critical buckling
C      pattern will span a shallow portion of the panel.
C
C      Shallow shell theory is used here because discrete stiffener theory
C      is needed only if the wavelength of the critical buckling pattern
C      is of the same order as the stiffener spacing. It is assumed that
C      the stiffener spacing is close enough so that the section of panel
C      bounded by adjacent stiffeners is a shallow shell.
C
C   4. Work done by prebuckling loads in the stiffeners during buckling
C      modal displacements: 
C
C      0.5*sum(k=1=web,k=2=outstanding flange)(stiffener segment FORCE)x
C               {integral-over-stiffener-length-L(rotx**2 + roty**2)dL
C
C     in which, for stringers:
C
C          rotx = w,x
C          roty = v,x - wyx*z(k)
C
C     and for rings:
C
C          rotx = w,y
C          roty = u,y - wxy*z(k)
C
C     where z(k) is the distance from the panel skin reference surface to
C     the kth stringer segment or kth ring segment.
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION A(MNTOT,MNTOT),B(MNTOT,MNTOT)
      DIMENSION DNXSTR(2),DX0STR(2),ZDXSTR(2),LUPPR1(2),LUPPR2(2)
      DIMENSION DNXRNG(2),DX0RNG(2),ZDXRNG(2)
      DIMENSION CMSTAR(100),CNSTAR(100),CISTAR(100),CJSTAR(100)
      DIMENSION SMSTAR(100),SNSTAR(100),SISTAR(100),SJSTAR(100)
C
C     MAMAX = number of trig terms in the x-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     MDMAX = number of trig terms in the x-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     MBMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     MEMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     MCMAX = number of trig terms in the x-coord. expansion for displ. w
C     NAMAX = number of trig terms in the y-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     NDMAX = number of trig terms in the y-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     NBMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     NEMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     NCMAX = number of trig terms in the y-coord. expansion for displ. w
C
C
      PI = 3.1415927
C     MNTOT  = rank of the stiffness matrix 
C            = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C
      IF (NUMSTR.LT.1.AND.NUMRNG.LT.1) RETURN
      DO 2000 M = 1,MCMAX
        FM = FLOAT(M)*PI/XMAX
        GM = M
        IF (NUMRNG.GE.1) THEN
           DO  5 IRING = 1,NUMRNG
              XCOORD = (FLOAT(IRING)-1.)*SPCRNG
              CMSTAR(IRING) = DCOS(FM*XCOORD)
              SMSTAR(IRING) = DSIN(FM*XCOORD)
    5      CONTINUE
        ENDIF
        NSTART = 1
        NINCR = 1
        IF (ISPLIT.EQ.1) THEN
           NINCR = 2
           IMOD = MOD(M,2)
           IF (NDEL.EQ.1) THEN
            NSTART = 2
            IF (IMOD.EQ.0) NSTART = 1
           ELSE
            NSTART = 1
            IF (IMOD.EQ.0) NSTART = 2
           ENDIF
        ENDIF
      DO 1900 N = NSTART,NCMAX,NINCR
         FN = FLOAT(N)*PI/YMAX
         GN = N
         IF (NUMSTR.GE.1) THEN
           DO  6 ISTR = 1,NUMSTR
              YCOORD = (FLOAT(ISTR)-1.)*SPCSTR
              CNSTAR(ISTR) = DCOS(FN*YCOORD)
              SNSTAR(ISTR) = DSIN(FN*YCOORD)
    6      CONTINUE
         ENDIF
         IF (ISPLIT.EQ.1) THEN
           MNPOSA = MNCMAX +(M/2)*(NAMAX-NDEL)/2 
     1                           +((M-1)/2)*(NAMAX+NDEL)/2 + (N+1)/2
           MNPOSB = MNCMAX + MNAMAX +(M/2)*(NBMAX-NDEL)/2 
     1                           +((M-1)/2)*(NBMAX+NDEL)/2 + (N+1)/2
           MNPOSC = (M/2)*(NCMAX-NDEL)/2 
     1                           +((M-1)/2)*(NCMAX+NDEL)/2 + (N+1)/2
           MNPOSD = MNCMAX + MNAMAX + MNBMAX
     1                           +(M/2)*(NDMAX-NDEL)/2 
     1                           +((M-1)/2)*(NDMAX+NDEL)/2 + (N+1)/2
           MNPOSE = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(M/2)*(NEMAX-NDEL)/2 
     1                           +((M-1)/2)*(NEMAX+NDEL)/2 + (N+1)/2
         ELSE
           MNPOSA = MNCMAX + (M-1)*NAMAX + N
           MNPOSB = MNCMAX + MNAMAX + (M-1)*NBMAX + N
           MNPOSC = (M-1)*NCMAX + N
           MNPOSD = MNCMAX + MNAMAX + MNBMAX + (M-1)*NDMAX + N
           MNPOSE = MNCMAX + MNAMAX + MNBMAX + MNDMAX +(M-1)*NEMAX +N
         ENDIF
C
         DO 1800 I = 1,MCMAX
           FI = FLOAT(I)*PI/XMAX
           GI = I
           IF (NUMRNG.GE.1) THEN
              DO  7 IRING = 1,NUMRNG
                 XCOORD = (FLOAT(IRING)-1.)*SPCRNG
                 CISTAR(IRING) = DCOS(FI*XCOORD)
                 SISTAR(IRING) = DSIN(FI*XCOORD)
    7         CONTINUE
           ENDIF
           JSTART = 1
           JINCR  = 1
           IF (ISPLIT.EQ.1) THEN
              JINCR = 2
              IMOD = MOD(I,2)
              IF (NDEL.EQ.1) THEN
               JSTART = 2
               IF (IMOD.EQ.0) JSTART = 1
              ELSE
               JSTART = 1
               IF (IMOD.EQ.0) JSTART = 2
              ENDIF
           ENDIF
         DO 1700 J = JSTART,NCMAX,JINCR
            FJ = FLOAT(J)*PI/YMAX
            GJ = J
            IF (NUMSTR.GE.1) THEN
              DO  8 ISTR = 1,NUMSTR
                 YCOORD = (FLOAT(ISTR)-1.)*SPCSTR
                 CJSTAR(ISTR) = DCOS(FJ*YCOORD)
                 SJSTAR(ISTR) = DSIN(FJ*YCOORD)
    8         CONTINUE
            ENDIF
            IF (ISPLIT.EQ.1) THEN
              IJPOSA  = MNCMAX +(I/2)*(NAMAX-NDEL)/2 
     1                           +((I-1)/2)*(NAMAX+NDEL)/2 + (J+1)/2
              IJPOSB = MNCMAX + MNAMAX +(I/2)*(NBMAX-NDEL)/2 
     1                           +((I-1)/2)*(NBMAX+NDEL)/2 + (J+1)/2
              IJPOSC = (I/2)*(NCMAX-NDEL)/2 
     1                    +((I-1)/2)*(NCMAX+NDEL)/2 + (J+1)/2
              IJPOSD = MNCMAX + MNAMAX + MNBMAX
     1                           +(I/2)*(NDMAX-NDEL)/2 
     1                           +((I-1)/2)*(NDMAX+NDEL)/2 + (J+1)/2
              IJPOSE = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(I/2)*(NEMAX-NDEL)/2 
     1                           +((I-1)/2)*(NEMAX+NDEL)/2 + (J+1)/2
            ELSE
              IJPOSA = MNCMAX + (I-1)*NAMAX + J
              IJPOSB = MNCMAX + MNAMAX + (I-1)*NBMAX + J
              IJPOSC = (I-1)*NCMAX + J
              IJPOSD = MNCMAX + MNAMAX + MNBMAX + (I-1)*NDMAX + J
              IJPOSE = MNCMAX + MNAMAX + MNBMAX + MNDMAX 
     1                                           +(I-1)*NEMAX + J
            ENDIF
C
C  Stringers...
         IF (NUMSTR.GE.1) THEN
            XINTEG = 0.
            IF (M.EQ.I) THEN
C             IF (M.EQ.1.AND.N.EQ.1.AND.J.EQ.1)
C    1        WRITE(IFILE,'(A,A,/,5I3,1P,5E12.4)')
C    1     '  LUPPR1(1),LUPPR2(1),NUMSTR,M,I,',
C    1       'ECCSTR,EASTR,EIXSTR,EIYSTR,GJSTR=',
C    1        LUPPR1(1),LUPPR2(1),NUMSTR,M,I,
C    1        ECCSTR,EASTR,EIXSTR,EIYSTR,GJSTR
              XINTEG = 0.5*XMAX
              DO 16 ISTR = 1,NUMSTR
               SNSJ = SNSTAR(ISTR)*SJSTAR(ISTR)
               CNCJ = CNSTAR(ISTR)*CJSTAR(ISTR)
               XEAFI = XINTEG*EASTR*FM*FI
C BEG NOV 2003
               GJSTRE = GJSTR
               EIXSTE = EIXSTR
               IF (ISTR.EQ.1.OR.ISTR.EQ.NUMSTR) THEN
                  XEAFI  = 0.5*XEAFI
                  GJSTRE = 0.5*GJSTR
                  EIXSTE = 0.5*EIXSTR
               ENDIF
C END NOV 2003
               A(MNPOSA,IJPOSA) =A(MNPOSA,IJPOSA) + XEAFI*SNSJ
               A(IJPOSA,MNPOSA) =A(IJPOSA,MNPOSA) + XEAFI*SNSJ
               A(MNPOSA,IJPOSC) =A(MNPOSA,IJPOSC) - XEAFI*FI*ECCSTR*SNSJ
               A(IJPOSC,MNPOSA) =A(IJPOSC,MNPOSA) - XEAFI*FI*ECCSTR*SNSJ
               A(MNPOSC,IJPOSA) =A(MNPOSC,IJPOSA) - XEAFI*FM*ECCSTR*SNSJ
               A(IJPOSA,MNPOSC) =A(IJPOSA,MNPOSC) - XEAFI*FM*ECCSTR*SNSJ
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                      + XEAFI*FM*FI*ECCSTR**2*SNSJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                      + XEAFI*FM*FI*ECCSTR**2*SNSJ
               A(MNPOSD,IJPOSD) =A(MNPOSD,IJPOSD) + XEAFI*SNSJ
               A(IJPOSD,MNPOSD) =A(IJPOSD,MNPOSD) + XEAFI*SNSJ
C BEG NOV 2003
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                  + XINTEG*EIXSTE*SNSJ*FM**2*FI**2
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                  + XINTEG*EIXSTE*SNSJ*FM**2*FI**2
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                  + XINTEG*GJSTRE*CNCJ*FM*FN*FI*FJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                  + XINTEG*GJSTRE*CNCJ*FM*FN*FI*FJ
C END NOV 2003
C  The following terms are generated from the "EIy" bending stiffness:
               XEAFI = XINTEG*EIYSTR*FM**2*FI**2
               IF (ISTR.EQ.1.OR.ISTR.EQ.NUMSTR) XEAFI = 0.5*XEAFI
               CNSJ  = CNSTAR(ISTR)*SJSTAR(ISTR)
               SNCJ  = SNSTAR(ISTR)*CJSTAR(ISTR)
               A(MNPOSB,IJPOSB) =A(MNPOSB,IJPOSB) +XEAFI*CNCJ
               A(IJPOSB,MNPOSB) =A(IJPOSB,MNPOSB) +XEAFI*CNCJ
               A(MNPOSB,IJPOSE) =A(MNPOSB,IJPOSE) +XEAFI*CNSJ
               A(IJPOSE,MNPOSB) =A(IJPOSE,MNPOSB) +XEAFI*CNSJ
               A(MNPOSB,IJPOSC) =A(MNPOSB,IJPOSC) -XEAFI*FJ*ECCSTR*CNCJ
               A(IJPOSC,MNPOSB) =A(IJPOSC,MNPOSB) -XEAFI*FJ*ECCSTR*CNCJ
               A(MNPOSE,IJPOSB) =A(MNPOSE,IJPOSB) +XEAFI*SNCJ
               A(IJPOSB,MNPOSE) =A(IJPOSB,MNPOSE) +XEAFI*SNCJ
               A(MNPOSE,IJPOSE) =A(MNPOSE,IJPOSE) +XEAFI*SNSJ
               A(IJPOSE,MNPOSE) =A(IJPOSE,MNPOSE) +XEAFI*SNSJ
               A(MNPOSE,IJPOSC) =A(MNPOSE,IJPOSC) -XEAFI*FJ*ECCSTR*SNCJ
               A(IJPOSC,MNPOSE) =A(IJPOSC,MNPOSE) -XEAFI*FJ*ECCSTR*SNCJ
               A(MNPOSC,IJPOSB) =A(MNPOSC,IJPOSB) -XEAFI*FN*ECCSTR*CNCJ
               A(IJPOSB,MNPOSC) =A(IJPOSB,MNPOSC) -XEAFI*FN*ECCSTR*CNCJ
               A(MNPOSC,IJPOSE) =A(MNPOSC,IJPOSE) -XEAFI*FN*ECCSTR*CNSJ
               A(IJPOSE,MNPOSC) =A(IJPOSE,MNPOSC) -XEAFI*FN*ECCSTR*CNSJ
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                      +XEAFI*FN*FJ*ECCSTR**2*CNCJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                      +XEAFI*FN*FJ*ECCSTR**2*CNCJ
C
C  the following terms are generated from the fixed preload on the stringers:
              IF (LUPPR2(1).GT.0) THEN
              LUP = LUPPR2(1)
              DO 9 L = 1,LUP
               XEAFI = XINTEG*DX0STR(L)*FM*FI
               IF (ISTR.EQ.1.OR.ISTR.EQ.NUMSTR) XEAFI = 0.5*XEAFI
               ZCCSTR = ZDXSTR(L)
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC) +XEAFI*SNSJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC) +XEAFI*SNSJ
               A(MNPOSB,IJPOSB) =A(MNPOSB,IJPOSB) +XEAFI*CNCJ
               A(IJPOSB,MNPOSB) =A(IJPOSB,MNPOSB) +XEAFI*CNCJ
               A(MNPOSB,IJPOSE) =A(MNPOSB,IJPOSE) +XEAFI*CNSJ
               A(IJPOSE,MNPOSB) =A(IJPOSE,MNPOSB) +XEAFI*CNSJ
               A(MNPOSB,IJPOSC) =A(MNPOSB,IJPOSC) -XEAFI*FJ*ZCCSTR*CNCJ
               A(IJPOSC,MNPOSB) =A(IJPOSC,MNPOSB) -XEAFI*FJ*ZCCSTR*CNCJ
               A(MNPOSE,IJPOSB) =A(MNPOSE,IJPOSB) +XEAFI*SNCJ
               A(IJPOSB,MNPOSE) =A(IJPOSB,MNPOSE) +XEAFI*SNCJ
               A(MNPOSE,IJPOSE) =A(MNPOSE,IJPOSE) +XEAFI*SNSJ
               A(IJPOSE,MNPOSE) =A(IJPOSE,MNPOSE) +XEAFI*SNSJ
               A(MNPOSE,IJPOSC) =A(MNPOSE,IJPOSC) -XEAFI*FJ*ZCCSTR*SNCJ
               A(IJPOSC,MNPOSE) =A(IJPOSC,MNPOSE) -XEAFI*FJ*ZCCSTR*SNCJ
               A(MNPOSC,IJPOSB) =A(MNPOSC,IJPOSB) -XEAFI*FN*ZCCSTR*CNCJ
               A(IJPOSB,MNPOSC) =A(IJPOSB,MNPOSC) -XEAFI*FN*ZCCSTR*CNCJ
               A(MNPOSC,IJPOSE) =A(MNPOSC,IJPOSE) -XEAFI*FN*ZCCSTR*CNSJ
               A(IJPOSE,MNPOSC) =A(IJPOSE,MNPOSC) -XEAFI*FN*ZCCSTR*CNSJ
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                      +XEAFI*FN*FJ*ZCCSTR**2*CNCJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                      +XEAFI*FN*FJ*ZCCSTR**2*CNCJ
    9         CONTINUE
              ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
C  the following terms are generated from the eigenvalue preload on stringers:
              IF (LUPPR1(1).GT.0) THEN
              LUP = LUPPR1(1)
              DO 10 L = 1,LUP
               XEAFI = XINTEG*DNXSTR(L)*FM*FI
               IF (ISTR.EQ.1.OR.ISTR.EQ.NUMSTR) XEAFI = 0.5*XEAFI
               ZCCSTR = ZDXSTR(L)
C              IF (M.EQ.1.AND.N.EQ.1.AND.J.EQ.1.AND.ISTR.EQ.1)
C    1         WRITE(IFILE,'(A,5I2,1P,3E10.2)')
C    1       ' M,N,I,J,L,XINTEG,DNXSTR(L),ZCCSTR=',
C    1         M,N,I,J,L,XINTEG,DNXSTR(L),ZCCSTR
               B(MNPOSC,IJPOSC) =B(MNPOSC,IJPOSC) +XEAFI*SNSJ
               B(IJPOSC,MNPOSC) =B(IJPOSC,MNPOSC) +XEAFI*SNSJ
               B(MNPOSB,IJPOSB) =B(MNPOSB,IJPOSB) +XEAFI*CNCJ
               B(IJPOSB,MNPOSB) =B(IJPOSB,MNPOSB) +XEAFI*CNCJ
               B(MNPOSB,IJPOSE) =B(MNPOSB,IJPOSE) +XEAFI*CNSJ
               B(IJPOSE,MNPOSB) =B(IJPOSE,MNPOSB) +XEAFI*CNSJ
               B(MNPOSB,IJPOSC) =B(MNPOSB,IJPOSC) -XEAFI*FJ*ZCCSTR*CNCJ
               B(IJPOSC,MNPOSB) =B(IJPOSC,MNPOSB) -XEAFI*FJ*ZCCSTR*CNCJ
               B(MNPOSE,IJPOSB) =B(MNPOSE,IJPOSB) +XEAFI*SNCJ
               B(IJPOSB,MNPOSE) =B(IJPOSB,MNPOSE) +XEAFI*SNCJ
               B(MNPOSE,IJPOSE) =B(MNPOSE,IJPOSE) +XEAFI*SNSJ
               B(IJPOSE,MNPOSE) =B(IJPOSE,MNPOSE) +XEAFI*SNSJ
               B(MNPOSE,IJPOSC) =B(MNPOSE,IJPOSC) -XEAFI*FJ*ZCCSTR*SNCJ
               B(IJPOSC,MNPOSE) =B(IJPOSC,MNPOSE) -XEAFI*FJ*ZCCSTR*SNCJ
               B(MNPOSC,IJPOSB) =B(MNPOSC,IJPOSB) -XEAFI*FN*ZCCSTR*CNCJ
               B(IJPOSB,MNPOSC) =B(IJPOSB,MNPOSC) -XEAFI*FN*ZCCSTR*CNCJ
               B(MNPOSC,IJPOSE) =B(MNPOSC,IJPOSE) -XEAFI*FN*ZCCSTR*CNSJ
               B(IJPOSE,MNPOSC) =B(IJPOSE,MNPOSC) -XEAFI*FN*ZCCSTR*CNSJ
               B(MNPOSC,IJPOSC) =B(MNPOSC,IJPOSC)
     1                                      +XEAFI*FN*FJ*ZCCSTR**2*CNCJ
               B(IJPOSC,MNPOSC) =B(IJPOSC,MNPOSC)
     1                                      +XEAFI*FN*FJ*ZCCSTR**2*CNCJ
   10         CONTINUE
              ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
   16         CONTINUE
            ENDIF
            IMOD1 = MOD(M-I,2)
            IF (IMOD1.NE.0) THEN
              XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
              DO 20 ISTR = 1,NUMSTR
               SNSJ = SNSTAR(ISTR)*SJSTAR(ISTR)
               XEAFI = XINTEG*2.*EASTR*FM*FI
               IF (ISTR.EQ.1.OR.ISTR.EQ.NUMSTR) XEAFI = 0.5*XEAFI
               A(MNPOSA,IJPOSD) =A(MNPOSA,IJPOSD) -XEAFI*SNSJ
               A(IJPOSD,MNPOSA) =A(IJPOSD,MNPOSA) -XEAFI*SNSJ
               A(MNPOSC,IJPOSD) =A(MNPOSC,IJPOSD) +XEAFI*SNSJ*FM*ECCSTR
               A(IJPOSD,MNPOSC) =A(IJPOSD,MNPOSC) +XEAFI*SNSJ*FM*ECCSTR
   20         CONTINUE
            ENDIF
         ENDIF
C
C  Rings...
         IF (NUMRNG.GE.1) THEN
            YINTEG = 0.
            IF (N.EQ.J) THEN
C             IF (M.EQ.1.AND.N.EQ.1.AND.I.EQ.1)
C    1        WRITE(IFILE,'(A,A,/,5I3,1P,5E12.4)')
C    1     '  LUPPR1(2),LUPPR2(2),NUMRNG,N,J,',
C    1       'ECCRNG,EARNG,EIXRNG,EIYRNG,GJRNG=',
C    1        LUPPR1(1),LUPPR2(1),NUMRNG,M,I,
C    1        ECCRNG,EARNG,EIXRNG,EIYRNG,GJRNG
              YINTEG = 0.5*YMAX
              DO 30 IRNG = 1,NUMRNG
               SMSI = SMSTAR(IRNG)*SISTAR(IRNG)
               CMCI = CMSTAR(IRNG)*CISTAR(IRNG)
               YEAFI = YINTEG*EARNG*FN*FJ
C BEG NOV 2003
               GJRNGE = GJRNG
               EIXRNE = EIXRNG
               IF (IRNG.EQ.1.OR.IRNG.EQ.NUMRNG) THEN
                  YEAFI = 0.5*YEAFI
                  GJRNGE = 0.5*GJRNG
                  EIXRNE = 0.5*EIXRNG
               ENDIF
C END NOV 2003
               A(MNPOSB,IJPOSB) =A(MNPOSB,IJPOSB) + YEAFI*SMSI
               A(IJPOSB,MNPOSB) =A(IJPOSB,MNPOSB) + YEAFI*SMSI
               A(MNPOSB,IJPOSC) =A(MNPOSB,IJPOSC)
     1                                  - YEAFI*(CUR/FJ+FJ*ECCRNG)*SMSI
               A(IJPOSC,MNPOSB) =A(IJPOSC,MNPOSB)
     1                                  - YEAFI*(CUR/FJ+FJ*ECCRNG)*SMSI
               A(MNPOSC,IJPOSB) =A(MNPOSC,IJPOSB)
     1                                  - YEAFI*(CUR/FN+FN*ECCRNG)*SMSI
               A(IJPOSB,MNPOSC) =A(IJPOSB,MNPOSC)
     1                                  - YEAFI*(CUR/FN+FN*ECCRNG)*SMSI
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1               + YEAFI*(CUR/FN+FN*ECCRNG)*(CUR/FJ+FJ*ECCRNG)*SMSI
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1               + YEAFI*(CUR/FN+FN*ECCRNG)*(CUR/FJ+FJ*ECCRNG)*SMSI
               A(MNPOSE,IJPOSE) =A(MNPOSE,IJPOSE) + YEAFI*SMSI
               A(IJPOSE,MNPOSE) =A(IJPOSE,MNPOSE) + YEAFI*SMSI
C BEG NOV 2003
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                + YINTEG*EIXRNE*SMSI*FN**2*FJ**2
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                + YINTEG*EIXRNE*SMSI*FN**2*FJ**2
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                + YINTEG*GJRNGE*CMCI*FM*FN*FI*FJ
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                + YINTEG*GJRNGE*CMCI*FM*FN*FI*FJ
C END NOV 2003
C  The following terms are generated from the "EIy" bending stiffness:
               YEAFI = YINTEG*EIYRNG*FN**2*FJ**2
               IF (IRNG.EQ.1.OR.IRNG.EQ.NUMRNG) YEAFI = 0.5*YEAFI
               CMSI  = CMSTAR(IRNG)*SISTAR(IRNG)
               SMCI  = SMSTAR(IRNG)*CISTAR(IRNG)
               A(MNPOSA,IJPOSA) =A(MNPOSA,IJPOSA) +YEAFI*CMCI
               A(IJPOSA,MNPOSA) =A(IJPOSA,MNPOSA) +YEAFI*CMCI
               A(MNPOSA,IJPOSD) =A(MNPOSA,IJPOSD) +YEAFI*CMSI
               A(IJPOSD,MNPOSA) =A(IJPOSD,MNPOSA) +YEAFI*CMSI
               A(MNPOSA,IJPOSC) =A(MNPOSA,IJPOSC) -YEAFI*FI*ECCRNG*CMCI
               A(IJPOSC,MNPOSA) =A(IJPOSC,MNPOSA) -YEAFI*FI*ECCRNG*CMCI
               A(MNPOSD,IJPOSA) =A(MNPOSD,IJPOSA) +YEAFI*SMCI
               A(IJPOSA,MNPOSD) =A(IJPOSA,MNPOSD) +YEAFI*SMCI
               A(MNPOSD,IJPOSD) =A(MNPOSD,IJPOSD) +YEAFI*SMSI
               A(IJPOSD,MNPOSD) =A(IJPOSD,MNPOSD) +YEAFI*SMSI
               A(MNPOSD,IJPOSC) =A(MNPOSD,IJPOSC) -YEAFI*FI*ECCRNG*SMCI
               A(IJPOSC,MNPOSD) =A(IJPOSC,MNPOSD) -YEAFI*FI*ECCRNG*SMCI
               A(MNPOSC,IJPOSA) =A(MNPOSC,IJPOSA) -YEAFI*FM*ECCRNG*CMCI
               A(IJPOSA,MNPOSC) =A(IJPOSA,MNPOSC) -YEAFI*FM*ECCRNG*CMCI
               A(MNPOSC,IJPOSD) =A(MNPOSC,IJPOSD) -YEAFI*FM*ECCRNG*CMSI
               A(IJPOSD,MNPOSC) =A(IJPOSD,MNPOSC) -YEAFI*FM*ECCRNG*CMSI
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                      +YEAFI*FM*FI*ECCRNG**2*CMCI
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                      +YEAFI*FM*FI*ECCRNG**2*CMCI
C  the following terms are generated from the fixed preload on the rings:
              IF (LUPPR2(2).GT.0) THEN
              LUP = LUPPR2(2)
              DO 27 L = 1,LUP
               YEAFI = YINTEG*DX0RNG(L)*FN*FJ
               IF (IRNG.EQ.1.OR.IRNG.EQ.NUMRNG) YEAFI = 0.5*YEAFI
               ZCCRNG = ZDXRNG(L)
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC) +YEAFI*SMSI
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC) +YEAFI*SMSI
               A(MNPOSA,IJPOSA) =A(MNPOSA,IJPOSA) +YEAFI*CMCI
               A(IJPOSA,MNPOSA) =A(IJPOSA,MNPOSA) +YEAFI*CMCI
               A(MNPOSA,IJPOSD) =A(MNPOSA,IJPOSD) +YEAFI*CMSI
               A(IJPOSD,MNPOSA) =A(IJPOSD,MNPOSA) +YEAFI*CMSI
               A(MNPOSA,IJPOSC) =A(MNPOSA,IJPOSC) -YEAFI*FI*ZCCRNG*CMCI
               A(IJPOSC,MNPOSA) =A(IJPOSC,MNPOSA) -YEAFI*FI*ZCCRNG*CMCI
               A(MNPOSD,IJPOSA) =A(MNPOSD,IJPOSA) +YEAFI*SMCI
               A(IJPOSA,MNPOSD) =A(IJPOSA,MNPOSD) +YEAFI*SMCI
               A(MNPOSD,IJPOSD) =A(MNPOSD,IJPOSD) +YEAFI*SMSI
               A(IJPOSD,MNPOSD) =A(IJPOSD,MNPOSD) +YEAFI*SMSI
               A(MNPOSD,IJPOSC) =A(MNPOSD,IJPOSC) -YEAFI*FI*ZCCRNG*SMCI
               A(IJPOSC,MNPOSD) =A(IJPOSC,MNPOSD) -YEAFI*FI*ZCCRNG*SMCI
               A(MNPOSC,IJPOSA) =A(MNPOSC,IJPOSA) -YEAFI*FM*ZCCRNG*CMCI
               A(IJPOSA,MNPOSC) =A(IJPOSA,MNPOSC) -YEAFI*FM*ZCCRNG*CMCI
               A(MNPOSC,IJPOSD) =A(MNPOSC,IJPOSD) -YEAFI*FM*ZCCRNG*CMSI
               A(IJPOSD,MNPOSC) =A(IJPOSD,MNPOSC) -YEAFI*FM*ZCCRNG*CMSI
               A(MNPOSC,IJPOSC) =A(MNPOSC,IJPOSC)
     1                                      +YEAFI*FM*FI*ZCCRNG**2*CMCI
               A(IJPOSC,MNPOSC) =A(IJPOSC,MNPOSC)
     1                                      +YEAFI*FM*FI*ZCCRNG**2*CMCI
   27         CONTINUE
              ENDIF
C  the following terms are generated from the eigenvalue preload on the rings:
              IF (LUPPR1(2).GT.0) THEN
              LUP = LUPPR1(2)
              DO 29 L = 1,LUP
               YEAFI = YINTEG*DNXRNG(L)*FN*FJ
               IF (IRNG.EQ.1.OR.IRNG.EQ.NUMRNG) YEAFI = 0.5*YEAFI
               ZCCRNG = ZDXRNG(L)
C              IF (M.EQ.1.AND.N.EQ.1.AND.I.EQ.1.AND.IRNG.EQ.1)
C    1         WRITE(IFILE,'(A,5I2,1P,3E10.2)')
C    1       ' M,N,I,J,L,YINTEG,DNXRNG(L),ZCCRNG=',
C    1         M,N,I,J,L,YINTEG,DNXRNG(L),ZCCRNG
               B(MNPOSC,IJPOSC) =B(MNPOSC,IJPOSC) +YEAFI*SMSI
               B(IJPOSC,MNPOSC) =B(IJPOSC,MNPOSC) +YEAFI*SMSI
               B(MNPOSA,IJPOSA) =B(MNPOSA,IJPOSA) +YEAFI*CMCI
               B(IJPOSA,MNPOSA) =B(IJPOSA,MNPOSA) +YEAFI*CMCI
               B(MNPOSA,IJPOSD) =B(MNPOSA,IJPOSD) +YEAFI*CMSI
               B(IJPOSD,MNPOSA) =B(IJPOSD,MNPOSA) +YEAFI*CMSI
               B(MNPOSA,IJPOSC) =B(MNPOSA,IJPOSC) -YEAFI*FI*ZCCRNG*CMCI
               B(IJPOSC,MNPOSA) =B(IJPOSC,MNPOSA) -YEAFI*FI*ZCCRNG*CMCI
               B(MNPOSD,IJPOSA) =B(MNPOSD,IJPOSA) +YEAFI*SMCI
               B(IJPOSA,MNPOSD) =B(IJPOSA,MNPOSD) +YEAFI*SMCI
               B(MNPOSD,IJPOSD) =B(MNPOSD,IJPOSD) +YEAFI*SMSI
               B(IJPOSD,MNPOSD) =B(IJPOSD,MNPOSD) +YEAFI*SMSI
               B(MNPOSD,IJPOSC) =B(MNPOSD,IJPOSC) -YEAFI*FI*ZCCRNG*SMCI
               B(IJPOSC,MNPOSD) =B(IJPOSC,MNPOSD) -YEAFI*FI*ZCCRNG*SMCI
               B(MNPOSC,IJPOSA) =B(MNPOSC,IJPOSA) -YEAFI*FM*ZCCRNG*CMCI
               B(IJPOSA,MNPOSC) =B(IJPOSA,MNPOSC) -YEAFI*FM*ZCCRNG*CMCI
               B(MNPOSC,IJPOSD) =B(MNPOSC,IJPOSD) -YEAFI*FM*ZCCRNG*CMSI
               B(IJPOSD,MNPOSC) =B(IJPOSD,MNPOSC) -YEAFI*FM*ZCCRNG*CMSI
               B(MNPOSC,IJPOSC) =B(MNPOSC,IJPOSC)
     1                                      +YEAFI*FM*FI*ZCCRNG**2*CMCI
               B(IJPOSC,MNPOSC) =B(IJPOSC,MNPOSC)
     1                                      +YEAFI*FM*FI*ZCCRNG**2*CMCI
   29         CONTINUE
              ENDIF
   30         CONTINUE
            ENDIF
            IMOD1 = MOD(N-J,2)
            IF (IMOD1.NE.0) THEN
              YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
              DO 40 IRNG = 1,NUMRNG
               SMSI = SMSTAR(IRNG)*SISTAR(IRNG)
               YEAFI = YINTEG*2.*EARNG*FN*FJ
               IF (IRNG.EQ.1.OR.IRNG.EQ.NUMRNG) YEAFI = 0.5*YEAFI
               A(MNPOSB,IJPOSE) =A(MNPOSB,IJPOSE) -YEAFI*SMSI
               A(IJPOSE,MNPOSB) =A(IJPOSE,MNPOSB) -YEAFI*SMSI
               A(MNPOSC,IJPOSE) =A(MNPOSC,IJPOSE)
     1                                   +YEAFI*SMSI*(CUR/FN+FN*ECCRNG)
               A(IJPOSE,MNPOSC) =A(IJPOSE,MNPOSC)
     1                                   +YEAFI*SMSI*(CUR/FN+FN*ECCRNG)
   40         CONTINUE
            ENDIF
         ENDIF
C
 1700    CONTINUE
 1800    CONTINUE
 1900 CONTINUE
 2000 CONTINUE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
      IF (MNTOT.LE.0) THEN
        WRITE(IFILE,60)
   60   FORMAT(/' STIFFNESS MATRIX, A:',/,
     1' A(I,1)   A(I,2)   A(I,3)   A(I,4)   A(I,5)   A(I,6)   A(I,7)  ',
     1' A(I,8)   A(I,9)   A(I,10)  A(I,11)  A(I,12)')
        DO 70 I = 1,MNTOT
         WRITE(IFILE,65) (A(I,J),J=1,MNTOT)
   65    FORMAT(1P12E9.2)
   70   CONTINUE
      ENDIF
C
      RETURN
      END       
C
C
C
C=DECK      TRIGW
      SUBROUTINE TRIGW(B,FNX,FNY,FNXY,MNTOT,
     1  MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,
     1  XMAX,YMAX,CUR,FISAND,IFILE,
     1  MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,ISPLIT)
C23456789012345678901234567890123456789012345678901234567890123456789012
C
C  PURPOSE IS TO FILL THE LOAD-GEOMETRIC MATRIX FOR LINEAR BUCKLING OF PANEL
C  SKIN BETWEEN STIFFENERS. THIS SUBROUTINE IS FOR THE DONNELL OR SANDERS
C  THEORIES.
C
C  The theory is based on the following:
C   1. The assumed displacement field is:
C   axial displacement, u = sum-over-m{sum-over-n{A(m,n)cos(mx)sin(ny)
C                                                +D(m,n)sin(mx)sin(ny)}}
C    hoop displacement, v = sum-over-m{sum-over-n{B(m,n)sin(mx)cos(ny)
C                                                +E(m,n)sin(mx)sin(ny)}}
C  normal displacement, w = sum-over-m{sum-over-n{C(m,n)sin(mx)sin(ny)}}
C      
C   2. The work done by prebuckling in-plane loads Nxo, Nyo, Nxyo
C      during bifurcation buckling displacements (from Sanders' theory)
C      is given by:
C
C      W = 0.5*int-over-x{int-over-y{Nxo[(w,x)**2 +gamma**2]
C             +Nyo[(w,y-v/R)**2 +gamma**2] +Nxyo[(w,x)(w,y-v/R)]}dy}dx
C
C      in which
C               gamma = 0.5(u,y - v,x)
C
C   3. We wish to express the "work done", W, in a form analogous to
C      that used for the strain energy. If we define three rotation
C      components, rotx, roty, rotxy, as follows:
C       rotx  = w,x
C       roty  = w,y - v/R
C       rotxy = 0.5*(u,y - v,x)
C
C   4. then the "work done", W, is given by
C
C       W = 0.5*int-over-x{int-over-y{rot(transpose)*[N]*rot}dy}dx
C
C      in which rot = [rotx, roty, rotxy] and the 3x3 matrix [N] is
C      given by:
C                 Nxo    Nxyo   0.
C                 
C                 Nxyo   Nyo    0.
C
C                 0.     0.  (Nxo+Nyo)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION COEFMN(2,3),COEFIJ(2,3),MNPOS(2,3),IJPOS(2,3),ITERMS(3)
      DIMENSION RESULT(3,3),ITRIG(3,2)
      DIMENSION ITRIGD(3,2),COFDMN(3),COFEMN(3),MNPOSD(3),MNPOSE(3)
      DIMENSION ITRIGE(3,2),COFDIJ(3),COFEIJ(3),IJPOSD(3),IJPOSE(3)
      DIMENSION B(MNTOT,MNTOT)
C
C     RESULT(i,j) is the 3x3 [N] matrix given in 4. above:
C
      CALL MOVER(0.,0,RESULT,1,18)
      RESULT(1,1) = FNX
      RESULT(1,2) = FNXY
      RESULT(2,1) = FNXY
      RESULT(2,2) = FNY
      RESULT(3,3) = FNX + FNY
C     WRITE(IFILE,'(A,1P,3E12.3)')' FNX,FNY,FNXY=',FNX,FNY,FNXY
C
C     MAMAX = number of trig terms in the x-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     MDMAX = number of trig terms in the x-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     MBMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     MEMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     MCMAX = number of trig terms in the x-coord. expansion for displ. w
C     NAMAX = number of trig terms in the y-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     NDMAX = number of trig terms in the y-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     NBMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     NEMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     NCMAX = number of trig terms in the y-coord. expansion for displ. w
C
      PI = 3.1415927
C     MNTOT  = rank of the load-geometric matrix 
C            = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C
C     ITERMS(i) = number of terms in the ith rotation expression
      ITERMS(1) = 1
      ITERMS(2) = 2
      ITERMS(3) = 2
C
C     ITRIG(i,j) = ith rotation component.
C                  j=1 means x-coord., j=2 means y-coord.
C                  ITRIG = 1 means sine, 2 means cosine, 
C
      ITRIG(1,1) = 2
      ITRIG(1,2) = 1
      ITRIG(2,1) = 1
      ITRIG(2,2) = 2
      ITRIG(3,1) = 2
      ITRIG(3,2) = 2
C
      IF (MNDMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGD,1,6)
C        ITRIGD(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGD(3,1) = 1
         ITRIGD(3,2) = 2
      ENDIF
      IF (MNEMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGE,1,6)
C        ITRIGE(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGE(2,1) = 1
         ITRIGE(2,2) = 1
         ITRIGE(3,1) = 2
         ITRIGE(3,2) = 1
      ENDIF
C
C     COEFMN(i,j), i=1,2; j=1,3: coefficients of the undetermined
C                  coefficients, A(m,n), B(m,n), C(m,n) in the rotation
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to the rotation component.
C     MNPOS(i,j),  i=1,2; j=1,3: row or col. number in load-geometric matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C
      DO 2000 M = 1,MCMAX
        FM = FLOAT(M)*PI/XMAX
        GM = M
        NSTART = 1
        NINCR  = 1
        IF (ISPLIT.EQ.1) THEN
           NINCR = 2
           IMOD = MOD(M,2)
           IF (NDEL.EQ.1) THEN
            NSTART = 2
            IF (IMOD.EQ.0) NSTART = 1
           ELSE
            NSTART = 1
            IF (IMOD.EQ.0) NSTART = 2
           ENDIF
        ENDIF
      DO 1900 N = NSTART,NCMAX,NINCR
         FN = FLOAT(N)*PI/YMAX
         GN = N
         CALL MOVER(0.,0,COEFMN,1,12)
         CALL MOVER(0,0,MNPOS,1,6)
         COEFMN(1,1) = FM
         COEFMN(1,2) = FN
         IF (ISPLIT.EQ.1) MNPOS(1,1) = (M/2)*(NCMAX-NDEL)/2 
     1                   +((M-1)/2)*(NCMAX+NDEL)/2 + (N+1)/2
         IF (ISPLIT.EQ.0) MNPOS(1,1) = (M-1)*NCMAX + N
         MNPOS(1,2)  = MNPOS(1,1)
         IF (N.LE.NBMAX.AND.M.LE.MBMAX) THEN
            COEFMN(2,2) = -FISAND*CUR
            COEFMN(2,3) = -0.5*FISAND*FM
            IF (ISPLIT.EQ.1)
     1           MNPOS(2,2) = MNCMAX + MNAMAX +(M/2)*(NBMAX-NDEL)/2 
     1                          +((M-1)/2)*(NBMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0)
     1           MNPOS(2,2) = MNCMAX + MNAMAX + (M-1)*NBMAX + N
            MNPOS(2,3)  = MNPOS(2,2)
         ENDIF
         IF (N.LE.NAMAX.AND.M.LE.MAMAX) THEN
            COEFMN(1,3) = 0.5*FISAND*FN
            IF (ISPLIT.EQ.1)
     1           MNPOS(1,3) = MNCMAX +(M/2)*(NAMAX-NDEL)/2 
     1                        +((M-1)/2)*(NAMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0)  MNPOS(1,3) = MNCMAX + (M-1)*NAMAX + N
         ENDIF
C        WRITE(IFILE,'(A,/,1P,3E12.4)')' COEFMN(1,L),L=1,3=',
C    1                                  (COEFMN(1,L),L=1,3)
C        WRITE(IFILE,'(A,/,1P,3E12.4)')' COEFMN(2,L),L=1,3=',
C    1                                  (COEFMN(2,L),L=1,3)
C
C  Add the "D" and "E" terms, if any:
C     COFDMN(i), i=1,3 = coefficients of the undetermined coefficients
C     D(m,n) of the u-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..3).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNDMAX.GT.0) THEN
            CALL MOVER(0.,0,COFDMN,1,6)
            CALL MOVER(0,0,MNPOSD,1,3)
            IF (M.LE.MDMAX.AND.N.LE.NDMAX) THEN
               COFDMN(3) = 0.5*FN*FISAND
               IF (ISPLIT.EQ.1) MNPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           +(M/2)*(NDMAX-NDEL)/2 
     1                           +((M-1)/2)*(NDMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0) MNPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           + (M-1)*NDMAX + N
            ENDIF
         ENDIF
C     COFEMN(i), i=1,3 = coefficients of the undetermined coefficients
C     E(m,n) of the v-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..3).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNEMAX.GT.0) THEN
            CALL MOVER(0.,0,COFEMN,1,6)
            CALL MOVER(0,0,MNPOSE,1,3)
            IF (M.LE.MEMAX.AND.N.LE.NEMAX) THEN
               COFEMN(2) = -CUR*FISAND
               COFEMN(3) = -0.5*FM*FISAND
               IF (ISPLIT.EQ.1)
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(M/2)*(NEMAX-NDEL)/2 
     1                           +((M-1)/2)*(NEMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0)
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           + (M-1)*NEMAX + N
               MNPOSE(3) = MNPOSE(2)
            ENDIF
         ENDIF
C
C     COEFIJ(i,j), i=1,2; j=1,3: coefficients of the undetermined
C                  coefficients, A(i,j), B(i,j), C(i,j) in the rotation
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C     IJPOS(i,j),  i=1,2; j=1,3: column or row no. in load-geometric matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C
         DO 1800 I = 1,MCMAX
           FI = FLOAT(I)*PI/XMAX
           GI = I
           JSTART = 1
           JINCR  = 1
           IF (ISPLIT.EQ.1) THEN
              JINCR = 2
              IMOD = MOD(I,2)
              IF (NDEL.EQ.1) THEN
               JSTART = 2
               IF (IMOD.EQ.0) JSTART = 1
              ELSE
               JSTART = 1
               IF (IMOD.EQ.0) JSTART = 2
              ENDIF
           ENDIF
         DO 1700 J = JSTART,NCMAX,JINCR
            FJ = FLOAT(J)*PI/YMAX
            GJ = J
            CALL MOVER(0.,0,COEFIJ,1,12)
            CALL MOVER(0,0,IJPOS,1,6)
            COEFIJ(1,1) = FI
            COEFIJ(1,2) = FJ
            IF (ISPLIT.EQ.1)  IJPOS(1,1) = (I/2)*(NCMAX-NDEL)/2 
     1                      +((I-1)/2)*(NCMAX+NDEL)/2 + (J+1)/2
            IF (ISPLIT.EQ.0)  IJPOS(1,1) = (I-1)*NCMAX + J
            IJPOS(1,2)  = IJPOS(1,1)
            IF (J.LE.NBMAX.AND.I.LE.MBMAX) THEN
               COEFIJ(2,2) = -FISAND*CUR
               COEFIJ(2,3) = -0.5*FISAND*FI
               IF (ISPLIT.EQ.1)
     1             IJPOS(2,2) = MNCMAX + MNAMAX +(I/2)*(NBMAX-NDEL)/2 
     1                            +((I-1)/2)*(NBMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0)
     1             IJPOS(2,2) = MNCMAX + MNAMAX + (I-1)*NBMAX + J
               IJPOS(2,3)  = IJPOS(2,2)
            ENDIF
            IF (J.LE.NAMAX.AND.I.LE.MAMAX) THEN
               COEFIJ(1,3) = 0.5*FISAND*FJ
               IF (ISPLIT.EQ.1)
     1             IJPOS(1,3)  = MNCMAX +(I/2)*(NAMAX-NDEL)/2 
     1                           +((I-1)/2)*(NAMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0)
     1             IJPOS(1,3)  = MNCMAX + (I-1)*NAMAX + J
            ENDIF
C
C  Add the "D" and "E" terms, if any:
C     COFDIJ(k), k=1,3 = coefficients of the undetermined coefficients
C     D(i,j) of the u-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..3).
C     IJPOSD(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
C23456789012345678901234567890123456789012345678901234567890123456789012
            IF (MNDMAX.GT.0) THEN
               CALL MOVER(0.,0,COFDIJ,1,6)
               CALL MOVER(0,0,IJPOSD,1,3)
               IF (I.LE.MDMAX.AND.J.LE.NDMAX) THEN
                  COFDIJ(3) = 0.5*FJ*FISAND
                  IF (ISPLIT.EQ.1) IJPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           +(I/2)*(NDMAX-NDEL)/2 
     1                           +((I-1)/2)*(NDMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0) IJPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                                          + (I-1)*NDMAX + J
               ENDIF
            ENDIF
C     COFEIJ(k), k=1,3 = coefficients of the undetermined coefficients
C     E(i,j) of the v-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..3).
C     IJPOSE(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
            IF (MNEMAX.GT.0) THEN
               CALL MOVER(0.,0,COFEIJ,1,6)
               CALL MOVER(0,0,IJPOSE,1,3)
               IF (I.LE.MEMAX.AND.J.LE.NEMAX) THEN
                  COFEIJ(2) = -CUR*FISAND
                  COFEIJ(3) = -0.5*FI*FISAND
                  IF (ISPLIT.EQ.1)
     1                 IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(I/2)*(NEMAX-NDEL)/2 
     1                           +((I-1)/2)*(NEMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0)
     1                 IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           + (I-1)*NEMAX + J
                  IJPOSE(3) = IJPOSE(2)
               ENDIF
            ENDIF
C
C           WRITE(IFILE,'(A,/,1P,3E12.4)')' COEFIJ(1,L),L=1,3=',
C    1                                     (COEFIJ(1,L),L=1,3)
C           WRITE(IFILE,'(A,/,1P,3E12.4)')' COEFIJ(2,L),L=1,3=',
C    1                                     (COEFIJ(2,L),L=1,3)
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
            DO 300 IROT = 1,3
            ITIEND = ITERMS(IROT)
            DO 250 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 250
               MN = MNPOS(ITERMI,IROT)
            DO 200 JROT = 1,3
            IF (RESULT(IROT,JROT).EQ.0.) GO TO 200
            ITJEND = ITERMS(JROT)
            DO 150 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 150
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1         RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COEFIJ(ITERMJ,JROT)
C              WRITE(IFILE,'(A,/,4I3,1P,4E12.4)')
C    1       ' IROT,JROT,ITERMI,ITERMJ,COEF,RESULT,COEFMN,COEFIJ=',
C    1         IROT,JROT,ITERMI,ITERMJ,COEF,RESULT(IROT,JROT),
C    1                   COEFMN(ITERMI,IROT),COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 150
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,M,I,XINTEG=',IROT,JROT,M,I,XINTEG
                  GO TO 10
               ELSE
                  IMOD = MOD(M-I,2)
C                 WRITE(IFILE,'(A,7I3)') 
C    1             ' M,I,N,J,IMOD,ITRIG(IROT,1),ITRIG(JROT,1)=',
C    1               M,I,N,J,IMOD,ITRIG(IROT,1),ITRIG(JROT,1)
                  IF (IMOD.EQ.0) GO TO 150
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,M,I,XINTEG=',IROT,JROT,M,I,XINTEG
               ENDIF
   10          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 150
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,N,J,YINTEG,=',IROT,JROT,N,J,YINTEG
                  GO TO 20
               ELSE
                  IMOD = MOD(N-J,2)
C                 WRITE(IFILE,'(A,7I3)') 
C    1             ' M,I,N,J,IMOD,ITRIG(IROT,2),ITRIG(JROT,2)=',
C    1               M,I,N,J,IMOD,ITRIG(IROT,2),ITRIG(JROT,2)
                  IF (IMOD.EQ.0) GO TO 150
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,N,J,YINTEG,=',IROT,JROT,N,J,YINTEG
               ENDIF
   20          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into load-geometric matrix, B:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
C              WRITE(IFILE,'(A,2I4,1P,3E12.4)')
C    1       ' MN,IJ,B(MN,IJ),FINTEG,COEF=',MN,IJ,B(MN,IJ),FINTEG,COEF
  150       CONTINUE
  200       CONTINUE
  250       CONTINUE
  300       CONTINUE
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 400 IROT = 1,3
            ITIEND = ITERMS(IROT)
            DO 350 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 350
               MN = MNPOS(ITERMI,IROT)
            DO 325 JROT = 1,3
               IF (RESULT(IROT,JROT).EQ.0.0) GO TO 325
               IF (COFDIJ(JROT).EQ.0.0) GO TO 325
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 310
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  310          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 320
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  320          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  325       CONTINUE
  350       CONTINUE
  400       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 500 IROT = 1,3
            ITIEND = ITERMS(IROT)
            DO 450 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 450
               MN = MNPOS(ITERMI,IROT)
            DO 425 JROT = 1,3
               IF (RESULT(IROT,JROT).EQ.0.0) GO TO 425
               IF (COFEIJ(JROT).EQ.0.0) GO TO 425
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 410
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  410          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 420
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  420          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  425       CONTINUE
  450       CONTINUE
  500       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNDMAX.GT.0) THEN
            DO 600 IROT = 1,3
               IF (COFDMN(IROT).EQ.0.0) GO TO 600
               MN = MNPOSD(IROT)
            DO 550 JROT = 1,3
            ITJEND = ITERMS(JROT)
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 550
            DO 525 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 525
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 510
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  510          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 520
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  520          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  525       CONTINUE
  550       CONTINUE
  600       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNEMAX.GT.0) THEN
            DO 700 IROT = 1,3
               IF (COFEMN(IROT).EQ.0.0) GO TO 700
               MN = MNPOSE(IROT)
            DO 650 JROT = 1,3
            ITJEND = ITERMS(JROT)
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 650
            DO 625 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 625
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 610
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  610          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 620
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  620          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  625       CONTINUE
  650       CONTINUE
  700       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 800 IROT = 1,3
               IF (COFDMN(IROT).EQ.0.0) GO TO 800
               MN = MNPOSD(IROT)
            DO 750 JROT = 1,3
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 750
               IF (COFDIJ(JROT).EQ.0.0) GO TO 750
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 710
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  710          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 720
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  720          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  750       CONTINUE
  800       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 900 IROT = 1,3
               IF (COFDMN(IROT).EQ.0.0) GO TO 900
               MN = MNPOSD(IROT)
            DO 850 JROT = 1,3
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 850
               IF (COFEIJ(JROT).EQ.0.0) GO TO 850
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 810
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  810          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 820
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  820          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  850       CONTINUE
  900       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 1000 IROT = 1,3
               IF (COFEMN(IROT).EQ.0.0) GO TO 1000
               MN = MNPOSE(IROT)
            DO 950 JROT = 1,3
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 950
               IF (COFDIJ(JROT).EQ.0.0) GO TO 950
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 910
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  910          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 920
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  920          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  950       CONTINUE
 1000       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 1100 IROT = 1,3
               IF (COFEMN(IROT).EQ.0.0) GO TO 1100
               MN = MNPOSE(IROT)
            DO 1050 JROT = 1,3
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 1050
               IF (COFEIJ(JROT).EQ.0.0) GO TO 1050
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1010
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
 1010          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1020
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
 1020          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
 1050       CONTINUE
 1100       CONTINUE
          ENDIF
C
 1700    CONTINUE
 1800    CONTINUE
 1900 CONTINUE
 2000 CONTINUE
C
      IF (MNTOT.LE.0) THEN
        WRITE(IFILE,60)
   60   FORMAT(/' LOAD-GEOMETRIC MATRIX, B:',/,
     1' B(I,1)   B(I,2)   B(I,3)   B(I,4)   B(I,5)   B(I,6)   B(I,7)  ',
     1' B(I,8)   B(I,9)   B(I,10)  B(I,11)  B(I,12)')
        DO 70 I = 1,MNTOT
         WRITE(IFILE,65) (B(I,J),J=1,MNTOT)
   65    FORMAT(1P12E9.2)
   70   CONTINUE
      ENDIF
C
      RETURN
      END       
C
C
C
C=DECK      TRIGWM
      SUBROUTINE TRIGWM(B,FNX,FNY,FNXY,MNTOT,
     1  MAMAX,NAMAX,MBMAX,NBMAX,MCMAX,NCMAX,MDMAX,NDMAX,MEMAX,NEMAX,
     1  XMAX,YMAX,CUR,IFILE,MNAMAX,MNBMAX,MNCMAX,MNDMAX,MNEMAX,NDEL,
     1  ISPLIT)
C23456789012345678901234567890123456789012345678901234567890123456789012
C
C  PURPOSE IS TO FILL THE LOAD-GEOMETRIC MATRIX FOR LINEAR BUCKLING OF PANEL
C  SKIN BETWEEN STIFFENERS. THIS SUBROUTINE IS FOR THE MARLOWE THEORY.
C
C  The theory is based on the following:
C   1. The assumed displacement field is:
C   axial displacement, u = sum-over-m{sum-over-n{A(m,n)cos(mx)sin(ny)
C                                                +D(m,n)sin(mx)sin(ny)}}
C    hoop displacement, v = sum-over-m{sum-over-n{B(m,n)sin(mx)cos(ny)
C                                                +E(m,n)sin(mx)sin(ny)}}
C  normal displacement, w = sum-over-m{sum-over-n{C(m,n)sin(mx)sin(ny)}}
C      
C   2. The work done by prebuckling in-plane loads Nxo, Nyo, Nxyo
C      during bifurcation buckling displacements (from Sanders' theory)
C      is given by:
C
C      W = 0.5*int-over-x{int-over-y{
C               Nxo[chi**2 +gamma1**2 +gamma21**2]
C              +Nyo[psi**2 +gamma2**2 +gamma12**2]
C              +Nxyo[chi*psi +gamma1*gamma12 +gamma2*gamma21}dy}dx
C
C      in which
C               chi     = w,x
C               psi     = w,y -v/R
C               gamma1  = u,x
C               gamma2  = v,y +w/R
C               gamma12 = u,y
C               gamma21 = v,x
C
C   3. We wish to express the "work done", W, in a form analogous to
C      that used for the strain energy. If we define a vector "rot"
C      with the six components,
C  
C       rot = [chi, psi, gamma1, gamma2, gamma12, gamma21]
C
C   4. then the "work done", W, is given by
C
C       W = 0.5*int-over-x{int-over-y{rot(transpose)*[N]*rot}dy}dx
C
C      in which [N] is a 6 x 6 matrix given by:
C
C                 Nxo   Nxyo  0.   0.    0.   0.
C                 
C                 Nxyo  Nyo   0.   0.    0.   0.
C
C                 0.    0.   Nxo   0.    0.  Nxyo
C 
C                 0.    0.    0.  Nyo   Nxyo  0.
C
C                 0.    0.    0.  Nxyo  Nxo   0.
C
C                 0.    0.  Nxy0   0.    0.  Nyo
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION COEFMN(2,6),COEFIJ(2,6),MNPOS(2,6),IJPOS(2,6),ITERMS(6)
      DIMENSION RESULT(6,6),ITRIG(6,2)
      DIMENSION ITRIGD(6,2),COFDMN(6),COFEMN(6),MNPOSD(6),MNPOSE(6)
      DIMENSION ITRIGE(6,2),COFDIJ(6),COFEIJ(6),IJPOSD(6),IJPOSE(6)
      DIMENSION B(MNTOT,MNTOT)
C
C     RESULT(i,j) is the 6x6 [N] matrix given in 4. above:
C
      CALL MOVER(0.,0,RESULT,1,72)
      RESULT(1,1) = FNX
      RESULT(1,2) = FNXY
      RESULT(2,1) = FNXY
      RESULT(2,2) = FNY
      RESULT(3,3) = FNX
      RESULT(3,6) = FNXY
      RESULT(4,4) = FNY
      RESULT(4,5) = FNXY
      RESULT(5,4) = FNXY
      RESULT(5,5) = FNX
      RESULT(6,3) = FNXY
      RESULT(6,6) = FNY
C     WRITE(IFILE,'(A,1P,3E12.3)')' FNX,FNY,FNXY=',FNX,FNY,FNXY
C
C     MAMAX = number of trig terms in the x-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     MDMAX = number of trig terms in the x-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     MBMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     MEMAX = number of trig terms in the x-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     MCMAX = number of trig terms in the x-coord. expansion for displ. w
C     NAMAX = number of trig terms in the y-coord. expansion for displ. u
C             (cos(mx)sin(ny) terms)
C     NDMAX = number of trig terms in the y-coord. expansion for displ. u
C             (sin(mx)sin(ny) terms)
C     NBMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)cos(ny) terms)
C     NEMAX = number of trig terms in the y-coord. expansion for displ. v
C             (sin(mx)sin(ny) terms)
C     NCMAX = number of trig terms in the y-coord. expansion for displ. w
C
      PI = 3.1415927
C     MNTOT  = rank of the load-geometric matrix 
C            = MNAMAX + MNBMAX + MNCMAX + MNDMAX + MNEMAX
C
C     ITERMS(i) = number of terms in the ith rotation expression
      ITERMS(1) = 1
      ITERMS(2) = 2
      ITERMS(3) = 1
      ITERMS(4) = 2
      ITERMS(5) = 1
      ITERMS(6) = 1
C
C     ITRIG(i,j) = i=ith rotation component
C                  j=1 means x-coord., j=2 means y-coord.
C                  ITRIG = 1 means sine, 2 means cosine, 
C
      ITRIG(1,1) = 2
      ITRIG(1,2) = 1
      ITRIG(2,1) = 1
      ITRIG(2,2) = 2
      ITRIG(3,1) = 1
      ITRIG(3,2) = 1
      ITRIG(4,1) = 1
      ITRIG(4,2) = 1
      ITRIG(5,1) = 2
      ITRIG(5,2) = 2
      ITRIG(6,1) = 2
      ITRIG(6,2) = 2
C
      IF (MNDMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGD,1,12)
C        ITRIGD(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGD(3,1) = 2
         ITRIGD(3,2) = 1
         ITRIGD(6,1) = 1
         ITRIGD(6,2) = 2
      ENDIF
      IF (MNEMAX.GT.0) THEN
         CALL MOVER(0,0,ITRIGE,1,12)
C        ITRIGE(i,j): i = strain component; j = 1 means x-coord, 2 means y
         ITRIGE(2,1) = 1
         ITRIGE(2,2) = 1
         ITRIGE(4,1) = 1
         ITRIGE(4,2) = 2
         ITRIGE(5,1) = 2
         ITRIGE(5,2) = 1
      ENDIF
C
C     COEFMN(i,j), i=1,2; j=1,6: coefficients of the undetermined
C                  coefficients, A(m,n), B(m,n), C(m,n) in the rotation
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to the rotation component.
C     MNPOS(i,j),  i=1,2; j=1,6: row or column no. in load-geometric matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C
      DO 2000 M = 1,MCMAX
        FM = FLOAT(M)*PI/XMAX
        GM = M
        NSTART = 1
        NINCR  = 1
        IF (ISPLIT.EQ.1) THEN
           NINCR = 2
           IMOD = MOD(M,2)
           IF (NDEL.EQ.1) THEN
            NSTART = 2
            IF (IMOD.EQ.0) NSTART = 1
           ELSE
            NSTART = 1
            IF (IMOD.EQ.0) NSTART = 2
           ENDIF
        ENDIF
      DO 1900 N = NSTART,NCMAX,NINCR
         FN = FLOAT(N)*PI/YMAX
         GN = N
         CALL MOVER(0.,0,COEFMN,1,24)
         CALL MOVER(0,0,MNPOS,1,12)
         COEFMN(1,1) = FM
         COEFMN(1,2) = FN
         COEFMN(2,4) = CUR
         IF (ISPLIT.EQ.1) MNPOS(1,1)  = (M/2)*(NCMAX-NDEL)/2 
     1                   +((M-1)/2)*(NCMAX+NDEL)/2 + (N+1)/2
         IF (ISPLIT.EQ.0) MNPOS(1,1) = (M-1)*NCMAX + N
         MNPOS(1,2)  = MNPOS(1,1)
         MNPOS(2,4)  = MNPOS(1,1)
         IF (N.LE.NBMAX.AND.M.LE.MBMAX) THEN
            COEFMN(2,2) = -CUR
            COEFMN(1,4) = -FN
            COEFMN(1,5) =  FM
            IF (ISPLIT.EQ.1)
     1           MNPOS(2,2)  = MNCMAX + MNAMAX +(M/2)*(NBMAX-NDEL)/2 
     1                           +((M-1)/2)*(NBMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0)
     1           MNPOS(2,2)  = MNCMAX + MNAMAX + (M-1)*NBMAX + N
            MNPOS(1,4)  = MNPOS(2,2)
            MNPOS(1,5)  = MNPOS(2,2)
         ENDIF
C23456789012345678901234567890123456789012345678901234567890123456789012
         IF (N.LE.NAMAX.AND.M.LE.MAMAX) THEN
            COEFMN(1,3) = -FM
            COEFMN(1,6) =  FN
            IF (ISPLIT.EQ.1) MNPOS(1,3)  = MNCMAX +(M/2)*(NAMAX-NDEL)/2 
     1                              +((M-1)/2)*(NAMAX+NDEL)/2 + (N+1)/2
            IF (ISPLIT.EQ.0) MNPOS(1,3)  = MNCMAX + (M-1)*NAMAX + N
            MNPOS(1,6)  = MNPOS(1,3)
         ENDIF
C        WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFMN(1,L),L=1,6=',
C    1                                  (COEFMN(1,L),L=1,6)
C        WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFMN(2,L),L=1,6=',
C    1                                  (COEFMN(2,L),L=1,6)
C  Add the "D" and "E" terms, if any:
C     COFDMN(i), i=1,6 = coefficients of the undetermined coefficients
C     D(m,n) of the u-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..6).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNDMAX.GT.0) THEN
            CALL MOVER(0.,0,COFDMN,1,12)
            CALL MOVER(0,0,MNPOSD,1,6)
            IF (M.LE.MDMAX.AND.N.LE.NDMAX) THEN
               COFDMN(3) = FM
               COFDMN(6) = FN
               IF (ISPLIT.EQ.1) MNPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           +(M/2)*(NDMAX-NDEL)/2 
     1                           +((M-1)/2)*(NDMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0) MNPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           + (M-1)*NDMAX + N
               MNPOSD(6) = MNPOSD(3)
            ENDIF
         ENDIF
C     COFEMN(i), i=1,6 = coefficients of the undetermined coefficients
C     E(m,n) of the v-disp. series expansion of the type, sin(mx)sin(ny)
C     corresponding to the ith strain/curvature component (i=1,2,..6).
C     MNPOSD(i) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
         IF (MNEMAX.GT.0) THEN
            CALL MOVER(0.,0,COFEMN,1,12)
            CALL MOVER(0,0,MNPOSE,1,6)
            IF (M.LE.MEMAX.AND.N.LE.NEMAX) THEN
               COFEMN(2) = -CUR
               COFEMN(4) = FN
               COFEMN(5) = FM
               IF (ISPLIT.EQ.1)
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(M/2)*(NEMAX-NDEL)/2 
     1                           +((M-1)/2)*(NEMAX+NDEL)/2 + (N+1)/2
               IF (ISPLIT.EQ.0)
     1                 MNPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           + (M-1)*NEMAX + N
               MNPOSE(4) = MNPOSE(2)
               MNPOSE(5) = MNPOSE(2)
            ENDIF
         ENDIF
C
C     COEFIJ(i,j), i=1,2; j=1,6: coefficients of the undetermined
C                  coefficients, A(i,j), B(i,j), C(i,j) in the rotation
C                  expressions written in terms of sines and cosines:
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C     IJPOS(i,j),  i=1,2; j=1,6: column or row no. in load-geometric matrix.
C                  First argument (i) corresponds to ith term number (ITERMS)
C                  Second argument(j) corresponds to rotation component.
C
         DO 1800 I = 1,MCMAX
           FI = FLOAT(I)*PI/XMAX
           GI = I
           JSTART = 1
           JINCR  = 1
           IF (ISPLIT.EQ.1) THEN
              JINCR = 2
              IMOD = MOD(I,2)
              IF (NDEL.EQ.1) THEN
               JSTART = 2
               IF (IMOD.EQ.0) JSTART = 1
              ELSE
               JSTART = 1
               IF (IMOD.EQ.0) JSTART = 2
              ENDIF
           ENDIF
         DO 1700 J = JSTART,NCMAX,JINCR
            FJ = FLOAT(J)*PI/YMAX
            GJ = J
            CALL MOVER(0.,0,COEFIJ,1,24)
            CALL MOVER(0,0,IJPOS,1,12)
            COEFIJ(1,1) = FI
            COEFIJ(1,2) = FJ
            COEFIJ(2,4) = CUR
            IF (ISPLIT.EQ.1) IJPOS(1,1) = (I/2)*(NCMAX-NDEL)/2 
     1                     +((I-1)/2)*(NCMAX+NDEL)/2 + (J+1)/2
            IF (ISPLIT.EQ.0) IJPOS(1,1) = (I-1)*NCMAX + J
            IJPOS(1,2)  = IJPOS(1,1)
            IJPOS(2,4)  = IJPOS(1,1)
            IF (J.LE.NBMAX.AND.I.LE.MBMAX) THEN
               COEFIJ(2,2) = -CUR
               COEFIJ(1,4) = -FJ
               COEFIJ(1,5) =  FI
               IF (ISPLIT.EQ.1)
     1           IJPOS(2,2)  = MNCMAX + MNAMAX +(I/2)*(NBMAX-NDEL)/2 
     1                           +((I-1)/2)*(NBMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0)
     1           IJPOS(2,2)  = MNCMAX + MNAMAX + (I-1)*NBMAX + J
               IJPOS(1,4)  = IJPOS(2,2)
               IJPOS(1,5)  = IJPOS(2,2)
            ENDIF
            IF (J.LE.NAMAX.AND.I.LE.MAMAX) THEN
               COEFIJ(1,3) = -FI
               COEFIJ(1,6) =  FJ
               IF (ISPLIT.EQ.1)
     1                    IJPOS(1,3)  = MNCMAX +(I/2)*(NAMAX-NDEL)/2 
     1                           +((I-1)/2)*(NAMAX+NDEL)/2 + (J+1)/2
               IF (ISPLIT.EQ.0) IJPOS(1,3)  = MNCMAX + (I-1)*NAMAX + J
               IJPOS(1,6)  = IJPOS(1,3)
            ENDIF
C           WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFIJ(1,L),L=1,6=',
C    1                                     (COEFIJ(1,L),L=1,6)
C           WRITE(IFILE,'(A,/,1P,6E12.4)')' COEFIJ(2,L),L=1,6=',
C    1                                     (COEFIJ(2,L),L=1,6)
C
C  Add the "D" and "E" terms, if any:
C     COFDIJ(k), k=1,6 = coefficients of the undetermined coefficients
C     D(i,j) of the u-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..6).
C     IJPOSD(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
C23456789012345678901234567890123456789012345678901234567890123456789012
            IF (MNDMAX.GT.0) THEN
               CALL MOVER(0.,0,COFDIJ,1,12)
               CALL MOVER(0,0,IJPOSD,1,6)
               IF (I.LE.MDMAX.AND.J.LE.NDMAX) THEN
                  COFDIJ(3) = FI
                  COFDIJ(6) = FJ
                  IF (ISPLIT.EQ.1) IJPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                           +(I/2)*(NDMAX-NDEL)/2 
     1                           +((I-1)/2)*(NDMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0) IJPOSD(3) = MNCMAX + MNAMAX + MNBMAX
     1                                         + (I-1)*NDMAX + J
                  IJPOSD(6) = IJPOSD(3)
               ENDIF
            ENDIF
C     COFEIJ(k), k=1,6 = coefficients of the undetermined coefficients
C     E(i,j) of the v-disp. series expansion of the type, sin(ix)sin(jy)
C     corresponding to the kth strain/curvature component (k=1,2,..6).
C     IJPOSE(k) = row or column number in the stiffness matrix, A(IJ,MN)
C                 or A(MN,IJ)
            IF (MNEMAX.GT.0) THEN
               CALL MOVER(0.,0,COFEIJ,1,12)
               CALL MOVER(0,0,IJPOSE,1,6)
               IF (I.LE.MEMAX.AND.J.LE.NEMAX) THEN
                  COFEIJ(2) = -CUR
                  COFEIJ(4) = FJ
                  COFEIJ(5) = FI
                  IF (ISPLIT.EQ.1)
     1                 IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                           +(I/2)*(NEMAX-NDEL)/2 
     1                           +((I-1)/2)*(NEMAX+NDEL)/2 + (J+1)/2
                  IF (ISPLIT.EQ.0)
     1                 IJPOSE(2) = MNCMAX + MNAMAX + MNBMAX + MNDMAX
     1                            + (I-1)*NEMAX + J
                  IJPOSE(4) = IJPOSE(2)
                  IJPOSE(5) = IJPOSE(2)
               ENDIF
            ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
            DO 300 IROT = 1,6
            ITIEND = ITERMS(IROT)
            DO 250 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 250
               MN = MNPOS(ITERMI,IROT)
            DO 200 JROT = 1,6
            IF (RESULT(IROT,JROT).EQ.0.) GO TO 200
            ITJEND = ITERMS(JROT)
            DO 150 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 150
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1         RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COEFIJ(ITERMJ,JROT)
C              WRITE(IFILE,'(A,/,4I3,1P,4E12.4)')
C    1       ' IROT,JROT,ITERMI,ITERMJ,COEF,RESULT,COEFMN,COEFIJ=',
C    1         IROT,JROT,ITERMI,ITERMJ,COEF,RESULT(IROT,JROT),
C    1                   COEFMN(ITERMI,IROT),COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 150
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,M,I,XINTEG=',IROT,JROT,M,I,XINTEG
                  GO TO 10
               ELSE
                  IMOD = MOD(M-I,2)
C                 WRITE(IFILE,'(A,7I3)') 
C    1             ' M,I,N,J,IMOD,ITRIG(IROT,1),ITRIG(JROT,1)=',
C    1               M,I,N,J,IMOD,ITRIG(IROT,1),ITRIG(JROT,1)
                  IF (IMOD.EQ.0) GO TO 150
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,M,I,XINTEG=',IROT,JROT,M,I,XINTEG
               ENDIF
   10          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 150
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,N,J,YINTEG,=',IROT,JROT,N,J,YINTEG
                  GO TO 20
               ELSE
                  IMOD = MOD(N-J,2)
C                 WRITE(IFILE,'(A,7I3)') 
C    1             ' M,I,N,J,IMOD,ITRIG(IROT,2),ITRIG(JROT,2)=',
C    1               M,I,N,J,IMOD,ITRIG(IROT,2),ITRIG(JROT,2)
                  IF (IMOD.EQ.0) GO TO 150
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
C                 WRITE(IFILE,'(A,4I3,1P,E12.4)')
C    1          ' IROT,JROT,N,J,YINTEG,=',IROT,JROT,N,J,YINTEG
               ENDIF
   20          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into load-geometric matrix, B:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
C              WRITE(IFILE,'(A,2I4,1P,3E12.4)')
C    1       ' MN,IJ,B(MN,IJ),FINTEG,COEF=',MN,IJ,B(MN,IJ),FINTEG,COEF
  150       CONTINUE
  200       CONTINUE
  250       CONTINUE
  300       CONTINUE
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 400 IROT = 1,6
            ITIEND = ITERMS(IROT)
            DO 350 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 350
               MN = MNPOS(ITERMI,IROT)
            DO 325 JROT = 1,6
               IF (RESULT(IROT,JROT).EQ.0.0) GO TO 325
               IF (COFDIJ(JROT).EQ.0.0) GO TO 325
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 310
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  310          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 325
                  ENDIF
                  GO TO 320
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 325
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  320          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  325       CONTINUE
  350       CONTINUE
  400       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients A, B, C, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 500 IROT = 1,6
            ITIEND = ITERMS(IROT)
            DO 450 ITERMI = 1,ITIEND
               IF (COEFMN(ITERMI,IROT).EQ.0.0) GO TO 450
               MN = MNPOS(ITERMI,IROT)
            DO 425 JROT = 1,6
               IF (RESULT(IROT,JROT).EQ.0.0) GO TO 425
               IF (COFEIJ(JROT).EQ.0.0) GO TO 425
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COEFMN(ITERMI,IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIG(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 410
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  410          CONTINUE
C
               YINTEG = 0.
               IF (ITRIG(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 425
                  ENDIF
                  GO TO 420
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 425
                  IF (ITRIG(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  420          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  425       CONTINUE
  450       CONTINUE
  500       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNDMAX.GT.0) THEN
            DO 600 IROT = 1,6
               IF (COFDMN(IROT).EQ.0.0) GO TO 600
               MN = MNPOSD(IROT)
            DO 550 JROT = 1,6
            ITJEND = ITERMS(JROT)
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 550
            DO 525 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 525
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 510
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  510          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 525
                  ENDIF
                  GO TO 520
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 525
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  520          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  525       CONTINUE
  550       CONTINUE
  600       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients A, B, C:
C
          IF (MNEMAX.GT.0) THEN
            DO 700 IROT = 1,6
               IF (COFEMN(IROT).EQ.0.0) GO TO 700
               MN = MNPOSE(IROT)
            DO 650 JROT = 1,6
            ITJEND = ITERMS(JROT)
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 650
            DO 625 ITERMJ = 1,ITJEND
               IF (COEFIJ(ITERMJ,JROT).EQ.0.0) GO TO 625
               IJ = IJPOS(ITERMJ,JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COEFIJ(ITERMJ,JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIG(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 610
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIG(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  610          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIG(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 625
                  ENDIF
                  GO TO 620
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 625
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIG(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  620          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  625       CONTINUE
  650       CONTINUE
  700       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0) THEN
            DO 800 IROT = 1,6
               IF (COFDMN(IROT).EQ.0.0) GO TO 800
               MN = MNPOSD(IROT)
            DO 750 JROT = 1,6
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 750
               IF (COFDIJ(JROT).EQ.0.0) GO TO 750
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 710
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  710          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 750
                  ENDIF
                  GO TO 720
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 750
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  720          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  750       CONTINUE
  800       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients D, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 900 IROT = 1,6
               IF (COFDMN(IROT).EQ.0.0) GO TO 900
               MN = MNPOSD(IROT)
            DO 850 JROT = 1,6
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 850
               IF (COFEIJ(JROT).EQ.0.0) GO TO 850
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFDMN(IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGD(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 810
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  810          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGD(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 850
                  ENDIF
                  GO TO 820
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 850
                  IF (ITRIGD(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  820          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  850       CONTINUE
  900       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients D:
C
          IF (MNDMAX.GT.0.AND.MNEMAX.GT.0) THEN
            DO 1000 IROT = 1,6
               IF (COFEMN(IROT).EQ.0.0) GO TO 1000
               MN = MNPOSE(IROT)
            DO 950 JROT = 1,6
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 950
               IF (COFDIJ(JROT).EQ.0.0) GO TO 950
               IJ = IJPOSD(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COFDIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIGD(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 910
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIGD(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
  910          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIGD(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 950
                  ENDIF
                  GO TO 920
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 950
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIGD(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
  920          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
  950       CONTINUE
 1000       CONTINUE
          ENDIF
C
C  Next, process the IROT terms corresponding to the
C  undetermined coefficients E, and
C  Process the JROT terms corresponding to the
C  undetermined coefficients E:
C
          IF (MNEMAX.GT.0) THEN
            DO 1100 IROT = 1,6
               IF (COFEMN(IROT).EQ.0.0) GO TO 1100
               MN = MNPOSE(IROT)
            DO 1050 JROT = 1,6
            IF (RESULT(IROT,JROT).EQ.0.0) GO TO 1050
               IF (COFEIJ(JROT).EQ.0.0) GO TO 1050
               IJ = IJPOSE(JROT)
               COEF = 
     1           RESULT(IROT,JROT)*COFEMN(IROT)*COFEIJ(JROT)
C     Find integrals:
               XINTEG = 0.
               IF (ITRIGE(IROT,1).EQ.ITRIGE(JROT,1)) THEN
                  IF (M.EQ.I) THEN
                     XINTEG = 0.5*XMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1010
               ELSE
                  IMOD = MOD(M-I,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IROT,1).EQ.1.AND.ITRIGE(JROT,1).EQ.2) THEN
                     XINTEG = (1./(GM-GI) + 1./(GM+GI))*XMAX/PI
                  ELSE
                     XINTEG = (1./(GI-GM) + 1./(GI+GM))*XMAX/PI
                  ENDIF
               ENDIF
 1010          CONTINUE
C
               YINTEG = 0.
               IF (ITRIGE(IROT,2).EQ.ITRIGE(JROT,2)) THEN
                  IF (N.EQ.J) THEN
                     YINTEG = 0.5*YMAX
                  ELSE
                     GO TO 1050
                  ENDIF
                  GO TO 1020
               ELSE
                  IMOD = MOD(N-J,2)
                  IF (IMOD.EQ.0) GO TO 1050
                  IF (ITRIGE(IROT,2).EQ.1.AND.ITRIGE(JROT,2).EQ.2) THEN
                     YINTEG = (1./(GN-GJ) + 1./(GN+GJ))*YMAX/PI
                  ELSE
                     YINTEG = (1./(GJ-GN) + 1./(GJ+GN))*YMAX/PI
                  ENDIF
               ENDIF
 1020          CONTINUE
               FINTEG = XINTEG*YINTEG
C     Put contribution into stiffness matrix, A:
               B(MN,IJ) = B(MN,IJ) + FINTEG*COEF
               B(IJ,MN) = B(IJ,MN) + FINTEG*COEF
 1050       CONTINUE
 1100       CONTINUE
          ENDIF
C
 1700    CONTINUE
 1800    CONTINUE
 1900 CONTINUE
 2000 CONTINUE
C
      IF (MNTOT.LE.0) THEN
        WRITE(IFILE,60)
   60   FORMAT(/' LOAD-GEOMETRIC MATRIX, B:',/,
     1' B(I,1)   B(I,2)   B(I,3)   B(I,4)   B(I,5)   B(I,6)   B(I,7)  ',
     1' B(I,8)   B(I,9)   B(I,10)  B(I,11)  B(I,12)')
        DO 70 I = 1,MNTOT
         WRITE(IFILE,65) (B(I,J),J=1,MNTOT)
   65    FORMAT(1P12E9.2)
   70   CONTINUE
      ENDIF
C
      RETURN
      END       
C
C
C
C=DECK$F77               GSEIG
      SUBROUTINE GSEIG (n, a, b, e, x, w, ipri)
C
      implicit double precision (a-h,o-z)
C+---------------------------------------------------------------------+
C|                                                                     |
C|    solve the small, full, generalized, symmetric eigenproblem       |
C|                                                                     |
C|             {[a] - lambda * [b]} (x) = 0                            |
C|                                                                     |
C|    a generalized Jacobi Iteration is simultaneously applied         |
C|    to [a] and [b] until they are diagonalized.  the process will    |
C|    fail if and only if the given problem has complex eigenvalues.   |
C|                                                                     |
C+---------------------------------------------------------------------+
C|    the calling sequence is:                                         |
C|                                                                     |
C|        call   GSEIG (n, a, b, e, x, w, ipri)  -or-                  |
C|                                                                     |
C|        call  DGSEIG (n, a, b, e, x, w, ipri)                        |
C|                                                                     |
C|    where (n) is the problem size.  the remaining arguments are      |
C|    are floating point (real or double precision throughout).        |
C|                                                                     |
C|    arrays interpreted as follows                                    |
C|                                                                     |
C|    input arguments                                                  |
C|                                                                     |
C|     a,b    full, symmetric matrices defining the problem            |
C|            the contents of these arrays are changed by GSEIG        |
C|      w     workspace vector (size n)                                |
C|     ipri   print parameter (0 = none, 1 = minimal, 2 = full)        |
C|                                                                     |
C|    output arguments                                                 |
C|                                                                     |
C|      e     vector of eigenvalues                                    |
C|      x     matrix of eigenvectors                                   |
C|                                                                     |
C|    this routine is applicable only to problems that have real       |
C|    eigenvalues.  if a problem has complex eigenvalues, jgl is       |
C|    set to -1 to indicate the program failure.                       |
C|                                                                     |
C|    if the i-th eigenvalue is infinite, the results will show        |
C|                                                                     |
C|         a(i,i) .ne. 0                                               |
C|         b(i,i) .eq. 0                                               |
C|         e(i)    =   1.0e+30                                         |
C|                                                                     |
C|    the lower triangular parts of [a] and [b] are ignored.           |
C|                                                                     |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        ipri
      dimension     a(n,n),   b(n,n),   e(n),     x(n,n),   w(n)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      logical       print
      character*6   name
      dimension     al(3),    bl(3),    xl(4)
C
      external      DSCAL,    DASUM,    DCOPY,    DGROT,    DAXPY
C+---------------------------------------------------------------------+
C|                  D A T A                                            |
C+---------------------------------------------------------------------+
      data          mxs   /      50 /
      data          tfb   / 1.0d-02 /
      data          zer   / 0.0d+00 /
      data          one   / 1.0d+00 /
      data          big   / 1.0d+30 /
      data          eps   / 1.0d-16 /
      data          name  / 'DGSEIG' /
      data          print /  .TRUE. /
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      if (ipri .gt. 0)                 then
        WRITE(8,4000) name, n
      endif
C
      if (n .lt. 1)                    then
        if (print) WRITE(8,3000) name, n
        return
      endif
C+---------------------------------------------------------------------+
C|    n  =  1  case                                                    |
C+---------------------------------------------------------------------+
      if (n .eq. 1)                    then
        alf     =  one
        bet     =  one
        x(1,1)  =  one
        go to 160
      endif
C+---------------------------------------------------------------------+
C|    n  .gt.  1  case                                                 |
C+---------------------------------------------------------------------+
      if (ipri .gt. 2)                 then
        WRITE(8,4001) (i, a(i,i), b(i,i), i=1,n)
      endif
C
      np1   =  n + 1
      nsq   =  n * n
      ith   =  6
      fn    =  DBLE (n)
C
      call     DCOPY (nsq, zer, 0, x,   1)
      call     DCOPY (n,   one, 0, x, np1)
C+---------------------------------------------------------------------+
C|    scale  a  and  b  to have a unit average diagonal                |
C+---------------------------------------------------------------------+
      alf   =  DASUM (n, a, np1)
      bet   =  DASUM (n, b, np1)
C
      if (ipri .gt. 0)                 then
        WRITE(8,4002) alf, bet
      endif
C
      if (alf .eq. zer)                alf = fn
      if (bet .eq. zer)                bet = fn
      call     DSCAL (nsq, fn/alf, a, 1)
      call     DSCAL (nsq, fn/bet, b, 1)
C
      nz    =  0
      nr    =  0
      tf    =  tfb / nsq
C+---------------------------------------------------------------------+
C|    iteration loop                                                   |
C+---------------------------------------------------------------------+
      if (ipri .gt. 1)                 then
        WRITE(8,4003)
      endif
C
      do 140 loop = 1,mxs
        ith   =  ith - 1
        off   =  zer
        call     DCOPY (n, zer, 0, e, 1)
        call     DCOPY (n, zer, 0, w, 1)
        do 100 j = 2,n
          off =  off + DASUM (j-1,a(1,j),1)
     $               + DASUM (j-1,b(1,j),1)
  100   continue
C
        if (off .le. eps)              go to 160
C+---------------------------------------------------------------------+
C|      off diagonal sweep                                             |
C+---------------------------------------------------------------------+
        thr   =  tf * off
C
        if (ipri .gt. 1)               then
          WRITE(8,4004) ith, off, tf, thr
        endif
C
        do 130 j = 2,n
          jm1  =  j-1
C
          do 120 i = 1,jm1
            iwh   = -1
C
            if (ith .gt. 0)            then
              t   =  ABS(a(i,j)) + ABS(b(i,j))
              if (t .le. thr)          go to 120
            endif
C
            al(1)   =  a(i,i) + e(i)
            al(2)   =  a(i,j)
            al(3)   =  a(j,j) + e(j)
C
            bl(1)   =  b(i,i) + w(i)
            bl(2)   =  b(i,j)
            bl(3)   =  b(j,j) + w(j)
C
            xl(1)   =  al(1)*bl(2) - bl(1)*al(2)
            xl(2)   =  al(1)*bl(3) - bl(1)*al(3)
            xl(3)   =  al(2)*bl(3) - bl(2)*al(3)
C+---------------------------------------------------------------------+
C|                                                                     |
C+---------------------------------------------------------------------+
  110       xl(1)   =  xl(1) + xl(1)
            xl(3)   =  xl(3) + xl(3)
            xl(4)   =  xl(2)**2 - xl(1)*xl(3)
C
            a(i,j)  =  zer
            b(i,j)  =  zer
C
            if (xl(4) .lt. zer)        then
              if (print) WRITE(8,3001) name, loop, i, j
              go to 150
            endif
C
            if (xl(4) .eq. zer)        then
              nz    =  nz + 1
              if     (iwh .lt. 0)      then
                iwh     =  0
                xl(1)   = -al(2)
                xl(2)   =  al(1) - al(3)
                xl(3)   =  al(2)
                go to 110
              elseif (iwh .eq. 0)      then
                iwh     =  1
                xl(1)   = -bl(2)
                xl(2)   =  bl(1) - bl(3)
                xl(3)   =  bl(2)
                go to 110
              elseif (iwh .gt. 0)      then
                go to 120
              endif
            endif
C
            xl(4)   =  SQRT(xl(4))
C
            if (xl(2) .lt. zer)        then
              t     =  xl(2) - xl(4)
            else
              t     =  xl(2) + xl(4)
            endif
C
            xl(4)   =  t * t
            t1      =  t + t
            al(2)   =  t1*al(2)
            bl(2)   =  t1*bl(2)
            t1      =  one / (xl(4) + xl(1)**2)
            t2      =  one / (xl(4) + xl(3)**2)
            al(3)   =  al(1) - al(3)
            bl(3)   =  bl(1) - bl(3)
            al(1)   = -xl(1)*(al(2) + xl(1)*al(3)) * t1
            al(3)   = -xl(3)*(al(2) - xl(3)*al(3)) * t2
            bl(1)   = -xl(1)*(bl(2) + xl(1)*bl(3)) * t1
            bl(3)   = -xl(3)*(bl(2) - xl(3)*bl(3)) * t2
            t1      =  SQRT(t1)
            xl(2)   = -t1*xl(1)
            xl(1)   =  t1*t
            t2      =  SQRT(t2)
            xl(3)   = -t2*xl(3)
            xl(4)   =  t2*t
            e(i)    =  e(i) + al(1)
            e(j)    =  e(j) + al(3)
            w(i)    =  w(i) + bl(1)
            w(j)    =  w(j) + bl(3)
C
            if ((xl(2)+xl(1) .eq. xl(1)) .and.
     $          (xl(3)+xl(4) .eq. xl(4))      )  go to 120
C
            nr      =  nr + 1
            ln      =  i  - 1
            if (ln .gt. 0)             then
              call     DGROT (ln, xl, a(1,i), 1, a(1,j), 1)
              call     DGROT (ln, xl, b(1,i), 1, b(1,j), 1)
            endif
C
            ln      =  j - i - 1
            if (ln .gt. 0)             then
              k     =  i + 1
              call     DGROT (ln, xl, a(i,k), n, a(k,j), 1)
              call     DGROT (ln, xl, b(i,k), n, b(k,j), 1)
            endif
C
            ln      =  n - j
            if (ln .gt. 0)             then
              k     =  j + 1
              call     DGROT (ln, xl, a(i,k), n, a(j,k), n)
              call     DGROT (ln, xl, b(i,k), n, b(j,k), n)
            endif
C
            call     DGROT (n,  xl, x(1,i), 1, x(1,j), 1)
C
  120     continue
  130   continue
C
        call     DAXPY (n, one, e, 1, a, np1)
        call     DAXPY (n, one, w, 1, b, np1)
C
  140 continue
C+---------------------------------------------------------------------+
C|    error exits                                                      |
C+---------------------------------------------------------------------+
  145 WRITE(8,3002) name
      go to 155
  150 WRITE(8,3003) name
C
  155 n     = -n
      if (print) WRITE(8,3004) al, bl, xl(1), xl(3), xl(2), xl(4)
      go to 200
C+---------------------------------------------------------------------+
C|    determine the eigenvalues                                        |
C+---------------------------------------------------------------------+
  160 b(1,2)  =  fn / bet
      bet     =  alf / bet
C
      if (ipri .gt. 0)                 then
        WRITE(8,4005) alf, bet
      endif
C
      if (ipri .gt. 2)                 then
        WRITE(8,4006)
      endif
C
      do 170 i = 1,n
C
        if (ipri .gt. 2)               then
          WRITE(8,4007) i, a(i,i), b(i,i)
        endif
C
        if (b(i,i) .eq. zer)           then
          e(i)    =  big
        else
          a(i,i)  =  bet * a(i,i)
          e(i)    =  a(i,i) / b(i,i)
        endif
C BEG DEC 2003
        if (dabs(e(i)).gt.big) e(i) = big
C END DEC 2003
  170 continue
C
      if (ipri .gt. 2)                 then
        WRITE(8,4008) (i, e(i), i=1,n)
      endif
C
      return
C+---------------------------------------------------------------------+
C|    error exits                                                      |
C+---------------------------------------------------------------------+
  200 if (print) WRITE(8,3005) n, loop, nr, nz
      return
C+---------------------------------------------------------------------+
C|    format statements                                                |
C+---------------------------------------------------------------------+
 3000 format (/5X,A6,'  input (n) .lt. 1,   n = ',I5/)
 3001 format (/5X,A6,'  stop in loop = ',I3,' at (i,j) = ',2I4/)
 3002 format (/5X,A6,'  did not converge'/)
 3003 format (/5X,A6,'  stop, eigenvalues are complex'/)
 3004 format (/5X,'2 x 2  a(-,-), b(-,-) and x(-,-) matrices',
     $        2(/4X,1PE15.6/4X,2E15.6/)/(4X,2E15.6))
 3005 format (/5X,'n    = ',I5,'   loop = ',I5,
     $        /5X,'nr   = ',I5,'   nz   = ',I5/)
C
 4000 format (//5X,'====  debug print outs from ',A,'  ====',
     $        //5X,'      input matrix size (n) = ',i6//)
 4001 format (//5X,'diagonal elements of input matrices are',
     $        //9X,'i',7X,'a(i,i)',9X,'b(i,i)',
     $        //(5X,i5,1p2e15.6))
 4002 format (//4X,'==== Initial Scale Factors ===='
     $        //4X,'alf  =  ',1pe15.6,
     $         /4X,'bet  =  ',e15.6/)
 4003 format (//5X,'begining iteration loop to find eigenvalues'
     $         /5X,'==========================================='/)
 4004 format ( /4X,'ith  =  ',i5,
     $        //4X,'off  =  ',1pe15.6,
     $         /4X,' tf  =  ',e15.6,
     $         /4X,'thr  =  ',e15.6)
 4005 format (//4X,'==== FINAL RESULTS  ===='
     $         /4X,'alf  =  ',e15.6,
     $         /4X,'bet  =  ',e15.6)
 4006 format (//5X,'diagonal elements of final matrices are',
     $        //9X,'i',7X,'a(i,i)',9X,'b(i,i)'/)
 4007 format (5X,i5,1p2e15.6)
 4008 format (//5X,'eigenvalues are given by',
     $        //9X,'i',7X,'eigval'//(5X,i5,1pe15.6))
      end
C
C
C
C=DECK$F77               DSCAL
      subroutine    DSCAL (n, a, x, incx)
C+---------------------------------------------------------------------+
C|    this routine scales the vector  x(-)  by  a                      |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        incx
      double precision        a,        x(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        ns
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      if (n .le. 0)                    return
C
      if (incx .eq. 0)                 go to 20
C+---------------------------------------------------------------------+
C|    code for increments not equal to 1                               |
C+---------------------------------------------------------------------+
      ns    =  n * incx
C
      do 10 i = 1,ns,incx
        x(i)  =  a * x(i)
   10 continue
C
      go to 30
C+---------------------------------------------------------------------+
C|    code for increments equal to 1                                   |
C+---------------------------------------------------------------------+
   20 x(1)  =  a * x(1)
C
   30 return
      end
C
C
C
C=DECK$F77               DGROT
      subroutine    DGROT (n, r, u, iu, v, iv)
C+---------------------------------------------------------------------+
C|    this routine performs the (2x2) rotation (r) on the two          |
C|    vectors  u(-) and  v(-)                                          |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        iu,       iv
      double precision        r(4),     u(*),     v(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        lu,       lv,       nm1
      double precision        tem
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      if (n .le. 0)                    return
C
      nm1   =  n - 1
      lu    =  MAX (1, 1-nm1*iu)
      lv    =  MAX (1, 1-nm1*iv)
C
      do 10 i = 1,n
        tem   =  u(lu)*r(1) + v(lv)*r(2)
        v(lv) =  u(lu)*r(3) + v(lv)*r(4)
        u(lu) =  tem
        lu    =  lu + iu
        lv    =  lv + iv
   10 continue
C
      return
      end
C
C
C
C=DECK$F77               DDOT
      double precision function  DDOT (n, x, incx, y, incy)
C+---------------------------------------------------------------------+
C|    this routine performs the dot product of  x(-)  and  y(-)        |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        incx,     incy
      double precision        x(n),     y(n)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        ix,       iy
      double precision        sum
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      sum   =  0.0d+00
      if (n .le. 0)                    go to 40
C
      if (incx .eq. incy)              go to 20
C+---------------------------------------------------------------------+
C|    code for unequal or nonpositive increments                       |
C+---------------------------------------------------------------------+
      ix    =  1
      iy    =  1
      if (incx .lt. 0)                 ix = (-n+1)*incx + 1
      if (incy .lt. 0)                 iy = (-n+1)*incy + 1
C
      do 10 i = 1,n
        sum   =  sum + x(ix) * y(iy)
        ix    =  ix   + incx
        iy    =  iy   + incy
   10 continue
C
      go to 40
C+---------------------------------------------------------------------+
C|    code for positive equal increments .ne. 1                        |
C+---------------------------------------------------------------------+
   20 if (incx .eq. 0)                then
        sum  =  x(1) * y(1)
        go to 40
      endif
C
      ns    =  n * incx
C
      do 30 i = 1,ns,incx
        sum   =  sum + x(i) * y(i)
   30 continue
C
   40 DDOT  =  sum
C
      return
      end
C
C
C
C=DECK$F77               DCOPY
      subroutine    DCOPY (n, a, inca, b, incb)
C+---------------------------------------------------------------------+
C|    this routine copies elements of the vector  a(-)  into the       |
C|    elements of the vector  b(-),  where the elements are            |
C|    determined by the increments  inca  and incb  respectively.      |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        inca,     incb
      double precision        a(*),     b(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        ia,       ib
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      if (inca .eq. incb)              go to 20
C+---------------------------------------------------------------------+
C|    code for nonequal or nonpositive increments.                     |
C+---------------------------------------------------------------------+
      ia    =  1
      ib    =  1
C
      do 10 i = 1,n
        b(ib) =  a(ia)
        ia    =  ia + inca
        ib    =  ib + incb
   10 continue
C
      go to 40
C+---------------------------------------------------------------------+
C|    code for both increments equal                                   |
C+---------------------------------------------------------------------+
   20 if (inca .eq. 0)                 then
        b(1)  =  a(1)
        go to 40
      endif
C
      do 30 i = 1,n,inca
        b(i)  =  a(i)
   30 continue
C
   40 return
      end
C
C
C
C=DECK$F77               DASUM
       double precision function DASUM (n, a, inc)
C+---------------------------------------------------------------------+
C|    this routine obtains the absolute value summation of  a(-)       |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        inc
      double precision        a(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        ix
      double precision        sum
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      sum   =  0.0d+00
C
      if (inc .eq. 0)                  go to 20
      if (inc .gt. 0)                  go to 30
C+---------------------------------------------------------------------+
C|    code for negative increments                                     |
C+---------------------------------------------------------------------+
      ix  =  1
      if (inc .lt. 0)                  ix = 1 + (1-n)*inc
C
      do 10 i = 1, n
        sum   =  sum + ABS (a(ix))
        ix    =  ix  + inc
 10   continue
C
      go to 50
C+---------------------------------------------------------------------+
C|    code for zero increment                                          |
C+---------------------------------------------------------------------+
   20 sum   =  ABS (a(1))
C
      go to 50
C+---------------------------------------------------------------------+
C|    code for positive increments                                     |
C+---------------------------------------------------------------------+
   30 ns    =  n * inc
C
      do 40 i = 1,ns,inc
        sum   =  sum + ABS (a(i))
   40 continue
C
   50 DASUM   =  sum
C
      return
      end
C
C
C
C=DECK$F77               DAMAX
      double precision function DAMAX (n, a, inc)
C+---------------------------------------------------------------------+
C|    this routine obtains the absolute maximum value in  a(-)         |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        inc
      double precision        a(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      integer       i,        ix
      double precision        amax
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      amax  =  0.0d+00
C
      if (inc .eq. 0)                  go to 20
      if (inc .gt. 0)                  go to 30
C+---------------------------------------------------------------------+
C|    code for negative increments                                     |
C+---------------------------------------------------------------------+
      ix  =  1
      if (inc .lt. 0)                  ix = 1 + (1-n)*inc
C
      do 10 i = 1, n
        amax  =  MAX(amax, ABS(a(ix)))
        ix    =  ix  + inc
 10   continue
C
      go to 50
C+---------------------------------------------------------------------+
C|    code for zero increment                                          |
C+---------------------------------------------------------------------+
   20 amax  =  ABS(a(1))
C
      go to 50
C+---------------------------------------------------------------------+
C|    code for positive increments                                     |
C+---------------------------------------------------------------------+
   30 ns    =  n * inc
C
      do 40 i = 1,ns,inc
        amax  =  MAX(amax, ABS(a(i)))
   40 continue
C
   50 DAMAX   =  amax
C
      return
      end
C
C
C
C=DECK$F77               DAXPY
      subroutine    DAXPY (n, a, x, incx, y, incy)
C+---------------------------------------------------------------------+
C|    this routine performs the accumulative proiduct/sum operation    |
C|                                                                     |
C|         y(i)  =  y(i)  +  a * x(i)                                  |
C|                                                                     |
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C|                  A R G U M E N T S                                  |
C+---------------------------------------------------------------------+
      integer       n,        incx,     incy
      double precision        a,        x(*),     y(*)
C+---------------------------------------------------------------------+
C|                  L O C A L   V A R I A B L E S                      |
C+---------------------------------------------------------------------+
      double precision        zer
C+---------------------------------------------------------------------+
C|                  D A T A                                            |
C+---------------------------------------------------------------------+
      data          zer / 0.0d+00 /
C+---------------------------------------------------------------------+
C|                  L O G I C                                          |
C+---------------------------------------------------------------------+
      if ((n .le.   0) .or.
     $    (a .eq. zer)     )           return
C
      if (incx .eq. incy)              go to 20
C+---------------------------------------------------------------------+
C|    code for nonequal or nonpositive increments                      |
C+---------------------------------------------------------------------+
      ix    =  1
      iy    =  1
      if (incx .lt. 0)                 ix = (-n+1)*incx + 1
      if (incy .lt. 0)                 iy = (-n+1)*incy + 1
C
      do 10 i = 1,n
        y(iy) =  y(iy) + a * x(ix)
        ix    =  ix    + incx
        iy    =  iy    + incy
   10 continue
C
      go to 40
C+---------------------------------------------------------------------+
C|    code for positive equal increments                               |
C+---------------------------------------------------------------------+
   20 if (incx .eq. 0)               then
        y(1)  =  y(1) + a * x(1)
        go to 40
      endif
C
      ns    =  n * incx
C
      do 30 i = 1,ns,incx
        y(i)  =  y(i) + a * x(i)
   30 continue
C
   40 return
      end
C
C
C
C=DECK      RAYQUO
      SUBROUTINE RAYQUO(N,PHI,A,B,EIG)
C
C  Purpose is to obtain the Rayleigh Quotient,
C
C                        PHI(transpose)*A*PHI
C      eigenvalue, EIG = --------------------
C                        PHI(transpose)*B*PHI
C  in which:
C
C    PHI = the current estimate of the critical buckling mode shape.
C      A = the stiffness matrix.
C      B = the load-geometric matrix.
C      N = the system rank.
C    EIG = the critical eigenvalue
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C BEG JAN 2005
C     DIMENSION PHI(*),V(300),A(N,N),B(N,N)
      DIMENSION PHI(*),V(400),A(N,N),B(N,N)
C END JAN 2005
C
   10 CONTINUE
      DO 100 I = 1,N
      V(I) = 0.
      DO  90 J = 1,N
      V(I) = V(I) + A(I,J)*PHI(J)
   90 CONTINUE
  100 CONTINUE
C
      SUMNUM = 0.
      DO 110 I = 1,N
      SUMNUM = SUMNUM + PHI(I)*V(I)
  110 CONTINUE
C
      DO 200 I = 1,N
      V(I) = 0.
      DO 190 J = 1,N
      V(I) = V(I) + B(I,J)*PHI(J)
  190 CONTINUE
  200 CONTINUE
C
      SUMDEN = 0.
      DO 210 I = 1,N
      SUMDEN = SUMDEN + PHI(I)*V(I)
  210 CONTINUE
C
      EIG = ABS(SUMNUM/SUMDEN)
C
      RETURN
      END
