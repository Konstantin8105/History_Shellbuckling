/*
blowup: Scales an entire plot.  Acts on all features of each frame in a series
of plots, location of physical origins, page border, and all symbols and
lettering.  Each call to blowup is cumulative.  i.e. each call to blowup
multiplies the current scale factor by the new scale factor.  The origin
is also scaled accordingly.
*/
void blowup_(_float_ *xyfac)
/*
Arguments:	*xyfac - scale factor >0.0 by which plot is scaled.
*/
{

  if (level != 1) {
    derror("Level must be 1.  Routine: blowup", FATAL);
    return;
  }

  plot.sf = *xyfac * plot.sf;
  o.x *= plot.sf;
  o.y *= plot.sf;

  fprintf(fp, "%%\n%% Set plot scale factor.\n");
  fprintf(fp, "%f %f scale\n", *xyfac, *xyfac);
}

/*
bshift: Sets the base shift in inches from the physical origin, regardless
of plot scale factor.
*/
void bshift_(_float_ *xadd, _float_ *yadd)
/*
Arguments:	*xadd - translation in x direction
		*yadd - translation in y direction
*/
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2 or 3.  Routine: bshift", !FATAL);
    return;
  }

#if DEBUG
  fprintf(stderr, "origin before shift: (%f, %f)\n", o.x, o.y);
#endif
  o.x += *xadd;
  o.y += *yadd;
#if DEBUG
  fprintf(stderr, "origin after shift: (%f, %f)\n", o.x, o.y);
#endif

  fprintf(fp, "%%\n%% Perform plot translation.\n");
  fprintf(fp, "%.2f %.2f translate\n", *xadd/plot.sf*DPI, *yadd/plot.sf*DPI);

}

/*
chndot: issues the PS command to set the trace line-style to dash-dot.
*/
void chndot_(void)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: chndot", !FATAL);
    return;
  }

  fprintf(fp, "%%\n%% set line style to dash-dot\n");
  fprintf(fp, "[%d %d %d %d] 0 setdash]\n", DASHLEN,
                                            3*SPCLEN,
                                            DOTLEN,
                                            3*SPCLEN);
  fprintf(fp, "%d setlinecap\n", ButtCap);

  pointset = 0;

  if (markr > 0)
    plot.lineStyle[markr] = CHNDOT;
}

/*
chndsh: issues the PS command to set the trace line-style to int dash
 - short dash.
*/
void chndsh_(void)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: chndsh", !FATAL);
    return;
  }

  fprintf(fp, "%%\n%% set line style to intdash-shortdash.\n");
  fprintf(fp, "[%d %d %d %d] 0 setdash\n", LDASHLEN,
                                           3*SPCLEN,
                                           SDASHLEN,
                                           3*SPCLEN);
  fprintf(fp, "%d setlinecap\n", ButtCap);

  pointset = 0;

  if (markr > 0)
    plot.lineStyle[markr] = CHNDSH;
}

/*
comprs: opens the PS output file, for writing.  Also sets the fonts.  
*/
void comprs_(void)
{

char date[DATELEN], hostname[MAXHOSTNAMELEN], *username;
_int_ status; 
_int_ hostlen=MAXHOSTNAMELEN;

#if (!_hp700_)
time_t *tp;
struct passwd *pw;
#endif

  if (level != 0) {
    derror("Level must be 0.  Routine: comprs", FATAL);
    return;
  }

  if (!eps)
    fp = stdout;

#if (!_hp700_)
/* Get user name. */
  if ((username = (char *) getlogin()) == NULL) {
    pw = getpwuid(getuid());
    username = pw->pw_name;
  }

/* Get host name. */
  if (gethostname(hostname, hostlen))
    derror("Could not read hostname.", !FATAL);

/* Figure out local time. */
  tp = (time_t *) malloc(sizeof (time_t) );
  time(tp);
  strcpy(date, ctime(tp));
  free((struct timeval *) tp);


#endif

/* Print out header information.  */
  fprintf(fp, "%%!PS-Adobe-1.0\n");
  fprintf(fp, "%%%%DocumentFonts: %s %s\n", Helvetica, TimesBold);
  fprintf(fp, "%%%%Title: %s\n", "PostScript X-Y plot generated by plotps");
#if (_hp700_)
  fprintf(fp, "%%%%Creator: Not provided.\n");
  fprintf(fp, "%%%%CreationDate: Not provided.\n");
#else
  fprintf(fp, "%%%%Creator: %s@%s\n", username, hostname);
  fprintf(fp, "%%%%CreationDate: %s", date);
#endif
  fprintf(fp, "%%%%Pages: (atend)\n");
  fprintf(fp, "%%%%BoundingBox: (atend)\n");
  fprintf(fp, "%%%%EndComments\n");

  fprintf(fp, "%%\n%% PostScript output from the abridged Disspla library\n%%\n");
  fprintf(fp, "%%\n%%-------------------- Begin Prolog ---------------------\n%%\n");

  define_aliases();
  define_fonts();
  define_markers();

  fprintf(fp, "%%\n%%-------------------- End Prolog -----------------------\n%%\n");
  fprintf(fp, "%%%%EndProlog\n");
  fprintf(fp, "%%\n%%-------------------- Begin Script ---------------------\n%%\n");

/* Initialize certain elements of the static structures. */
  initstruct();
  plot.border = TRUE;
  plot.customleg = FALSE;
  plot.sf = 1.0;
  plot.linethick = TraceLineWidth;
  o.x = 0.0;
  o.y = 0.0;
  bb.left = 8.5;
  bb.bottom = 11.0;
  bb.right = 0.0;
  bb.top = 0.0;

  level = 1;
}

/*
CurrentMarker: returns the current marker number in [0..18]
*/
_int_ currentmarker_(void)
{
  return(markr);
}

/*
dash: issues the PS command to set the trace line-style to dashed.
*/
void dash_(void)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: dash", !FATAL);
    return;
  }

  fprintf(fp, "%%\n%% set the line-style to dashed.\n");
  fprintf(fp, "[%d %d] 0 setdash\n", DASHLEN,
                                     DASHLEN);
  fprintf(fp, "%d setlinecap\n", ButtCap);

  pointset = 0;

  if (markr > 0)
    plot.lineStyle[markr] = DASH;
}

/*
delleg: Deletes a legend entry in the legend table.
*/
void delleg_(_int_ *entry)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: delleg", !FATAL);
    return;
  }

  if (legnd.drawit[*entry % MaxLeg] > 0)
    legnd.drawit[(*entry % MaxLeg)] = 0;
}

/*
donepl: closes the PS output file.
*/
void donepl_(void)
{

  if (level != 1) {
    derror("Level must be 1.  Routine: donepl", !FATAL);
    return;
  }

  fprintf(fp, "%%%%Trailer\n");
  fprintf(fp, "%%%%Pages: %d\n", pg-1);
  fprintf(fp, "%%%%BoundingBox: %d %d %d %d\n",
              (_int_) round(bb.left*DPI),
              (_int_) round(bb.bottom*DPI),
              (_int_) round(bb.right*DPI),
              (_int_) round(bb.top*DPI)
         );

  fprintf(fp, "%%\n%%\n%%\n");

  if (eps)
    fclose(fp);

#if DEBUG
  fprintf(stderr, "Bounding Box in inches from lower left corner of page:\n");
  fprintf(stderr, "left:\t%f\n", bb.left);
  fprintf(stderr, "bottom:\t%f\n", bb.bottom);
  fprintf(stderr, "right:\t%f\n", bb.right);
  fprintf(stderr, "top:\t%f\n", bb.top);
#endif

  level = 0;
}

/*
dot: issues the PS command to set the trace line-style to dotted.
*/
void dot_(void)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: dot", !FATAL);
    return;
  }

  fprintf(fp, "%%\n%% set the line-style to dotted.\n");
  fprintf(fp, "[%d %d] 0 setdash\n", DOTLEN,
                                     3*SPCLEN);
  fprintf(fp, "%d setlinecap\n", ButtCap);

  pointset = 0;

  if (markr > 0)
    plot.lineStyle[markr] = DOT;
}

/*
endpl: issues the PS command to showpage for commands given since the
last showpage.
*/
void endpl_(_int_ *plotno)
{

  if (level < 2 || level > 3) {
    derror("Level must be 2 or 3.  Routine: endpl", !FATAL);
    return;
  }

#if DEBUG
  fprintf(fp, "%% testing out the bounding box.\n");
  fprintf(fp, "%.2f %.2f m\n", round((bb.left-o.x)/plot.sf*DPI),
                               round((bb.bottom-o.y)/plot.sf*DPI));
  fprintf(fp, "%.2f %.2f l\n", round((bb.left-o.x)/plot.sf*DPI),
                               round((bb.top-o.y)/plot.sf*DPI));
  fprintf(fp, "%.2f %.2f l\n", round((bb.right-o.x)/plot.sf*DPI),
                               round((bb.top-o.y)/plot.sf*DPI));
  fprintf(fp, "%.2f %.2f l\n", round((bb.right-o.x)/plot.sf*DPI),
                               round((bb.bottom-o.y)/plot.sf*DPI));
  fprintf(fp, "%.2f %.2f l\n", round((bb.left-o.x)/plot.sf*DPI),
                               round((bb.bottom-o.y)/plot.sf*DPI));
  fprintf(fp, "%.2f setlinewidth\n", 1.0);
  fprintf(fp, "stroke\n");
#endif
  
/* Re-initialize certain elements of the static structures. */
  initstruct();

  fprintf(fp, "%%\n%% end this plot.\n");
  fprintf(fp, "showpage\n%%\n%%\n%%\n");

  level = 1;
}

/*
erase: erases the screen
*/
void erase_(void)
{

  derror("This routine is not supported.  Routine: erase", !FATAL);
}

/*
height: changes the height of all subsequent character strings,
including names, numbers, and axes labels.
*/
void height_(_float_ *hite)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: height", !FATAL);
    return;
  }

  derror("This routine is not supported.  Routine: height", !FATAL);

}

/* 
line: Sets the default line to solid and width to one.
*/
void line_(void)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: line", !FATAL);
    return;
  }

  fprintf(fp, "%%\n%% Set line to continuous.\n");
  fprintf(fp, "[] 0 setdash\n");
  fprintf(fp, "%d setlinecap\n", RoundCap);

  pointset = 0;

  if (markr > 0)
    plot.lineStyle[markr] = LINE;
}

/*
marker: Uses the symbol corresponding to sym for all subsequent calls
to curve.
*/
void marker_(_int_ *sym)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: marker", !FATAL);
    return;
  }

  markr = abs(*sym) % MaxLeg;
}

/*
nobrdr: suppresses the default page border.
*/
void nobrdr_(void)
{

  if (level != 1) {
    derror("Level must be 1.  Routine: nobrdr", !FATAL);
    return;
  }

  plot.border = FALSE;
}

/*
reset: resets lines to solid, markers to zero, and angles to zero.
This routine probably doesn't behave just like the DISSPLA equivalent.
In the case of resetting a marker, it will set the marker to number one.
Otherwise reset() resets the line style to solid and width = 1.
*/
void reset_(char *mode, _int_ lmode)
{
char m[80], *foreground = "FORE";
_int_ all;

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: reset", !FATAL);
    return;
  }

  all = !strcmp(m, "ALL");
  strnlcpy(m, mode, lmode);

  if (!strcmp(m, "MARKER") || all)
    markr = DefaultMarker;

  if (!strcmp(m, "DOT") || !strcmp(m, "DASH") ||
      !strcmp(m, "CHNDSH") || !strcmp(m, "CHNDOT") || all) {
    fprintf(fp, "%%\n%% reset default line parameters\n");
    fprintf(fp, "newpath\n");
    fprintf(fp, "%.2f setlinewidth\n", 1.0);
    fprintf(fp, "%d setlinecap\n", RoundCap);
    fprintf(fp, "[] 0 setdash\n");
    fprintf(fp, "stroke\n");
    pointset = 0;

    if (markr > 0)
      plot.lineStyle[markr] = LINE;
  }

  if (all || !strcmp(m, "ANGLE"))
    mess_angle = 0.0;

  if (all || !strcmp(m, "NEWCLR"))
    newclr_(foreground, strlen(foreground));

}

/*
setdev: sets the unit numbers for error and summary output.
*/
void setdev_(_int_ *err, _int_ *summ)
{

  if (level < 1 || level > 3) {
    derror("Level must be 1, 2, or 3.  Routine: setdev", !FATAL);
    return;
  }

  derror("This routine is not supported.  Routine: setdev", !FATAL);
}

/*
tekall: (does nothing as of yet)
*/
void tekall_(void)
{

  derror("This routine is not supported.  Routine: tekall", FATAL);
}

/*
tk41:
*/
void tk41_(void)
{

  derror("This routine is not supported.  Routine: tk41", FATAL);
}

