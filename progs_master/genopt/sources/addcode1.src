C=DECK      ADDCODE1.NEW
C
C  This is the ADDCODE1.NEW library.  The GENOPT user should
C  add subroutines to this and other ADDCODEn.NEW libraries
C  that he or she may wish to establish. (n less than or equal to
C  five, please!). (ADDCODE1.NEW already contains code relating to Test
C  Case 2 (problem class PANEL, particular example TEE) ).
C
C  Please follow the format given below. You do not need to name
C  the subroutines that you supply USER1, USER2, etc.  You may call
C  them whatever you wish (within FORTRAN rules, of course!).  However,
C  their names and argument lists must be consistent with the calls
C  that you provide in SUBROUTINE STRUCT, which is in the library
C  STRUCT.NEW.
C  
C  When you have completed this ADDCODE1.NEW library, you must compile
C  it and form an object "deck" in library format (.OLB rather than .OBJ).
C  This you do via the following (in the VAX Command Mode):
C
C   $ FOR ADDCODE1.NEW
C   $ GETLIB
C       GIVE NAME OF LIBRARY FILE:  ADDCODE1
C
C  This simple sequence will yield a file called  ADDCODE1.OLB,
C  which you will see listed in the linking ".COM"  file, LINKMAIN.COM.
C  You can see what the command GETLIB does by listing GETLIB.COM.
C  
C
C  This library is used for the 2nd sample case.
C  The problem class name is PANEL.
C  The particular case name is PANEL1.
C
C  THIS IS A LIBRARY OF SUBROUTINES NEEDED FOR VARIOUS KINDS OF BUCKLING
C  OF STRINGER AND RING-STIFFENED COMPOSITE CYLINDRICAL OR FLAT PANELS OR
C  SHELLS.  IT IS VERY LIKE THE COMBINATION OF THE FOLLOWING FOUR
C  ENTITIES FROM THE PANDA2 PROGRAM SYSTEM:
C
C   BUCPAN1.NEW 
C   PANCOM.NEW
C   STFEIG  part of the library BUCKLE.NEW
C   OBJECT  part of the library BUCKLE.NEW
C
C  IN THE PANDA2 PROGRAM SYSTEM.
C
C
C=DECK      BUCPAN
      SUBROUTINE BUCPAN(IFILE,IDESGN,ISTIF,RWBEIG,RWBTOT,
     1                  ILOAD,MBUCK,NBUCK,TBUCK,CBUCK,EBUCK)
C     
C  NEW COMMON ADDED FOR GENOPT APPLICATION...
C
      COMMON/FV31/GENBUC(20),AGENBK(20),FFSGEN(20)
      COMMON/FV34/WIDCOL(20),AWIDCL(20),FSWID(20)
      COMMON/FV37/PANBUC(20),APANBK(20),FFSPAN(20)
      COMMON/FV40/LOCBUC(20),ALOCBK(20),FFSLOC(20)
      REAL LOCBUC
      COMMON/FV43/ROLSKN(20),AROLSK(20),FROLSK(20)
      COMMON/FV46/WEBBUC(20,2 ),JWEBBU,AWEBBK(20,2 ),FSWEB(20,2 )
      COMMON/FV49/WFLBUC(20,2 ),AWFLBK(20,2 ),FSWFL(20,2 )
      COMMON/FV52/FLABUC(20,2 ),AFLABK(20,2 ),FSFLBK(20,2 )
      COMMON/FV55/HATBAS(20,2 ),AHATBS(20,2 ),FSHATB(20,2 )
      COMMON/FV58/HATCRN(20,2 ),AHATBC(20,2 ),FSHATC(20,2 )
      COMMON/FV61/ROLSTF(20,2 ),AROLST(20,2 ),FSROL1(20,2 )
      COMMON/FV64/ROLSMR(20,2 ),AROLSM(20,2 ),FSROL2(20,2 )
      COMMON/FV67/AXIROL(20),AAXIRL(20),FSROL3(20)
C  END OF NEW COMMON FOR GENOPT APPLICATION
C
      COMMON/BOVERW/BOVRW2(2)
      COMMON/CBOSOR/CXB(6,6,5),CYB(6,6),CSB(6,6),CSWB(6,6),CSRB(6,6)
      COMMON/ALLCIJ/CX(6,6,5),CY(6,6,5),CS(6,6)
      DIMENSION ISTIF(*),RWBEIG(*),RWBTOT(*)
      DIMENSION MBUCK(*),NBUCK(*),TBUCK(*),CBUCK(*),EBUCK(*)
C
      COMMON/IIIROL/IIROLL,IPREL,IQUIC
      COMMON/NDEBUG/NPRNT
      COMMON/ROLLIT/NSTOT,NRTOT,IROLL(9,9,2),FNUM(9,2),FDEN(9,2)  
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/STR/D11S(9),D12S(9),D22S(9),GJS(9),ALS(9),ASSM(9),ASSM3(9)
      COMMON/RNG/D11R(9),D12R(9),D22R(9),GJR(9),ALR(9),ARSM(9),ARSM3(9)
      COMMON/PARAM1/ E0X,E0Y,A0,B0,ROB,PHI,PI,ERR,ABIG,BBIG 
      COMMON/STR2/ NPARTS,NSEGS(9),NENDS(9)     
      COMMON/RNG2/ NPARTR,NSEGR(9),NENDR(9)     
      COMMON/NPRINT/NPRT
      COMMON/OUTP/NNPRT
      COMMON/CWALL/C11,C12,C22,C33,C44,C45,C55,C66    
      COMMON/PRELOD/NX0,NY0   
      REAL NX0, NY0, NNORM,NANGL,NNORM0,NANGL0  
      COMMON/PARAM8/ MBAR,NBAR,NXNORM,NYNORM    
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN   
      COMMON/WALLX/JWALL,KWALL,NLAYER,NLIP,NSMRS
      COMMON/REWORK/NREDES    
      COMMON/GENLOC/NXFIX,NYFIX,NXYFIX,TEST,E0XP,E0YP 
      COMMON/PRESTS/NXPRE,NYPRE     
      COMMON/RESULT/RESLTS(9),RESLTR(9),TOTS,TOTR,RSKINX,RSKINY   
      COMMON/RESLTP/RPRES(9),RPRER(9),TOTPS,TOTPR,RSKNXP,RSKNYP   
      COMMON/STRRNG/E0YSVE    
      COMMON/DESVAR/ISPACS(4),R     
      COMMON/MISCLN/NMATEL,IFLAT,DENS(10) 
      COMMON/INTCUR/ICURV,IIFILE,DTHETA,THMAX,THMIN,DIADIF
      COMMON/EFFECL/ELNGTH
      REAL NXFIX,NYFIX,NXYFIX 
      REAL NXPRE,NYPRE  
      REAL NXY0,NXYNRM,NXYSKN 
      REAL           MBAR,NBAR,NXNORM,NYNORM,LENMOD    
      EXTERNAL ROLSTR,ROLRNG,EIG1,EIGROL  
C     
      COMMON/GEOM2/B(2),B2(2),HH(2),WW(2),W2(2)
      COMMON/LOADS/FNX,FNY,FNXY,RESULT(3,5,2)
      COMMON/LOADS2/FNX0,FNY0,FNXY0,RESFXT(3,5,2)
      COMMON/LOADS5/RESFIX(3,5,2)
      COMMON/LOADS3/RESEIG(3,5,2)
      COMMON/THICK/TX(5),TY(5)
      COMMON/MATRN2/GTX(2,5),GTY(2,5),GTS(2),TEFF(2)
C     
C ***********************************
C ***********************************
C
C    FOR PRINTING EIGENVALUES VS. (N,M) DURING SEARCH, SET NPRNT = INDX
C
      NPRNT = 0
C     NPRNT = 1
C     NPRNT = 2
C     NPRNT = 3
C     NPRNT = 4
C ***********************************
C ***********************************
C
C  FIRST, FILL PANDA COMMON BLOCKS WITH PANDA2 VARIABLES...
C
      ISKNN = 0
      IIROLL  = 0
      IKNOCK = 0
      IWARN  = 0
      IPREL  = 0
      IQUIC  = 1
      JJJ    = 0
      IREDUC = 1
      LENMOD = 1.0
      ITUTOR = 0
      IF (IDESGN.EQ.0) THEN
         CALL MOVER(1,0,MBUCK,1,20)
         CALL MOVER(1,0,NBUCK,1,20)
         CALL MOVER(10.,0,TBUCK,1,20)
         CALL MOVER(0.,0,CBUCK,1,20)
         CALL MOVER(10.E+16,0,EBUCK,1,20)
      ENDIF
C
      CALL PANCOM(0,IDESGN,FNX,FNY,FNXY,FNX0,FNY0,FNXY0,
     1            0.,0.,0.,0.,0.,0.,1,1)
C
      IDLOOP = 0  
      DO 3 I = 1,9
      DO 2 J = 1,2
      FNUM(I,J) = 0.0   
      FDEN(I,J) = 0.0   
    2 CONTINUE    
    3 CONTINUE    
      PNX = RSKINX - RSKNXP   
      PNY = RSKINY - RSKNYP   
C     
      IF (NPARTR.EQ.0.AND.NPARTS.EQ.0) GO TO 10
C
      IF (BOVRW2(1).GT.3.0.AND.BOVRW2(2).GT.3.0) THEN
         CALL GENSTB(1,A0-W2(2),B0-W2(1),
     1   PNX,PNY,NXY0,RSKNXP,RSKNYP,MBUCK(1),NBUCK(1), 
     1   TBUCK(1),CBUCK(1),EBUCK(1),IDESGN,EIG1,CX(1,1,1),  
     1   TX(1),TX(1),GTX(1,1),IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
         LOCBUC(ILOAD) = EBUCK(1)
C
C        IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(1),MBUCK(1),NBUCK(1)=',
C    1                                EBUCK(1),MBUCK(1),NBUCK(1)
C
      ELSE
C
         IF (BOVRW2(2).GT.3.0) THEN
            CALL GENSTB(1,A0-W2(2),B(1)-W2(1),
     1          PNX,PNY,NXY0,RSKNXP,RSKNYP,
     1          MBUCK(1),NBUCK(1),TBUCK(1),CBUCK(1),EBUCK(1),
     1          IDESGN,EIG1,CX(1,1,1),
     1          TX(1),TX(1),GTX(1,1),IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
            LOCBUC(ILOAD) = EBUCK(1)
C
C           IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(1),MBUCK(1),NBUCK(1)=',
C    1                                   EBUCK(1),MBUCK(1),NBUCK(1)
C
    5       CONTINUE
            ID = 2
            CALL GENSTB(1,A0,W2(1),RESEIG(1,ID,1),RESEIG(2,ID,1),NXY0,
     1             RESFIX(1,ID,1),RESFIX(2,ID,1),
     1             MBUCK(14),NBUCK(14),TBUCK(14),CBUCK(14),EBUCK(14),
     1             IDESGN,EIG1,CX(1,1,ID),
     1             TX(ID),TX(ID),GTX(1,ID),IREDUC,0,IFILE,ITUTOR,
     1             JJJ,ISTIF)
C
            HATBAS(ILOAD,1) = EBUCK(14)
C
C         IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(14),MBUCK(14),NBUCK(14)=',
C    1                                 EBUCK(14),MBUCK(14),NBUCK(14)
C
         ELSE
C
            CALL GENSTB(1,A0-W2(2),B0-W2(1),PNX,PNY,NXY0,RSKNXP,RSKNYP,
     1          MBUCK(1),NBUCK(1),TBUCK(1),CBUCK(1),EBUCK(1),
     1          IDESGN,EIG1,CX(1,1,1),
     1          TX(1),TX(1),GTX(1,1),IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
            LOCBUC(ILOAD) = EBUCK(1)
C
C           IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(1),MBUCK(1),NBUCK(1)=',
C    1                                   EBUCK(1),MBUCK(1),NBUCK(1)
C
    7       CONTINUE
            ID = 2
            CALL GENSTB(1,B0,W2(2),RESEIG(1,ID,2),RESEIG(2,ID,2),-NXY0,
     1             RESFIX(1,ID,2),RESFIX(2,ID,2),
     1             MBUCK(16),NBUCK(16),TBUCK(16),CBUCK(16),EBUCK(16),
     1             IDESGN,EIG1,CY(1,1,ID),
     1             TY(ID),TY(ID),GTY(1,ID),IREDUC,0,IFILE,ITUTOR,
     1             JJJ,ISTIF)
C
            HATBAS(ILOAD,2) = EBUCK(16)
C
C         IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(16),MBUCK(16),NBUCK(16)=',
C    1                                 EBUCK(16),MBUCK(16),NBUCK(16)
C
         ENDIF
C
      ENDIF
C
    9 CONTINUE
C
      IF (NPARTR.EQ.0.OR.NPARTS.EQ.0) GO TO 10  
C
C   SMEARED STRINGERS, BUCKLING BETWEEN RINGS...
C
      IF (BOVRW2(2).GT.3.0) THEN
        CALL GENSTB(3,A0,BBIG,NX0,PNY,NXY0,NXPRE,RSKNYP,
     1   MBUCK(3),NBUCK(3),TBUCK(3),CBUCK(3),EBUCK(3),
     1   IDESGN,EIG1,CX(1,1,5),TEFF(1),TX(1),GTX(1,5),IREDUC, 
     1   0,IFILE,ITUTOR,JJJ,ISTIF)
C
C  PROVIDE KNOCKDOWN FOR CASE IN WHICH SMEARING STRINGERS LEADS TO
C  UNCONSERVATIVE RESULTS...(ADDED JULY 29, 1987)
C
       CALL EIGMOD(BBIG,NBUCK(3),B(1),EBUCK(3),ITUTOR,IFILE,
     1             CX(4,4,1),CS(4,4))
C
        PANBUC(ILOAD) = EBUCK(3)
C
C       IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(3),MBUCK(3),NBUCK(3)=',
C    1                               EBUCK(3),MBUCK(3),NBUCK(3)
C
C  WIDE COLUMN STUFF FOLLOWS:
       BBBG = MAX(10.*A0,BBIG)
       RSAVE = R
       R = 10000.*SQRT(A0**2 +BBBG**2)
       CALL GENSTB(3,A0,BBBG,NX0,PNY,NXY0,NXPRE,RSKNYP,
     1  MBUCK(4),NBUCK(4),TBUCK(4),CBUCK(4),EBUCK(4),
     1  IDESGN,EIG1,CX(1,1,5),TEFF(1),TX(1),GTX(1,5),IREDUC, 
     1  0,IFILE,ITUTOR,JJJ,ISTIF)
       CALL EIGMOD(BBBG,NBUCK(4),B(1),EBUCK(4),ITUTOR,IFILE,
     1             CX(4,4,1),CS(4,4))
       WIDCOL(ILOAD) = EBUCK(4)
C      IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(4),MBUCK(4),NBUCK(4)=',
C    1                              EBUCK(4),MBUCK(4),NBUCK(4)
C
       R = RSAVE
C  END WIDE COLUMN STUFF.
C
      ENDIF
C     
C  SMEARED RINGS, BUCKLING BETWEEN STRINGERS...
C
      IF (BOVRW2(1).GT.3.0) THEN
        CALL GENSTB(4,LENMOD*ABIG,B0,PNX,NY0,NXY0,RSKNXP,NYPRE,
     1      MBUCK(5),NBUCK(5),TBUCK(5),CBUCK(5),EBUCK(5),
     1      IDESGN,EIG1,CY(1,1,5),TX(1),TEFF(2),GTY(1,5), 
     1      IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
C      IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(5),MBUCK(5),NBUCK(5)=',
C    1                              EBUCK(5),MBUCK(5),NBUCK(5)
C
      ENDIF
C     
   10 CONTINUE    
C     
C  GENERAL INSTABILITY...
C
       CALL GENSTB(2,LENMOD*ABIG,BBIG,NX0,NY0,NXY0,NXPRE,NYPRE,
     1      MBUCK(6),NBUCK(6),TBUCK(6),CBUCK(6),EBUCK(6),IDESGN,
     1      EIG1,CS,TEFF(1),TEFF(2),GTS,IREDUC,0,IFILE,ITUTOR,
     1      JJJ,ISTIF)
C
      IF (NPARTS.NE.0) 
     1  CALL EIGMOD(BBIG,NBUCK(6),B(1),EBUCK(6),ITUTOR,IFILE,
     1              CX(4,4,1),CS(4,4))
      IF (NPARTS.EQ.0.AND.NPARTR.NE.0)
     1  CALL EIGMOD(LENMOD*ABIG,MBUCK(6),B(2),EBUCK(6),ITUTOR,IFILE,
     1              CX(5,5,1),CS(5,5))
C
      GENBUC(ILOAD) = EBUCK(6)
C
C     WRITE(8,*)' IDESGN,EBUCK(6),MBUCK(6),NBUCK(6)=',
C    1            IDESGN,EBUCK(6),MBUCK(6),NBUCK(6)
C
C  WIDE COLUMN STUFF FOLLOWS:
       IF (NPARTS.NE.0.AND.NPARTR.EQ.0) THEN
          BBBG = MAX(10.*A0,BBIG)
          RSAVE= R
          R = 10000.*SQRT(A0**2 +BBBG**2)
          CALL GENSTB(2,LENMOD*ABIG,BBBG,NX0,NY0,NXY0,NXPRE,NYPRE,
     1     MBUCK(4),NBUCK(4),TBUCK(4),CBUCK(4),EBUCK(4),
     1     IDESGN,EIG1,CS,TEFF(1),TEFF(2),GTS,IREDUC, 
     1     0,IFILE,ITUTOR,JJJ,ISTIF)
          CALL EIGMOD(BBBG,NBUCK(4),B(1),EBUCK(4),ITUTOR,IFILE,
     1                CX(4,4,1),CS(4,4))
          WIDCOL(ILOAD) = EBUCK(4)
C         IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(4),MBUCK(4),NBUCK(4)=',
C    1                                 EBUCK(4),MBUCK(4),NBUCK(4)
C
          R = RSAVE
       ENDIF
C  END WIDE COLUMN STUFF.
C
   20 CONTINUE
C
      ROB = ABS(R)/B0  
C     
      IIROLL = 1
      NSTOT = 0   
      IF (NPARTR.EQ.0.AND.NPARTS.EQ.0) GO TO 410
      NSTOT = 4   
      IF (NX0.EQ.0.0.AND.NY0.EQ.0.0) GO TO 410  
      CALL ROLL(B0,NPARTS,NENDS,ANGLS,C1S,ALS,NSEGS,1,RESLTS,RPRES, 
     1          ISTIF(1))
      CALL ROLL(A0,NPARTR,NENDR,ANGLR,C1R,ALR,NSEGR,2,RESLTR,RPRER, 
     1          ISTIF(2))
C     
C     
      ANORM = SQRT((NX0+NXPRE)**2 +(NY0+NYPRE)**2)    
      IF (ANORM.LT.(0.05*ABS(NXY0))) GO TO 350  
      IF (ISTIF(1).EQ.4.OR.ISTIF(2).EQ.4) GO TO 340
       CALL GENSTB(1,A0,B0,PNX,PNY,NXY0,RSKNXP,RSKNYP,
     1      MBUCK(7),NBUCK(7),TBUCK(7),CBUCK(7),EBUCK(7),
     1      IDESGN,EIGROL,CX(1,1,1),TX(1),TX(1),
     1      GTX(1,1),IREDUC,1,IFILE,ITUTOR,JJJ,ISTIF)
C
       ROLSKN(ILOAD) = EBUCK(7)
C
C      IF (IDESGN.EQ.0) WRITE(8,*)' EBUCK(7),MBUCK(7),NBUCK(7)=',
C    1                              EBUCK(7),MBUCK(7),NBUCK(7)
C
  340 CONTINUE
      IF (NPARTS.EQ.0.OR.NPARTR.EQ.0) GO TO 350 
      IF (ISTIF(2).EQ.4) GO TO 345
      CALL GENSTB(3,A0,BBIG,NX0,PNY,NXY0,NXPRE,RSKNYP,
     1      MBUCK(8),NBUCK(8),TBUCK(8),CBUCK(8),EBUCK(8),
     1      IDESGN,EIGROL,CX(1,1,5),TEFF(1),TX(1),
     1      GTX(1,5),IREDUC,1,IFILE,ITUTOR,JJJ,ISTIF)
C
      ROLSMR(ILOAD,1) = EBUCK(8)
C
  345 CONTINUE
      IF (ISTIF(1).EQ.4) GO TO 350
      CALL GENSTB(4,LENMOD*ABIG,B0,PNX,NY0,NXY0,RSKNXP,NYPRE,
     1      MBUCK(9),NBUCK(9),TBUCK(9),CBUCK(9),EBUCK(9),
     1      IDESGN,EIGROL,CY(1,1,5),TX(1),TEFF(2),
     1      GTY(1,5),IREDUC,1,IFILE,ITUTOR,JJJ,ISTIF)
C
      ROLSMR(ILOAD,2) = EBUCK(9)
C     
  350 CONTINUE    
      IF (NPARTS.EQ.0.OR.(TOTS-TOTPS).GT.0.0) GO TO 390     
      IF (ISTIF(1).EQ.4) GO TO 390
       CALL MINVAL(ROLSTR,EBUCK(10),MBUCK(10),IDESGN)
C
       ROLSTF(ILOAD,1) = EBUCK(10)
C
  390 CONTINUE    
      IF (NPARTR.EQ.0.OR.(TOTR-TOTPR).GT.0.0) GO TO 395     
      IF (ISTIF(2).EQ.4) GO TO 395
      CALL MINVAL(ROLRNG,EBUCK(11),NBUCK(11),IDESGN)
C
      ROLSTF(ILOAD,2) = EBUCK(11)
C
  395 CONTINUE    
      EIGRLL = 10.E16
      NAXI = 0    
      IF (NPARTR.EQ.0.OR.IFLAT.NE.0) GO TO 400  
      IF (ISTIF(2).EQ.4) GO TO 400
      CALL MINVAL(ROLRNG,EIGRLL,NAXI,IDESGN) 
C
      AXIROL(ILOAD) = EIGRLL
C
  400 CONTINUE    
C
  410 CONTINUE    
C
C  NEXT, GET LOCAL BUCKLING OF STIFFENER WEBS UNDER COMBINED LOADING.
C
      IF (NPARTS.GE.2) THEN
         CALL GENSTB(1,A0,HH(1),RWBEIG(1),RESEIG(2,3,1),
     1   RESEIG(3,3,1),RWBTOT(1),RESFIX(2,3,1),
     1   MBUCK(12),NBUCK(12),TBUCK(12),CBUCK(12),EBUCK(12),
     1   IDESGN,EIG1,CX(1,1,3),
     1   TX(3),TX(3),GTX(1,3),IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
         WEBBUC(ILOAD,1) = EBUCK(12)
C
      ENDIF
C
      IF (NPARTR.GE.2) THEN
         CALL GENSTB(1,B0,HH(2),RWBEIG(2),RESEIG(2,3,2),
     1   RESEIG(3,3,2),RWBTOT(2),RESFIX(2,3,2),
     1   MBUCK(13),NBUCK(13),TBUCK(13),CBUCK(13),EBUCK(13),
     1   IDESGN,EIG1,CY(1,1,3),
     1   TY(3),TY(3),GTY(1,3),IREDUC,0,IFILE,ITUTOR,JJJ,ISTIF)
C
         WEBBUC(ILOAD,2) = EBUCK(13)
C
      ENDIF
C
      IF (ISTIF(1).EQ.4) THEN
C 
C  NEXT, GET LOCAL BUCKLING UNDER STRINGER HAT BASE AND OF STRINGER
C  HAT CROWN ASSUMING SIMPLE SUPPORT ALONG AXIAL BOUNDARIES.
C
         IF (BOVRW2(1).GT.3.0) THEN
          I1 = 1
C
C    FIRST, GET BUCKLING UNDER BASE OF HAT (S.S. PLATE OF WIDTH W2(1):
C
          ID = 2
          CALL GENSTB(1,A0,W2(1),RESEIG(1,ID,1),RESEIG(2,ID,1),NXY0,
     1        RESFIX(1,ID,1),RESFIX(2,ID,1),
     1        MBUCK(14),NBUCK(14),TBUCK(14),CBUCK(14),EBUCK(14),
     1        IDESGN,EIG1,CX(1,1,ID),
     1        TX(ID),TX(ID),GTX(1,ID),IREDUC,0,IFILE,ITUTOR,
     1        JJJ,ISTIF)
C
           HATBAS(ILOAD,1) = EBUCK(14)
C
         ENDIF
C
C    NEXT, GET BUCKLING OF CROWN OF HAT (S.S. PLATE OF WIDTH WW(1):
C
         I1 = 1
C
         CALL GENSTB(1,A0,WW(1),RESEIG(1,4,1),RESEIG(2,4,1),0.,
     1       RESFIX(1,4,1),RESFIX(2,4,1),
     1       MBUCK(15),NBUCK(15),TBUCK(15),CBUCK(15),EBUCK(15),
     1       IDESGN,EIG1,CX(1,1,4),
     1       TX(4),TX(4),GTX(1,4),IREDUC,0,IFILE,ITUTOR,
     1       JJJ,ISTIF)
C
         HATCRN(ILOAD,1) = EBUCK(15)
C
      ENDIF
C
      IF (ISTIF(2).EQ.4) THEN
C 
C  NEXT, GET LOCAL BUCKLING UNDER RING HAT BASE AND OF RING
C  HAT CROWN ASSUMING SIMPLE SUPPORT ALONG AXIAL BOUNDARIES.
C
C    FIRST, GET BUCKLING UNDER BASE OF HAT (S.S. PLATE OF WIDTH W2(2):
C
           ID = 2
           CALL GENSTB(1,B0,W2(2),RESEIG(1,ID,2),RESEIG(2,ID,2),-NXY0,
     1           RESFIX(1,ID,2),RESFIX(2,ID,2),
     1           MBUCK(16),NBUCK(16),TBUCK(16),CBUCK(16),EBUCK(16),
     1           IDESGN,EIG1,CY(1,1,ID),
     1           TY(ID),TY(ID),GTY(1,ID),IREDUC,0,IFILE,ITUTOR,
     1           JJJ,ISTIF)
C
           HATBAS(ILOAD,2) = EBUCK(16)
C
C
C    NEXT, GET BUCKLING OF CROWN OF HAT (S.S. PLATE OF WIDTH WW(2):
C
         CALL GENSTB(1,B0,WW(2),RESEIG(1,4,2),RESEIG(2,4,2),0.,
     1     RESFIX(1,4,2),RESFIX(2,4,2),
     1     MBUCK(17),NBUCK(17),TBUCK(17),CBUCK(17),EBUCK(17),
     1     IDESGN,EIG1,CY(1,1,4),
     1     TY(4),TY(4),GTY(1,4),IREDUC,0,IFILE,ITUTOR,
     1     JJJ,ISTIF)
C
         HATCRN(ILOAD,2) = EBUCK(17)
C
      ENDIF
C
  412 FORMAT( ' ****************************************************')  
C     
  500 CONTINUE    
      RETURN
      END
C
C
C
C=DECK      GENSTB
      SUBROUTINE GENSTB(INDX,A,B,NX,NY,NXY,NXP,NYP,MWAVE,NWAVE,TESTSH,  
     1 CSLOPE,EIGVAL,IDESGN,EIG,C,TX,TY,G1323,IREDUC,IROLL,IFILE,
     1 ITUTOR,JJJ,ISTIF)
C     
C     PURPOSE IS TO FIND SHELL LOCAL AND GENERAL INSTABILITY.     
C     
C     
      COMMON/WALLD/FKKF(5),ITRANS(4)  
      COMMON/IIIROL/IIROLL,IPRELM,IQUICK
      COMMON/NDEBUG/NPRNT
      COMMON/WALLB/B11,B12,B22,B33
      COMMON /CWALL/C11,C12,C22,C33,C44,C45,C55,C66   
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL     
      COMMON/PARAM8/ MBAR,NBAR,NXNORM,NYNORM    
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN   
      COMMON/NPRINT/NPRT
      COMMON/GENLOC/NXFIX,NYFIX,NXYFIX,TEST,E0XP,E0YP 
      COMMON/DESVAR/ISPACS(4),R     
      DIMENSION C(6,6),G1323(*),ISTIF(*)
      COMMON/MMAXWV/MMAX
      COMMON/STR2/NPARTS,NSEGS(9),NENDS(9)
      COMMON/RNG2/NPARTR,NSEGR(9),NENDR(9)
      COMMON/C11SAV/C11SVE
      REAL NX,NY,NXY    
      REAL NXFIX,NYFIX,NXYFIX 
      REAL NXP,NYP
      REAL NXY0,NXYNRM,NXYSKN 
      REAL NXNORM,NYNORM,NBAR,MBAR,NSAVE,MSAVE  
      REAL NMAXM1,NMINM1
      REAL NCYL
      CHARACTER*70 PHRAS1,PHRAS2
      CHARACTER*5  YESNO
      EXTERNAL EIG
      IIROLL = IROLL
      RBB = ABS(R)/B   
      NBAR = NWAVE
      MBAR = MWAVE
      TEST = TESTSH     
      PI = 3.1415927    
C     
      EIGVAL = 10.E16
      IF (NX.GE.0.0.AND.NY.GE.0.0.AND.NXY.EQ.0.) RETURN
      NXNORM = NX 
      NYNORM = NY 
      NXYNRM = NXY
C
      CALL GTRANS(INDX,C,ISTIF)
      CALL FILLC(C)
C
      IF (NPRNT.NE.0) THEN
         WRITE(8,*)' INDX,IROLL=',INDX,IROLL
         WRITE(8,'(A,1P5E12.4)')' A,B,NX,NY,NXY =',A,B,NX,NY,NXY
         WRITE(8,'(A,1P6E12.4)')' [C(I,I),I=1,6]=',
     1   C(1,1),C(2,2),C(3,3),C(4,4),C(5,5),C(6,6)
      ENDIF
C
      IF (NPRNT.EQ.INDX) THEN
         WRITE(8,'(A,1P6E12.4)') ' C11,NX,NY,NXY,NXP,NYP=',
     1                             C11,NX,NY,NXY,NXP,NYP
         WRITE(8,*)' IPRELM,INDX,IROLL,IIROL=',IPRELM,INDX,IROLL,IIROL
         WRITE(8,1010) R,((C(I,J),J=1,6),I=1,6)
 1010    FORMAT(/' GENERAL INSTAB. MODEL. RADIUS OF CURV., R=',1PE12.4/
     1' SMEARED STIFFENER C(i,j) ='/(1P6E12.4))
      ENDIF
C
      PX = NX/C11
      PY = NY/C11
      PXY= NXY/C11
C
      NXFIX = NXP/C11 
      NYFIX = NYP/C11 
C     
      C11SVE = C11
      CALL CNORM(C)
C
C     ESTABLISH WHETHER SKEWED BUCKLE ANALYSIS IS REQUIRED...     
C     
      ISHEAR = 0  
      ANORM = SQRT(NX**2 +NY**2)    
      IF (ABS(NXY).GT.0.05*ANORM) ISHEAR = 1    
      IF (ABS(NXYFIX).GT.0.05*ANORM) ISHEAR = 1 
      IF (ISHEAR.EQ.0.AND.NX.GT.0.0.AND.NY.GT.0.0) RETURN   
C     
      IBAL = 0    
      IF (ABS(C13).GT.0.05*C11) IBAL = 1  
      IF (ABS(C23).GT.0.05*C22) IBAL = 1  
      IF (ABS(C34).GT.0.05*C44) IBAL = 1  
      IF (ABS(C35).GT.0.05*C55) IBAL = 1  
      IF (ABS(C16).GT.0.05*C66) IBAL = 1  
      IF (ABS(C26).GT.0.05*C66) IBAL = 1  
      IF (ABS(C46).GT.0.05*C66) IBAL = 1  
      IF (ABS(C56).GT.0.05*C66) IBAL = 1  
C     
      IF (IDESGN.EQ.0) GO TO 7
      CALL EIG(A,B,NBAR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGVAL,
     1 INDX)
      GO TO 105
    7 CONTINUE
C
C   GET BENDING STIFFNESS COEFFICIENTS ABOUT NEUTRAL AXES..
C
      C44N = ABS(C44 - B11**2/C11)
      C55N = ABS(C55 - B22**2/C22)
C
C   THE TEST FOR WHICH DIRECTION THE PANEL IS LONG IN MUST BE MADE
C   WITH RESPECT TO THE NEUTRAL AXES IN THE 1 AND 2 DIRECTIONS.  THIS
C   CORRECTION WAS MADE ON APRIL 15, 1983, AND MAY AFFECT SHEAR
C   BUCKLING OF PANELS STIFFENED IN ONE DIRECTION, ESPECIALLY IF THE
C   STIFFENERS ARE MODELLED AS A SHELL WALL LAYER...
C
      TEST = (A/B)*SQRT(C55N/C44N)    
      IF (RBB.LT.1.0.AND.TEST.GT.1.0) TEST = 1./TEST  
C
      IF (NPRNT.EQ.INDX) THEN
         WRITE(8,*)' A,B                =',A,B
         WRITE(8,*)' B11,B22            =',B11,B22
         WRITE(8,*)' C44N,C55N,TEST     =',C44N,C55N,TEST
      ENDIF
C     
      NMINA = 1
      PI = 3.14159
      RFCYL = PI*ABS(R)/B
      IF (RFCYL.LT.1.5) NMINA = 2
      FNMINA = NMINA
C     
C     FIRST FIND MINIMUM WITH MBAR SMALL...     
C     
      IF (NPRNT.EQ.INDX) WRITE(8,*)' FIRST EXPLORE SMALL MBAR RANGE...'
      FLX0 = PI*SQRT(SQRT(R*R*C44N/C22))   
      FMTST1 = A/FLX0   
      FMTST2 = (A/B)*SQRT(SQRT(C55N/C44N))  
      FMTST = AMAX1(FMTST1,FMTST2)  
      MTEST = FMTST + 0.5
C
C  FOLLOWING STATEMENT ADDED 10TH MARCH, 1986, BECAUSE OF INADEQUATE
C  SEARCH FOR CRITICAL BUCKLING LOAD VS. AXIAL HALF WAVENUMBER...
C
      MTEST = MAX(MTEST,2)
C
C
      MBAR = 1.0  
      M = 1 
      EIGSV2 = 100000.  
      FNTST1 = (B/A)*SQRT(SQRT(C44N/C55N))  
      FNTST = AMAX1(FNMINA,FNTST1)
      NBAR = FNTST
C
C  FOLLOWING STATEMENT ADDED 10 MARCH, 1986 TO CORRECT ERROR IN SEARCH
C
      NBAR = NMINA
C
C
      INCR = 1. + 0.10*NBAR   
      N = NBAR    
      NMAX = MAX0(100,N*5)    
      NMIN = NMINA    
      NBAR = N    
      NMINM1 = NBAR     
      FINCR = INCR
      SINCR = 1.0 
      MSAVE = 1.  
      ICHEK = 0   
    9 CONTINUE    
      CALL EIG(A,B,NBAR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGSAV,
     1 INDX)
      NSAVE = NBAR
      MSAVE = MBAR
      CSAVE = CSLOPE    
      FNBR = NBAR + FINCR     
      IF (NBAR.LT.3.) CSLOPE = 0.0
      IF (M.EQ.1) NMAXM1 = FNBR     
      CALL EIG(A,B,FNBR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGVAL,
     1 INDX)
      IF (EIGVAL.LE.EIGSAV) NBAR = FNBR   
      IF (EIGVAL.LE.EIGSAV) GO TO 30
C     
C     EIGSAV.LT.EIGVAL BRANCH...    
C     
      FINCR = - FINCR   
      SINCR = -1.0
      N = NBAR    
      IF (N.EQ.NMINA) GO TO 40    
      GO TO 35    
C     
   30 CONTINUE    
      MSAVE = MBAR
C     
      NSAVE = NBAR
      CSAVE = CSLOPE    
      EIGSAV = EIGVAL   
      IF (N.GT.NMAX.AND.EIGVAL.EQ.10.E16) GO TO 40    
      IF (N.GE.NMAX.AND.ICHEK.EQ.1) GO TO 408   
      IF (N.LE.NMIN.AND.ICHEK.EQ.1) GO TO 408   
C     
   35 CONTINUE    
C     
      NBAR = NBAR + FINCR     
      INCR = (1. + 0.10*NBAR)*SINCR 
      FINCR = INCR
      N = NBAR    
      IF (N.LT.NMINA) GO TO 40    
      IF (M.EQ.1) NMINM1 = AMIN1(NMINM1,NBAR)   
      IF (M.EQ.1) NMAXM1 = AMAX1(NMAXM1,NBAR)   
C
C     WRITE(8,*)' N,NBAR,MBAR,PX,PY,PXY=',N,NBAR,MBAR,PX,PY,PXY
C     WRITE(8,*)' CSLOPE,IDESGN,INDX=',CSLOPE,IDESGN,INDX
C
      CALL EIG(A,B,NBAR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGVAL,
     1 INDX)
      IF (EIGVAL.LE.EIGSAV) THEN
         NMOD = MOD(N,3)
         IF (RBB.LT.1.0.AND.NMOD.EQ.0) THEN
            IF (TEST.LT.0.99.AND.ABS(CSLOPE).GT.1.5) THEN
               CSLOPE = 0.0
            ENDIF
         ENDIF
         GO TO 30
      ENDIF
C     
   40 CONTINUE    
C     
      MMAX = MTEST/2    
      IF (N.GT.4) MMAX = N*2  
      IF (N.GT.NMAX.AND.EIGVAL.EQ.10.E16) MMAX = MAX(MTEST,10)
      IF (EIGSV2.LT.EIGSAV.AND.M.GT.1) GO TO 405
      MINCR = 1. + 0.1*MBAR   
      FMINCR = MINCR    
      MBAR = MBAR + FMINCR    
      M = MBAR    
      IF (M.GT.MMAX) GO TO 408
      NBAR = NSAVE
      IF (N.GT.NMAX.AND.EIGVAL.EQ.10.E16) NBAR = NMINA
      SINCR = 1.0 
      INCR = 1. + 0.10*NBAR   
      FINCR = INCR
      MMAXM1 = MBAR     
      CSLOPE = CSAVE    
      CSAVE2 = CSAVE    
      EIGSV2 = EIGSAV   
      MSAVE2 = MSAVE    
      NSAVE2 = NSAVE    
      GO TO 9     
C     
  405 CONTINUE    
      EIGSAV = EIGSV2   
      CSAVE = CSAVE2    
      MSAVE = MSAVE2    
      NSAVE = NSAVE2    
C     
  408 CONTINUE    
      MBAR = 1.   
      M = 1 
      IF (ICHEK.EQ.1) GO TO 415     
      IF (NMINM1.GE.3.0) GO TO 410  
      IF ((B/NMAXM1).LT.(0.2*ABS(R))) GO TO 420
C     
C      CHECK FOR HIGH-N RANGE....   
C     
      IF (NPRNT.EQ.INDX) WRITE(8,*)' Now check for high NBAR range...'
      NBAR = B/(0.2*ABS(R))  
      INCR = 1. + .10*NBAR    
      FINCR= INCR 
      N = NBAR    
      NMAX = MAX0(100,N*5)    
      NBAR = N    
      NMIN = NMAXM1     
      GO TO 413   
C     
  410 CONTINUE    
C     
C     CHECK FOR LOW-N RANGE....     
C     
      IF (NPRNT.EQ.INDX) WRITE(8,*)' Now check for low NBAR range...'
      NBAR = 2.0  
      N = NBAR
      FINCR = 1.0 
      INCR = FINCR
      NMAX = NMINM1     
      NMINM1 = FNMINA
  413 SINCR = 1.0 
      CSLOPE = 0. 
      NSAVE1 = NSAVE    
      MSAVE1 = MSAVE    
      CSAVE1 = CSAVE    
      EIGSV1 = EIGSAV   
      ICHEK = 1   
      GO TO 9     
  415 CONTINUE    
C     
      IF (EIGSAV.LT.EIGSV1) GO TO 420     
      EIGSAV = EIGSV1   
      CSAVE = CSAVE1    
      MSAVE = MSAVE1    
      NSAVE = NSAVE1    
  420 CONTINUE    
C     
C     NOW CHECK FOR MINIMUM CRITICAL LOAD CORRESPONDING TO HIGHER M...  
C     
      ICHEK = 0   
      NMIN = NMINA    
      SINCR = 1.0 
      NMAX = 10000
      IF (MTEST.LE.1) GO TO 50
C     
C     CHECK FOR MINIMUM CRITICAL LOAD AT HI VALUES OF AXIAL WAVES, MBAR 
C     
      IF (NPRNT.EQ.INDX) WRITE(8,*)' NEXT EXPLORE LARGE MBAR RANGE...'
      MBAR = MTEST
      MMAX = MAX0(100,MTEST*5)
      NBAR = NMINA    
   44 CONTINUE    
      CALL EIG(A,B,NBAR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGVAL,
     1 INDX)
      CALL MINM(A,B,PX,PY,PXY,CSLOPE,IDESGN,MBAR,NBAR,EIGVAL,     
     1 INDX,EIG)  
      M = MBAR    
      KOUNT = 1   
C     
   45 CONTINUE    
C     
C     CHANGE NBAR...    
C     
      KOUNT = KOUNT + 1 
      CCSAV = CSLOPE    
      EIGSSV = EIGVAL   
      MMSAV = MBAR
      NNSAV = NBAR
      FNNSAV = NNSAV    
   46 CONTINUE    
      INCR = (1.0 + 0.1*NBAR)*SINCR
      FINCR = INCR
      NBAR = NBAR + FINCR     
      IF (RBB.GT.1.0) MBAR = MBAR*NBAR/FNNSAV   
      M = MBAR    
      N = NBAR    
      IF (N.LE.NMIN.AND.ICHEK.EQ.1) GO TO 455   
      IF (N.GE.NMAX.AND.ICHEK.EQ.1) GO TO 455   
      IF (N.GT.100.AND.EIGVAL.EQ.10.E16) GO TO 50     
      IF (M.EQ.1) M = 2 
      MBAR = M    
      NMAXM1 = NBAR     
      CALL EIG(A,B,NBAR,MBAR,PX,PY,PXY,CSLOPE,IDESGN,EIGVAL,
     1 INDX)
      CALL MINM(A,B,PX,PY,PXY,CSLOPE,IDESGN,MBAR,NBAR,EIGVAL,     
     1 INDX,EIG)  
      M = MBAR    
C
      IF (EIGVAL.LE.EIGSSV) THEN
         NMOD = MOD(N,3)
         IF (RBB.LT.1.0.AND.NMOD.EQ.0) THEN
            IF (TEST.LT.0.99.AND.ABS(CSLOPE).GT.1.5) THEN
               CSLOPE = 0.0
            ENDIF
         ENDIF
         GO TO 45
      ENDIF
C     
C     
      IF (ICHEK.EQ.0) GO TO 47
      IF (KOUNT.GT.2.AND.SINCR.GT.0.) GO TO 455 
      IF (SINCR.LT.0.0) GO TO 455   
      CSLOPE = CCSAV    
      NBAR = NNSAV
      MBAR = MMSAV
      SINCR = -1.0
      GO TO 46    
   47 CONTINUE    
      NLARGE = NMAXM1   
C     
C     CHECK FOR HIGH-N RANGE...     
C     
      IF (NPRNT.EQ.INDX) WRITE(8,*)' Now check for high NBAR range...'
      NBAR = B/(0.4*ABS(R))  
      N = NBAR    
      IF (N.LE.NLARGE) GO TO 460    
      NBAR = N    
      MBAR = MTEST
      NMIN = NLARGE     
      NMAX = MAX0(100,N*5)    
      ICHEK = 1   
      CSLOPE = 0.0
      NSAVE1 = NNSAV    
      MSAVE1 = MMSAV    
      CSAVE1 = CCSAV    
      EIGSV1 = EIGSSV   
      GO TO 44    
C     
  455 CONTINUE    
      IF (EIGSSV.LT.EIGSV1) GO TO 460     
      EIGSSV = EIGSV1   
      CCSAV = CSAVE1    
      MMSAV = MSAVE1    
      NNSAV = NSAVE1    
  460 CONTINUE    
      IF (EIGSSV.GE.EIGSAV) GO TO 50
C     
      MBAR = MMSAV
      NBAR = NNSAV
      EIGVAL = EIGSSV   
      CSLOPE = CCSAV    
C     
      GO TO 100   
C     
   50 CONTINUE    
C     
      MBAR = MSAVE
      NBAR = NSAVE
      EIGVAL = EIGSAV   
      CSLOPE = CSAVE    
C     
C     
  100 CONTINUE    
C     
      TESTSH = TEST     
      MWAVE = MBAR + 0.1
      NWAVE = NBAR + 0.1
C     
  105 CONTINUE
C     PI = 3.14159
C     NCYL = NBAR*PI*ABS(R)/B
C     AMBAR = A/MBAR
C     DONNEL = 1.0
C     PTEST = ABS(PY) - ABS(PX)
C     IF (NCYL.GT.1.5.AND.NCYL.LT.20.) DONNEL = (NCYL*NCYL-1.)/NCYL**2
C     EIGVAL = DONNEL*EIGVAL
C     
      EIGVLS = EIGVAL
      IF (ITRANS(INDX).EQ.0)
     1      CALL SHRRED(IREDUC,NX,NY,NXY,TX,TY,G1323,EIGVAL,0,1,JJJ)
C
C     
C NEW OUTPUT IN CASE ITUTOR = 1.  THIS BLOCK GOES INTO GENSTB ON
C DECEMBER 30,1984
C
      IF (ITUTOR.EQ.1) THEN
C
         YESNO = '  YES'
         IF (IREDUC.EQ.0) YESNO = '   NO'
C
         GO TO (2,3,4,5),INDX
    2    PHRAS1='Local buckling (simple support along stiffener lines).'
         GO TO 6
    3    PHRAS1='General buckling (simple support at all boundaries).'
         GO TO 6
    4    PHRAS1='Smeared stringers, between rings (s.s. along rings).'
         GO TO 6
    5    PHRAS1='Smeared rings, between stringers (ss along stringers).'
C
    6    IROLL1 = IROLL + 1
         GO TO (8,10),IROLL1
    8    PHRAS2='Rolling of non-smeared stiffeners is not included.'
         GO TO 11
   10    PHRAS2='Rolling of non-smeared stiffeners is included.'
C
   11    CONTINUE
C
         WRITE(IFILE,12) PHRAS1,PHRAS2
   12    FORMAT(/' We are now in SUBROUTINE GENSTB, which is called'/
     1 ' from SUBROUTINE BUCPAN. PANDA-type "closed form" analysis.'/
     1 ' In this particular call to SUBROUTINE GENSTB we obtain'/
     1 ' a buckling load factor for buckling of the following type:'//
     1 1X,A70/1X,A70)
C
         WRITE(IFILE,13) A,B,NX,NY,NXY,NXP,NYP,C(1,1),C(2,2),C(3,3),
     1                   C(4,4),C(5,5),C(6,6),TX,TY,G1323(1),G1323(2),
     1                   YESNO
         IF (ITRANS(INDX).EQ.0) 
     1         WRITE(IFILE,131) EIGVLS,MWAVE,NWAVE,CSLOPE
   13    FORMAT(/' DIMENSIONS, LOADS, C(i,i), AND TRANSVERSE SHEAR'/
     1' PROPERTIES OF THE PORTION OF THE PANEL NOW BEING ANALYZED:'//
     1'  Axial, circumferential lengths, this buckling model=',1P2E12.4/
     1'  Eigenvalue in-plane loads/length of edge, Nx,Ny,Nxy=',1P3E12.4/
     1'  Fixed      in-plane loads/length of edge, Nxo, Nyo =',1P2E12.4/
     1'  Constitutive matrix diagonal, [C(i,i), i=1,6]      =',1P6E12.4/
     1'  Effective thickness, x-face, transverse shearing   =',1PE12.4/
     1'  Effective thickness, y-face, transverse shearing   =',1PE12.4/
     1'  Transverse shear stiffness components, G13, G23    =',1P2E12.4/
     1'  Is transverse shear deformation weakening included?=',A//
     1'  Buckling load factors and no. of halfwaves (M = axial, N = circ
     1umferential):')
  131    FORMAT(
     1'    Neglecting transverse shear deformation weakening=',1PE12.4,
     1' (M =',I3,', N =',I3,') halfwaves. Nodal line slope=',1PE12.4)
         IF (IREDUC.EQ.1) WRITE(IFILE,14) EIGVAL,MWAVE,NWAVE,CSLOPE
   14    FORMAT(
     1'    Including  transverse shear deformation weakening=',1PE12.4,
     1' (M =',I3,', N =',I3,') halfwaves. Nodal line slope=',1PE12.4)
         WRITE(IFILE,15)
   15    FORMAT(' ******************************************************
     1****************************************************************')
C
      ENDIF
C
      RETURN
      END   
C
C
C
C=DECK      EIGMOD
C  19 NOVEMBER, 1988 MODIFICATION:
      SUBROUTINE EIGMOD(CIRC,NWAVES,SPACNG,EIGVAL,ITUTOR,IFILE,
     1                  C44,CS44)
C  END 19 NOVEMBER, 1988 MODIFICATION.
C
C  PROVIDE KNOCKDOWN FOR CASE IN WHICH SMEARING STRINGERS LEADS TO
C  UNCONSERVATIVE RESULTS...(ADDED JULY 29, 1987), MODIFIED 19 NOV. 1988
C
       FN = NWAVES
       WBAR = (CIRC/FN)/SPACNG
       FSAFE= -0.7*WBAR + 2.75
       IF (WBAR.LE.1.5) FSAFE = 1.7
       IF (WBAR.GT.2.5) FSAFE = 1.0
C  19 NOVEMBER, 1988 MODIFICATION:
       FSAFE2 = 1. +(FSAFE-1.)*ABS(1.-C44/CS44)
       EIGNEW = EIGVAL/FSAFE2
C  END 19 NOVEMBER, 1988 MODIFICATION.
       IF (ITUTOR.EQ.1) THEN
          WRITE(IFILE,10)
C  19 NOVEMBER, 1988 MODIFICATION:
   10     FORMAT(/' We are in SUBROUTINE EIGMOD, called from BUCPAN.'/
     1 ' The purpose is to modify the buckling load factor in order'/
     1 ' to account for possible nonconservativeness involved in'/
     1 ' smearing the stiffeners. If there are not at least 2.5'/
     1 ' stiffeners per half-wavelength of the buckling pattern, the'/
     1 ' eigenvalue from the smeared-stiffener (PANDA-type) analysis'/
     1 ' is divided by a factor FSAFE2, which is calculated thus:'/
     1 '       WBAR = (WIDTH/NWAVES)/SPACNG'/
     1 '       FSAFE= -0.7*WBAR + 2.75    '/
     1 '       IF (WBAR.LE.1.5) FSAFE = 1.7'/
     1 '       IF (WBAR.GT.2.5) FSAFE = 1.0'/
     1 '       FSAFE2 = 1. +(FSAFE-1.)*ABS(1.-C44/CS44)'/
     1 '       EIGNEW = EIGVAL/FSAFE2'/)
          WRITE(IFILE,20) CIRC,NWAVES,SPACNG,WBAR,FSAFE,C44,CS44,
     1                    FSAFE2,EIGVAL,EIGNEW
   20     FORMAT(' in which'/
     1 ' Width of the panel (or length, if rings only), WIDTH=',1PE12.4/
     1 ' Number of half-waves across WIDTH,            NWAVES=',I7/
     1 ' Spacing of the stiffeners,                    SPACNG=',1PE12.4/
     1 ' Ratio of buckling half-wavelength to spacing,   WBAR=',1PE12.4/
     1 ' First modification factor,                     FSAFE=',1PE12.4/
     1 ' Bending stiffness of panel skin normal to WIDTH, C44=',1PE12.4/
     1 ' Bending stiffness with smeared stiffeners,      CS44=',1PE12.4/
     1 ' Factor by which the eigenvalue obtained from the'/
     1 '   smeared-stiffener model should be divided,  FSAFE2=',1PE12.4/
     1 ' Eigenvalue from the smeared-stiffener model,  EIGVAL=',1PE12.4/
     1 ' Reduced eigenvalue,           EIGVAL/FSAFE2 = EIGNEW=',1PE12.4)
C  END 19 NOVEMBER, 1988 MODIFICATION.
C
       ENDIF
C 
       EIGVAL = EIGNEW
      RETURN
      END
C
C
C
C=DECK      PANCOM
      SUBROUTINE PANCOM(IABP,IDESGN,FNX,FNY,FNXY,FNX0,FNY0,FNXY0,
     1            FNXP0,FNYP0,FNXYP0,FNXPL0,FNYPL0,FNXYPL,MIDEND,
     1            IREDUC)
C
C  PURPOSE IS TO FILL COMMON BLOCKS REQUIRED BY PANDA SOFTWARE FOR
C  BUCKLING AND ROLLING ANALYSIS, AND TO INITIALIZE CERTAIN PANDA
C  VARIABLES
C
C  COMMON BLOCKS USED IN PANDA...
C
      COMMON/ROLLIT/NSTOT,NRTOT,IROLL(9,9,2),FNUM(9,2),FDEN(9,2)
      COMMON/INTCUR/ICURV,IFILE,DTHETA,THMAX,THMIN,DIADIF
      COMMON/CWALL/C11,C12,C22,C33,C44,C45,C55,C66
      COMMON/PARAM8/ MBAR,NBAR,NXNORM,NYNORM
      COMMON/PARAM9/MSKIN,NSKIN,NXSKIN,NYSKIN
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/STR/D11S(9),D12S(9),D22S(9),GJS(9),ALS(9),ASSM(9),ASSM3(9)
      COMMON/RNG/D11R(9),D12R(9),D22R(9),GJR(9),ALR(9),ARSM(9),ARSM3(9)
      COMMON/STR2/NPARTS,NSEGS(9),NENDS(9)
      COMMON/RNG2/NPARTR,NSEGR(9),NENDR(9)
      COMMON/PARAM1/ E0X,E0Y,A0,B0,ROB,PHI,PI,ERR,ABIG,BBIG
      COMMON/PRELOD/NX0,NY0
      COMMON/WALLX/JWALL,KWALL,NNNLAY,NLIP,NSMRS
      COMMON/DESVAR/IBUCKL,ISPACR,ISIZS,ISIZR,R
      COMMON/SIGNAL/ISIG,ISIG1,ISIG2,ISIG3
      COMMON/PRESTS/NXPRE,NYPRE
      COMMON/GENLOC/NXFIX,NYFIX,NXYFIX,TEST,E0XP,E0YP
      COMMON/AA1/EIGSTR(9),EIGRNG(9),EIGROL(4),X(20),Y(20),XSAVE(20)
      COMMON/AA5/EIGGEN,EIGLOC,WSTAR,DX
      COMMON/AA7/IFLAG
      COMMON/MISCLN/NMATEL,IFLAT,DENS(10) 
      COMMON/STRRNG/E0YSVE
      COMMON/BENDNG/WXXMID,EPS1(30),EPS2(30),EPS12(30),TTOT
      COMMON/RESULT/RESLTS(9),RESLTR(9),TOTS,TOTR,RSKINX,RSKINY
      COMMON/RESLTP/RPRES(9),RPRER(9),TOTPS,TOTPR,RSKNXP,RSKNYP
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL
      COMMON/KSHEER/KTRANS
C
      REAL NXPRE,NYPRE,NXYPRE
      REAL NXFIX,NYFIX,NXYFIX
      REAL           MBAR,NBAR,NXNORM,NYNORM
      REAL NX0,NY0,NXY0
      REAL      NXYNRM,NXYSKN
      REAL MSKIN,NSKIN,NXSKIN,NYSKIN
C
C  COMMON BLOCKS USED IN PANDA2...
C
      COMMON/GEOM1/AXIAL,CIRC,RR
      COMMON/GEOM2/B(2),B2(2),H(2),W(2),W2(2)
      COMMON/GEOM3/ISTIF(2),NLAYER(4,2),NSEG(2),INTEXT(2)
      COMMON/GEOM5/RAD2,CURV2
      COMMON/LOADS/FNXX,FNYY,FNXXYY,RESULT(3,5,2)
      COMMON/LOADS2/FNX00,FNY00,FNXY00,RESFXT(3,5,2)
      COMMON/LOADS5/RESFIX(3,5,2)
      COMMON/ALLCIJ/CX(6,6,5),CY(6,6,5),CS(6,6)
C
      IF (IDESGN.NE.0.OR.MIDEND.EQ.2) GO TO 10
C
      CALL MOVER(0.,0,RPRES,1,22)
   10 CONTINUE
C
C
C  TRANSLATE FROM PANDA2 TO PANDA VARIABLES...
C
      PHI = 1.0
      ICURV = 0
C     KTRANS = 0
C
C  KTRANS CHANGE NEW ON 11 JULY, 1987 (USE MINDLIN THEORY FOR
C  TRANSVERSE SHEAR EFFECTS IN SMEARED STIFFENER MODELS IF IREDUC = 1.
C
      KTRANS = IREDUC
C
      RSKINX =  RESULT(1,1,1) 
      RSKINY =  RESULT(2,1,1)
      RSKNXP =  RESFIX(1,1,1)
      RSKNYP =  RESFIX(2,1,1)
      A0 = B(2)
      B0 = B(1)
      NXY0 = FNXY
      NXYPRE = 0.
      NXYFIX = NXYPRE
C
      CALL STFTYP(ISTIF(1),INTEXT(1),NPARTS,ANGLS,NSEGS,NENDS,RESLTS,
     1            RPRES,RESULT(1,1,1),RESFIX(1,1,1),ALS,W(1),H(1),
     1            C1S,C33S,D12S,D22S,D11S,GJS,CX,TOTS,TOTPS)
C
      CALL STFTYP(ISTIF(2),INTEXT(2),NPARTR,ANGLR,NSEGR,NENDR,RESLTR,
     1            RPRER,RESULT(1,1,2),RESFIX(1,1,2),ALR,W(2),H(2),
     1            C1R,C33R,D12R,D22R,D11R,GJR,CY,TOTR,TOTPR)
C
      ABIG = AXIAL
      BBIG = CIRC
      RTEST = 10000.*SQRT(ABIG**2 +BBIG**2)
      R    = RR
      IF (ABS(RAD2).LT.(RTEST/1.1)) R = RAD2
C     WRITE(8,*) ' RAD2 (FROM GEOM5 COMMON BLOCK) =', RAD2
C
      IF (IABP.EQ.0) THEN
         NX0 = FNX
         NY0 = FNY
         NXPRE = FNX0 + FNXP0 + FNXPL0
         NYPRE = FNY0 + FNYP0 + FNYPL0
      ELSE
         NX0 = FNX + FNXP0 + FNXPL0
         NY0 = FNY + FNYP0 + FNYPL0
         NXPRE = FNX0 
         NYPRE = FNY0 
      ENDIF
      IFLAT = 0
      IF (ABS(R).GT.(RTEST/1.1)) IFLAT = 1
C
      RETURN
      END
C
C
C=DECK      STFTYP
      SUBROUTINE STFTYP(ISTIF,INTERN,NPART,ANGL,NSEG,NEND,RESLT,RPRE,  
     1           RESULT,RESFIX,AL,W,H,C1,C33,D12,D22,D11,GJ,C,TOT,TOTP)
C     
C   PURPOSE IS TO FILL NPART,ANGL,NSEG, AND NEND, GIVEN ISTIF,INTERN
C     
      DIMENSION NSEG(*),ANGL(*),NEND(*),RESLT(*),RPRE(*),AL(*)   
      DIMENSION C1(*),C33(*),D12(*),D22(*),D11(*),GJ(*)
      DIMENSION RESULT(3,5),RESFIX(3,5),C(6,6,5)
C     
      DEGRAD = 3.1415927/180.
      NPART = 0
      TOT = 0.
      TOTP= 0.
      CALL MOVER(0,0,NSEG,1,5)
      CALL MOVER(0,0,NEND,1,5)
      CALL MOVER(0.,0,ANGL,1,5)
      CALL MOVER(0.,0,RESLT,1,5)
      CALL MOVER(0.,0,RPRE,1,5)
      CALL MOVER(0.,0,AL,1,5)
      CALL MOVER(0.,0,C1,1,5)
      CALL MOVER(0.,0,C33,1,5)
      CALL MOVER(0.,0,D11,1,5)
      CALL MOVER(0.,0,D12,1,5)
      CALL MOVER(0.,0,D22,1,5)
      CALL MOVER(0.,0,GJ,1,5)
C
      ISTIF1 = ISTIF + 1
      GO TO (5000,120,130,110,140), ISTIF1
  110 CONTINUE
C     
C   BRANCH FOR RECTANGULAR CROSS SECTION...     
C     
      NPART = 1   
      ANGL(1) = 0.
      IF (INTERN.EQ.1) ANGL(1) = 180.     
      NSEG(1) = 0 
      NEND(1) = 1 
      AL(1)   = H
      C1(1) = C(1,1,3)
      C33(1)= C(3,3,3)
      D11(1)= C(4,4,3)
      D12(1)= C(4,5,3)
      D22(1)= C(5,5,3)
      GJ(1)   = C(6,6,3)
      RESLT(1)= RESULT(1,3)
      RPRE(1) = RESFIX(1,3)
      TOT = RESLT(1)*H
      TOTP= RPRE(1)*H
      GO TO 5000  
C     
  120 CONTINUE    
C     
C   BRANCH FOR TEE CROSS SECTION (FLANGE AWAY FROM PANEL SKIN)    
C     
      NPART = 3   
      ANGL(1) = 0.
      IF (INTERN.EQ.1) ANGL(1) = 180.     
      ANGL(2) = 90.     
      ANGL(3) = -90.    
      NSEG(1) = 0 
      NSEG(2) = 1 
      NSEG(3) = 1 
      NEND(1) = 0 
      NEND(2) = 1 
      NEND(3) = 1 
      AL(1)   = H
      C1(1) = C(1,1,3)
      C33(1)= C(3,3,3)
      D11(1)= C(4,4,3)
      D12(1)= C(4,5,3)
      D22(1)= C(5,5,3)
      GJ(1)   = C(6,6,3)
      RESLT(1)= RESULT(1,3)
      RPRE(1) = RESFIX(1,3)
      AL(2)   = W/2.
      C1(2) = C(1,1,4)
      C33(2)= C(3,3,4)
      D11(2)= C(4,4,4)
      D12(2)= C(4,5,4)
      D22(2)= C(5,5,4)
      GJ(2)   = C(6,6,4)
      RESLT(2)= RESULT(1,4)
      RPRE(2) = RESFIX(1,4)
      AL(3)   = W/2.
      C1(3) = C(1,1,4)
      C33(3)= C(1,1,4)
      D11(3)= C(4,4,4)
      D12(3)= C(4,5,4)
      D22(3)= C(5,5,4)
      GJ(3)   = C(6,6,4)
      RESLT(3)= RESULT(1,4)
      RPRE(3) = RESFIX(1,4)
      TOT = RESLT(1)*H + RESLT(2)*W
      TOTP=  RPRE(1)*H +  RPRE(2)*W
C     WRITE(8,*)' RESLT1,RESLT2,RESLT3=',RESLT(1),RESLT(2),RESLT(3)
C     WRITE(8,*)' RPRE1, RPRE2, RPRE3 =',RPRE(1), RPRE(2), RPRE(3)
      GO TO 5000  
C     
  130 CONTINUE    
C     
C   BRANCH FOR L-SHAPED CROSS SECTION, FLANGE AWAY FROM SKIN..    
C     
      NPART = 2   
      ANGL(1) = 0.
      IF (INTERN.EQ.1) ANGL(1) = 180.     
      ANGL(2) = 90.     
      NSEG(1) = 0 
      NSEG(2) = 1 
      NEND(1) = 0 
      NEND(2) = 1 
      AL(1)   = H
      C1(1) = C(1,1,3)
      C33(1)= C(3,3,3)
      D11(1)= C(4,4,3)
      D12(1)= C(4,5,3)
      D22(1)= C(5,5,3)
      GJ(1)   = C(6,6,3)
      RESLT(1) = RESULT(1,3)
      RPRE(1)  = RESFIX(1,3)
      AL(2)   = W
      C1(2) = C(1,1,4)
      C33(2)= C(3,3,4)
      D11(2)= C(4,4,4)
      D12(2)= C(4,5,4)
      D22(2)= C(5,5,4)
      GJ(2)   = C(6,6,4)
      RESLT(2) = RESULT(1,4)
      RPRE(2)  = RESFIX(1,4)
      TOT = RESLT(1)*H + RESLT(2)*W
      TOTP=  RPRE(1)*H +  RPRE(2)*W
      GO TO 5000  
C     
C     
  140 CONTINUE    
C     
C   BRANCH FOR HAT CROSS SECTION (FLANGE AWAY FROM PANEL SKIN)    
C     
      NPART = 3   
      ANGL(1) = 0.
      IF (INTERN.EQ.1) ANGL(1) = 180.     
      ANGL(2) = 90.     
      ANGL(3) = 0.
      IF (INTERN.EQ.1) ANGL(3) = 180.     
      NSEG(1) = 0 
      NSEG(2) = 1 
      NSEG(3) = 0 
      NEND(1) = 0 
      NEND(2) = 0 
      NEND(3) = 0 
      AL(1)   = H
      C1(1) = C(1,1,3)
      C33(1)= C(3,3,3)
      D11(1)= C(4,4,3)
      D12(1)= C(4,5,3)
      D22(1)= C(5,5,3)
      GJ(1)   = C(6,6,3)
      RESLT(1)= RESULT(1,3)
      RPRE(1) = RESFIX(1,3)
      AL(2)   = W
      C1(2) = C(1,1,4)
      C33(2)= C(3,3,4)
      D11(2)= C(4,4,4)
      D12(2)= C(4,5,4)
      D22(2)= C(5,5,4)
      GJ(2)   = C(6,6,4)
      RESLT(2)= RESULT(1,4)
      RPRE(2) = RESFIX(1,4)
      AL(3)   = H
      C1(3) = C(1,1,3)
      C33(3)= C(1,1,3)
      D11(3)= C(4,4,3)
      D12(3)= C(4,5,3)
      D22(3)= C(5,5,3)
      GJ(3)   = C(6,6,3)
      RESLT(3)= RESULT(1,3)
      RPRE(3) = RESFIX(1,3)
      TOT = RESLT(1)*2.*H + RESLT(2)*W
      TOTP=  RPRE(1)*2.*H +  RPRE(2)*W
C     
C     
 5000 CONTINUE    
C
      DO 5100 I = 1,5
 5100 ANGL(I) = ANGL(I)*DEGRAD
C
      RETURN
      END   
C
C
C
C=DECK      GTRANS
      SUBROUTINE GTRANS(INDX,C,ISTIF) 
C     
C     PURPOSE IS TO CALCULATE TRANSVERSE SHEAR STIFFNESS FOR SMEARED    
C     STIFFENER WEBS.   
C     
C     THE OUTPUT (A44, A55, A45, K1, AND K2) ARE USED IN SUBROUTINE     
C     TSHEAR, WHICH CALCULATES CONTRIBUTION DUE TO TRANSVERSE SHEAR     
C     DEFORMATION.
C     
      COMMON/STFTHK/C1S(9),C1R(9),C33S(9),C33R(9),ANGLS(9),ANGLR(9)
      COMMON/STR/D11S(9),D12S(9),D22S(9),GJS(9),ALS(9),ASSM(9),ASSM3(9)
      COMMON/RNG/D11R(9),D12R(9),D22R(9),GJR(9),ALR(9),ARSM(9),ARSM3(9)
      COMMON/PARAM1/ E0X,E0Y,A0,B0,ROB,PHI,PI,ERR,ABIG,BBIG 
      COMMON/STR2/ NPARTS,NSEGS(9),NENDS(9)     
      COMMON/RNG2/ NPARTR,NSEGR(9),NENDR(9)     
      DIMENSION C(6,6),ISTIF(2)
      COMMON/WALLD/K1,K2,A44,A45,A55,ITRANS(4)  
      COMMON/KSHEER/KTRANS    
C     
      REAL K1,K2,KAPPA  
C     
      PI = 3.141593     
      KAPPA = 5./6.     
      DO 5 I = 1,4
    5 ITRANS(I) = 0     
      A44 = C(3,3)*KAPPA
      A45 = 0.    
      A55 = C(3,3)*KAPPA
C     
      IF (INDX.EQ.1) RETURN   
      IF (KTRANS.EQ.0) RETURN 
      IF (NPARTS.EQ.0) GO TO 100    
      IF (INDX.EQ.4) GO TO 100
C     
      DO 10 I = 1,NPARTS
      IF (NSEGS(I).NE.0) GO TO 10   
      DIFF = ABS( ABS(ANGLS(I)) - PI/2. )  
      IF (DIFF.LT.0.1) GO TO 10     
C     
C  THIS STRINGER PART IS A WEB ATTACHED TO THE SKIN...
C     
      KAPPA = 1.0 
      IF (NENDS(I).NE.0) KAPPA = 0.5
      FACT = 1.0
      IF (ISTIF(1).EQ.4) FACT = 2.0
      GXZ = FACT*C33S(I)/B0    
      A55 = GXZ*ALS(I)*KAPPA  
      ITRANS(INDX) = 1  
C     
      GO TO 100   
   10 CONTINUE    
C     
  100 CONTINUE    
C     
      IF (NPARTR.EQ.0) RETURN 
      IF (INDX.EQ.3) RETURN   
C     
      DO 20 I = 1,NPARTR
      IF (NSEGR(I).NE.0) GO TO 20   
      DIFF = ABS( ABS(ANGLR(I)) - PI/2. )  
      IF (DIFF.LT.0.1) GO TO 20     
C     
C  THIS RING PART IS A WEB ATTACHED TO THE SKIN...    
C     
      KAPPA = 1.0 
      IF (NENDR(I).NE.0) KAPPA = 0.5
      FACT = 1.0
      IF (ISTIF(2).EQ.4) FACT = 2.0
      GYZ = FACT*C33R(I)/A0    
      A44 = GYZ*ALR(I)*KAPPA  
      ITRANS(INDX) = 1  
      RETURN
   20 CONTINUE    
      RETURN
      END   
C
C
C
C=DECK      FILLC 
      SUBROUTINE FILLC(C)  
C     
C     PURPOSE IS TO TRANSFER C(I,J) MATRIX INTO C11,C12,...AND B11,B12..
C     
      DIMENSION C(6,6)
      COMMON /CWALL/C11,C12,C22,C33,C44,C45,C55,C66   
      COMMON/WALLB/B11,B12,B22,B33  
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL     
      COMMON/PRESHR/NXY0,E0XY,NXYNRM,ISHEAR,SHEAR,CSTART,NXYSKN,CSKIN   
      REAL NXY0,NXYNRM,NXYSKN 
      C11 = C(1,1)
      C12 = C(1,2)
      C22 = C(2,2)
      C33 = C(3,3)
      C44 = C(4,4)
      C45 = C(4,5)
      C55 = C(5,5)
      C66 = C(6,6)
C     
      B11 =  C(1,4)
      B12 =  C(1,5)
      B22 =  C(2,5)
      B33 =  C(3,6)
C     
      C13 = C(1,3)
      C16 = C(1,6)
      C23 = C(2,3)
      C26 = C(2,6)
      C34 = C(3,4)
      C35 = C(3,5)
      C46 = C(4,6)
      C56 = C(5,6)
C     
      RETURN
      END   
C
C
C
C=DECK      CNORM 
      SUBROUTINE CNORM(C)  
C     
C     PURPOSE IS TO NORMALIZE THE C(I,J) TO PREVENT OVERFLOW.     
C     
      DIMENSION C(6,6)
      COMMON/CMOD/CC(6,6)     
      COMMON /CWALL/C11,C12,C22,C33,C44,C45,C55,C66   
      COMMON/WALLB/B11,B12,B22,B33  
      COMMON/WALLC/C13,C16,C23,C26,C34,C35,C46,C56,IBAL     
      COMMON/WALLD/K1,K2,A44,A45,A55,ITRANS(4)  
      C12 = C(1,2)/C11  
      C22 = C(2,2)/C11  
      C33 = C(3,3)/C11  
      C44 = C(4,4)/C11  
      C45 = C(4,5)/C11  
      C55 = C(5,5)/C11  
      C66 = C(6,6)/C11  
C     
      B11 = C(1,4)/C11  
      B12 = C(1,5)/C11  
      B22 = C(2,5)/C11  
      B33 = C(3,6)/C11  
C     
      C13 = C(1,3)/C11  
      C16 = C(1,6)/C11  
      C23 = C(2,3)/C11  
      C26 = C(2,6)/C11  
      C34 = C(3,4)/C11  
      C35 = C(3,5)/C11  
      C46 = C(4,6)/C11  
      C56 = C(5,6)/C11  
      A44 = A44/C11     
      A45 = A45/C11     
      A55 = A55/C11     
      DO 20 I = 2,6     
      I1 = I - 1  
      DO 20 J = 1,I1    
   20 C(I,J) = C(J,I)   
      DO 30 I = 1,6     
      DO 30 J = 1,6     
   30 CC(I,J) = C(I,J)/C11    
C
C     DO 40 I = 1,3
C     DO 40 J = 4,6
C  40 CC(I,J) = -CC(I,J)
C     DO 50 I = 2,6     
C     I1 = I - 1  
C     DO 50 J = 1,I1    
C  50 CC(I,J) = CC(J,I)   
C
      C11 = 1.0   
C     
      RETURN
      END   
C
C
C
C=DECK      DIFF  
      SUBROUTINE DIFF(A,B,DIFF1)    
C     
C     PURPOSE IS TO FIND A FLOATING PT. QUANTITY DIFF1 USED IN COMPARI- 
C     SONS WITH A TOLERANCE INDEX, TOL, FOR LOGICAL IF STATEMENTS.
C     
      FNUM = ABS(A-B)   
      FDEN = SQRT(A*A + B*B)  
      DIFF1 = 0.0 
      IF (FDEN.GT.0.00001) DIFF1 = FNUM/FDEN    
C     
      RETURN
      END   
C
C
C
C=DECK      ZAZB  
      SUBROUTINE ZAZB(NPART,NSEG,ANGL,AL,FL,ZA,ZB,YA,YB)    
C     
C     PURPOSE IS TO CALCULATE BEGINNING AND END COORDINATES OF STIFFENER
C     SEGMENTS.   
C     
      DIMENSION NSEG(9),ANGL(9),AL(9),ZA(9),ZB(9),YA(9),YB(9)     
      CHARACTER*6 SUBNAM
      DATA SUBNAM/ 'ZAZB  ' / 
C     
      KOUNT = 0   
C     
      DO 20 J = 1,NPART 
      DO 10 I = 1,NPART 
C     
      K = NSEG(I) 
      IF (K.NE.J-1) GO TO 10  
      A = ANGL(I) 
      SA = SIN(A) 
      ASA = ABS(SA)     
      CA = COS(A) 
      ACA = ABS(CA)     
C     
      ZSTART = 0. 
      IF (K.GT.0) ZSTART = ZB(K)    
      YSTART = 0. 
      IF (K.GT.0) YSTART = YB(K)    
C     
      ZA(I) = ZSTART    
      ZB(I) = ZSTART + AL(I)*CA     
C     
      YA(I) = YSTART    
      YB(I) = YSTART + AL(I)*SA     
C     
      KOUNT = KOUNT + 1 
      IF (KOUNT.EQ.NPART) GO TO 25  
C     
   10 CONTINUE    
   20 CONTINUE    
      IF (KOUNT.LT.NPART) CALL MERR(SUBNAM)     
C     
   25 CONTINUE    
C     
      RETURN
      END   
C
C
C
C=DECK      MERR  
      SUBROUTINE MERR(SUBNAM) 
      CHARACTER*6 SUBNAM
      WRITE(6,10) 
   10 FORMAT(//' ERROR EXIT... CHECK INPUT DATA OR PROGRAM LOGIC.'/     
     1' ERROR OCCURRED IN SUBROUTINE...'/)
      WRITE(6,20) SUBNAM
   20 FORMAT(A6)  
      CALL EXIT   
      RETURN
      END   
C
C
C
C=DECK      STFEIG
      SUBROUTINE STFEIG(MIDEND,ISTIF,B,B2,H,W,W2,CX,CY,RESULT,RESFIX,
     1             ISKIN,TX,TY,GTX,GTY,IREDUC,IMOD,ICRIP,MSKIN,
     1             NSKIN,IFILE,JJJ,RWBTOT,RWBEIG,ILOAD,FLABUC,WFLBUC)
C
C  PURPOSE IS TO GET CRIPPLING OF STIFFENER PARTS
C
      COMMON/GEOM6/IFAY(2),IMISCL(28)
      DIMENSION ISTIF(*),B(*),B2(*),H(*),W(*),W2(*),CX(6,6,5),CY(6,6,5)
      DIMENSION RESULT(3,5,2),RESFIX(3,5,2)
      DIMENSION TX(*),TY(*),GTX(2,5),GTY(2,5)
      DIMENSION RWBTOT(2),RWBEIG(2),FLABUC(20,2),WFLBUC(20,2)
C
C     WRITE(8,*)' ISTIF(1),ISTIF(2)=',ISTIF(1),ISTIF(2)
C     WRITE(8,*)' RESULT(1,1,1),RESFIX(1,1,1)=',
C    1            RESULT(1,1,1),RESFIX(1,1,1)
C
      DO 100 K = 1,2
      IFREE = 0
      IF (ISTIF(K).EQ.0) GO TO 100
      IF (ISTIF(K).EQ.1.OR.ISTIF(K).EQ.2) THEN
         ISTART = 3
         IEND   = 4
      ENDIF
C
      IF (ISTIF(K).EQ.3) THEN
         ISTART = 3
         IEND   = 3
      ENDIF
C
      IF (ISTIF(K).EQ.4) THEN
         ISTART = 2
C        IF (ISKIN.EQ.0) ISTART = 1
         IEND   = 4
      ENDIF
C
C     WRITE(8,*)' IMOD,INUMTT,K,ISTART,IEND=',IMOD,INUMTT,K,ISTART,IEND
C
C
C     M = MSKIN
C     IF (K.EQ.2) M = NSKIN
C
      IF (ISTIF(K).EQ.4) GO TO 100
C
C      DO 60 I = ISTART,IEND
C
C      IF (ISTIF(K).NE.4.AND.I.EQ.IEND) IFREE = 1
C      ID = I
C      IF (IFAY(K).EQ.1.AND.I.EQ.2) ID = 1
C      FVAR = RESULT(1,ID,K)
C      FFIX = RESFIX(1,ID,K)
C      IF (I.EQ.3) THEN
C         FVAR = MIN(RWBEIG(K),RESULT(1,I,K))
C         FFIX = MIN(RWBTOT(K),RESFIX(1,I,K))
C      ENDIF
C      IF (K.EQ.1) THEN         
C
C         CALL CRIPPL(IFREE,K,I,ISTIF(K),B(K),H(K),W(K),W2(K),
C     1               CX(1,1,ID),FVAR,FFIX,
C     1               TX(ID),GTX(1,ID),IREDUC,IMOD,
C     1               B(2),M,IFILE,ISTART,
C     1               ICRIP,JJJ,MIDEND,FLABUC(ILOAD,K))
C
C   40    CONTINUE
C     WRITE(8,*)' IMOD,INUMTT,I,ICONST,CONSTR=',
C    1            IMOD,INUMTT,I,ICONST,CONSTR(ICONST)
C
C      ELSE
C
C         IF (MIDEND.EQ.1) THEN
C            CALL CRIPPL(IFREE,K,I,ISTIF(K),B(K),H(K),W(K),W2(K),
C    1               CY(1,1,ID),FVAR,FFIX,
C    1               TY(ID),GTY(1,ID),IREDUC,IMOD,
C    1               B(1),M,IFILE,ISTART,
C    1               ICRIP,JJJ,MIDEND,FLABUC(ILOAD,K))
C         ENDIF
C
C     WRITE(8,*)' IMOD,INUMTT,I,ICONST,CONSTR=',
C    1            IMOD,INUMTT,I,ICONST,CONSTR(ICONST)
C
C     ENDIF
C
C  60 CONTINUE
C
      IF (ISTART.EQ.3.AND.IEND.EQ.4) THEN
C
C  GET 2-SEGMENT CRIPPLING OF T OR J STIFFENER  (OCT. 20, 1986)
C
         IF (K.EQ.1) THEN
          CALL CRIPP2(K,ISTIF(K),B(2),H(K),W(K),CX(1,1,3),CX(1,1,4),
     1      RESULT(1,3,K),RESULT(1,4,K),RESFIX(1,3,K),RESFIX(1,4,K),
     1      TX(4),GTX(1,4),IREDUC,IMOD,
     1      IFILE,JJJ,MIDEND,WFLBUC(ILOAD,K))
         ELSE
          IF (MIDEND.EQ.1)
     1    CALL CRIPP2(K,ISTIF(K),B(1),H(K),W(K),CY(1,1,3),CY(1,1,4),
     1      RESULT(1,3,K),RESULT(1,4,K),RESFIX(1,3,K),RESFIX(1,4,K),
     1      TY(4),GTY(1,4),IREDUC,IMOD,
     1      IFILE,JJJ,MIDEND,WFLBUC(ILOAD,K))
         ENDIF
      ENDIF
C
  100 CONTINUE
C
C     WRITE(8,115) IMOD, INUMTT, (IPOINC(I),I=1,INUMTT)
  115 FORMAT(/' IMOD = ',I2,'   INUMTT = ', I2,'  IPOINC(I),I=1,..='/
     1 (10I10))
C
      RETURN
      END
C
C
C
C=DECK      CRIPPL
      SUBROUTINE CRIPPL(IFREE,ILOOP,ISEG,ISTIF,B,H,W,W2,C,NVAR,NFIX,
     1                  T,GT,IREDUC,IMOD,
     1                  A0,M,IFILE,ISTART,
     1                  ICRIP,JJJ,MIDEND,FLABUC)
C
C  PURPOSE IS TO FIND THE CRIPPLING MARGIN FOR A STIFFENER SEGMENT
C
      COMMON/OUTP/NPRT
      DIMENSION C(6,6)
      CHARACTER*8 CN
      CHARACTER*4 CNN
      CHARACTER*3 CM
      CHARACTER*7 CN2
      REAL NVAR,NFIX,LAMBDA,NUM1,NUM2,LAMB2
C
C     WRITE(8,*)' ILOOP,ISEG,NVAR=',ILOOP,ISEG,NVAR
      IF (ILOOP.EQ.1.AND.ISEG.EQ.2.AND.ICRIP.NE.0) GO TO 100
      IF (NVAR.GE.0.) RETURN
C
      ITYPE = IFREE + 1
      IF (ISTIF.NE.4) THEN
         IF (ISEG.EQ.3) WIDTH = H
         IF (ISEG.EQ.4) WIDTH = W
      ELSE
         IF (ISEG.EQ.1) THEN
            WIDTH = B - W2
            ITYPE = 1
         ENDIF
         IF (ISEG.EQ.2) WIDTH = W2
         IF (ISEG.EQ.3) WIDTH = SQRT(H*H + (W2-W)**2/4.)
         IF (ISEG.EQ.4) WIDTH = W
      ENDIF
C
      FACT = (3.1415927/WIDTH)**2
      C44C55 = SQRT(C(4,4)*C(5,5))
      IF (ITYPE.EQ.1) M = SQRT(C44C55*FACT/C(4,4))*A0/3.1415927
C
      GO TO (10,20),ITYPE
C
C  INTERIOR SEGMENT..
C
   10 CONTINUE
C
      NUM1    = 2.*FACT*(C44C55 + C(4,5) + 2.*C(6,6))
      GO TO 30
C
   20 CONTINUE
C
C  "END" SEGMENT...
C
      FMJ = FLOAT(M)*3.1415927/A0
      NUM1 = C(4,4)*FMJ**2 +12.*C(6,6)/WIDTH**2
C
   30 CONTINUE
C
      NUM2    = -(NUM1 + NFIX)
      LAMBDA  =  NUM2/NVAR
      LAMB2   = -NUM1/(NFIX + NVAR)
      IF (NUM2.GE.0.) THEN
         IF (IMOD.EQ.0) WRITE(IFILE,40) ISEG,NFIX
   40    FORMAT(/' *** NOTE **** NOTE **** NOTE ***'/
     1' STIFFENER SEGMENT NO.                           =',I2/
     1' AXIAL RESULTANT IN SEGMENT FROM LOAD SET B, NFIX=',1PE12.4/
     1' THIS AXIAL RESULTANT, NFIX, WILL CAUSE BUCKLING BY ITSELF.'/
     1' *** END NOTE **** END NOTE **** END NOTE ***'/)
         IF ((NFIX+NVAR).GT.0.) GO TO 100
         LAMBDA = LAMB2
         GO TO 50
      ENDIF
      IF (NVAR.GT.0.0) GO TO 100
   50 CONTINUE
      FSAFE  = 1.00
      EIGPRE = LAMBDA
      CN = '  ring  '
      IF (ILOOP.EQ.1) CN = 'stringer'
      CNN= 'MID.'
      IF (MIDEND.EQ.2) CNN = 'ENDS'
      IF (ISEG.EQ.1)  CN = '  skin  '
C     WRITE(8,*) ' M,LAMBDA=',M,LAMBDA
      CALL SHRRED(IREDUC,NVAR,0.,0.,T,T,GT,LAMBDA,0,1,JJJ)
C
      IF (ITYPE.EQ.2) FLABUC = LAMBDA
C
  100 CONTINUE
      IF ((IMOD.EQ.0.AND.JJJ.EQ.0.AND.NPRT.GE.1).OR.NPRT.GE.2) THEN
         IF(ILOOP.EQ.1.AND.ISEG.EQ.ISTART) WRITE(IFILE,110)
  110    FORMAT(/' ***  BUCKLING (short wavelength buckling) of parts of
     1 the panel module cross section perpendicular to generator ***')
         IF(ILOOP.EQ.2.AND.ISEG.EQ.ISTART) WRITE(IFILE,111)
  111    FORMAT(/' ***  BUCKLING (short wavelength buckling) of parts of
     1 the panel module cross section   parallel    to generator ***')
         IF (ISEG.EQ.ISTART) WRITE(IFILE,112)
  112    FORMAT(
     1' STIFFENER   MODULE    PRELOAD      APPLIED    BUCKLING       BUC
     1KLING   NO. OF BUCKLING HALFWAVES'/
     1'   TYPE     SEGMENT   RESULTANT    RESULTANT  LOAD FACTOR    LOAD 
     1 FACTOR    BETWEEN STIFFENERS'/
     1'                    (from curing            (no transverse (with 
     1transverse'/
     1'                   and Load Set B)           shear deform.) shear
     1 deformation)')
         IF (ILOOP.EQ.1.AND.ISEG.EQ.2.AND.ICRIP.NE.0) GO TO 200
         IF (IREDUC.NE.0)
     1   WRITE(IFILE,120) CN,ISEG,NFIX,NVAR,EIGPRE,LAMBDA,M
         IF (IREDUC.EQ.0)
     1   WRITE(IFILE,122) CN,ISEG,NFIX,NVAR,EIGPRE,M
  120    FORMAT(2X,A8,I6,1PE15.4,1PE13.4,1PE13.4,1PE15.4,I10)
  122    FORMAT(2X,A8,I6,1PE15.4,1PE13.4,1PE13.4,15X,I10)
      ENDIF
C
  200 CONTINUE
      RETURN
      END
C
C
C
C=DECK      CRIPP2
      SUBROUTINE CRIPP2(ILOOP,ISTIF,A0,H,W,C3,C4,NVAR3,NVAR4,
     1     NFIX3,NFIX4,T,GT,IREDUC,IMOD,
     1     IFILE,JJJ,MIDEND,WFLBUC)
C
C  PURPOSE IS TO FIND THE CRIPPLING MARGIN FOR A STIFFENER WEB AND
C  FLANGE BUCKLING TOGETHER, BUT WITH CORNER BETWEEN THEM NOT MOVING.
C
      COMMON/OUTP/NPRT
      DIMENSION C3(6,6),C4(6,6)
      CHARACTER*8 CN
      CHARACTER*4 CNN
      CHARACTER*3 CM
      CHARACTER*7 CN2
      REAL NVAR3,NVAR4,NFIX3,NFIX4,LAMBDA,NUM1,NUM2,LAMB2
      REAL NBAR,MBAR,NBAR2,MBAR2
C
      EIGPRE = 10.E+16
      LAMBDA = 10.E+16
      FSAFE  = 1.40
      CN = '  ring  '
      IF (ILOOP.EQ.1) CN = 'stringer'
      CNN= 'MID.'
      IF (MIDEND.EQ.2) CNN = 'ENDS'
C
C     WRITE(8,*)' NVAR3, NVAR4=',NVAR3,NVAR4
C     WRITE(8,*)' NFIX3, NFIX4=',NFIX3,NFIX4
C
      IF (NVAR3.GE.0.0.AND.NVAR4.GE.0.) RETURN
C
      PI = 3.1415927
      DEN = 12.
      IF (ISTIF.EQ.2) DEN = 3.
      NBAR = PI/H
      NBAR2 = NBAR*NBAR
      WS3 = (2.*PI*PI/DEN)*(W/H)**3
      FM = 1.0
      EIGSAV = 0.
   10 CONTINUE
      MBAR = FM*PI/A0
      MBAR2 = MBAR*MBAR
      NUM1 = C3(4,4)*MBAR2 +(2.*C3(4,5)+4.*C3(6,6))*NBAR2
     1      +C3(5,5)*NBAR2**2/MBAR2
     1      +C4(4,4)*MBAR2*WS3 +4.*C4(6,6)*NBAR2*2.*(W/H)
      ADDX = NFIX3 + WS3*NFIX4
      ADDV = NVAR3 + WS3*NVAR4
      NUM2    = -(NUM1 + ADDX)
      LAMBDA  =  NUM2/ADDV
      LAMB2   = -NUM1/(ADDX + ADDV)
      IF (NUM2.GE.0.) THEN
         IF (IMOD.EQ.0) WRITE(IFILE,40) NFIX3,NFIX4
   40    FORMAT(/' *** NOTE **** NOTE **** NOTE ***'/
     1' AXIAL RESULTANT IN SEGMENT3 FROM LOAD SET B, NFIX3=',1PE12.4/
     1' AXIAL RESULTANT IN SEGMENT4 FROM LOAD SET B, NFIX4=',1PE12.4/
     1' THESE AXIAL RESULTANTS WILL CAUSE BUCKLING BY THEMSELVES.'/
     1' *** END NOTE **** END NOTE **** END NOTE ***'/)
         IF ((ADDX+ADDV).GT.0.) GO TO 100
         LAMBDA = LAMB2
         GO TO 50
      ENDIF
      IF (ADDV.GT.0.0) GO TO 100
   50 CONTINUE
      M = FM
C     WRITE(IFILE,*)' ISTIF,M,ADDV,LAMBDA=',ISTIF,M,ADDV,LAMBDA
      IF (LAMBDA.LE.EIGSAV.OR.M.EQ.1) THEN
         EIGSAV = LAMBDA
         M = M + 1
         FM= M
         GO TO 10
      ELSE
         EIGPRE = EIGSAV
         M = M - 1
      ENDIF
C     WRITE(8,*) ' M,LAMBDA=',M,LAMBDA
      LAMBDA = EIGPRE
      CALL SHRRED(IREDUC,NVAR4,0.,0.,T,T,GT,EIGPRE,0,1,JJJ)
C     WRITE(8,*) ' EIGPRE=',EIGPRE
C
      WFLBUC = EIGPRE
C
  100 CONTINUE
      IF (EIGPRE.GT.10.E+15) GO TO 200
      IF ((IMOD.EQ.0.AND.JJJ.EQ.0.AND.NPRT.GE.1).OR.NPRT.GE.2) THEN
C        IF(ILOOP.EQ.1) WRITE(IFILE,110)
  110    FORMAT(/' Buckling of stringer segments 3 and 4 together:')
C        IF(ILOOP.EQ.2) WRITE(IFILE,111)
  111    FORMAT(/' Buckling of   ring   segments 3 and 4 together:')
         ISEG = 4
C        IF (IREDUC.NE.0)
C    1   WRITE(IFILE,120) CN,ISEG,NFIX4,NVAR4,LAMBDA,EIGPRE,M
C        IF (IREDUC.EQ.0)
C    1   WRITE(IFILE,122) CN,ISEG,NFIX4,NVAR4,LAMBDA,M
  120    FORMAT(2X,A8,I6,1PE15.4,1PE13.4,1PE13.4,1PE15.4,I10)
  122    FORMAT(2X,A8,I6,1PE15.4,1PE13.4,1PE13.4,15X,I10)
      ENDIF
C
  200 CONTINUE
      RETURN
      END
C
C
C
C=DECK      STRCON
      SUBROUTINE STRCON(ISTIF,NSEG,NLAYER,LTYPE,EALLOW,MATL,ANGLE,
     1                  B2,W2,T,TAPE,DEGRAD,
     1                  FSSTR,ETHERM,THERMX,THERMY,IMOD,
     1                  EPSLOD,ZPARTX,ZPARTY,ETHRMX,ETHRMY,CRACK,ICHANG,
     1                  EALLST,NPRINT,NAPPL,IFILE,ITYPE,IICHAN,
     1                  EPSTOT,EPSFIX,EPSEIG,IQUICK,INTEXT,MIDEND,
     1                  SIG1T,SIG1C,SIG2T,SIG2C,SIG12,ILOAD)
C
C  PURPOSE IS TO FIND STRESS CONSTRAINTS
C
      DIMENSION NSEG(*),NLAYER(4,2),LTYPE(99,5,2),EALLOW(5,10),MATL(*)
      DIMENSION EALLST(5,10),NAPPL(3),INTEXT(*)
      DIMENSION ISTIF(*),ANGLE(*)
      DIMENSION B2(*),W2(*),T(*),TAPE(*)
      DIMENSION DEGRAD(10,5,10),EPSLOD(*),ZPARTX(*),ZPARTY(*)
      DIMENSION ETHERM(*),THERMX(6,5),THERMY(6,5)
      DIMENSION ETHRMX(6,5),ETHRMY(6,5),ETPART(6),CRACK(99,5,2)
      DIMENSION EPSTOT(3,5,2),EPSFIX(3,5,2),EPSEIG(3,5,2)
      DIMENSION SIG1T(20,5),SIG1C(20,5)
      DIMENSION SIG2T(20,5),SIG2C(20,5),SIG12(20,5)
      COMMON/MATER1/E1(20),E2(20),G(20),FNU(20),DENS(20)
      COMMON/MATERT/ALPHA1(20),ALPHA2(20),CURETP(20),ICOCUR(2)
      COMMON/ALLCIJ/CX(6,6,5),CY(6,6,5),CS(6,6)
      COMMON/LOADS/FNX,FNY,FNXY,RESULT(3,5,2)
      COMMON/GEOM6/IFAY(2),IMISCL(28)
      CHARACTER*3 STRRNG
      CHARACTER*15 MODE(7)
      REAL NAPPL
C
      DO 100 ILOOP = 1,2
C
C        IF (ILOOP.EQ.1) STRRNG = 'STR'
C        IF (ILOOP.EQ.2) STRRNG = 'RNG'
      ISTART = 1
      IEND   = NSEG(ILOOP)
      IF (ILOOP.EQ.2) ISTART = 2
      IF (ISTART.GT.IEND) GO TO 100
C     IF (ITYPE.EQ.2.AND.IICHAN.EQ.0.AND.NPRINT.GE.1) THEN
C        MODE(1) = ' 0 deg. tension'
C        MODE(2) = ' 0 deg. comp.  '
C        MODE(3) = '90 deg. tension'
C        MODE(4) = '90 deg. comp.  '
C        MODE(5) = ' in-plane shear'
C        MODE(6) = '  no failure   '
C        MODE(7) = 'von-mises yield'
C
C        CALL PICTS(IFILE,ISTIF(ILOOP),INTEXT(ILOOP),B2(ILOOP),
C    1              W2(ILOOP),ILOOP,IFAY(ILOOP))
C        WRITE(IFILE,24)
C  24    FORMAT(/' Start calculation of stresses in the panel module dep
C    1icted above...'/
C    1' (Segment numbering below refers to the topmost of the sketches a
C    1bove.)'/
C    1'    SEG. LAYER  WINDING    IN-PLANE STRESSES IN MATL COORDS.   MA
C    1TERIAL    MODE OF   TRANSVERSE CRACKING  ALLOWABLE  MATERIAL'/
C    1'                 ANGLE      SIG1        SIG2        SIG12       S
C    1TATUS     FAILURE   (1.0 means inactive)  STRESS     TYPE')
C     ENDIF
C
      DO 60 I = ISTART,IEND
C
      NLAY = NLAYER(I,ILOOP)
C
      DO 30 J = 1,NLAY
C
      K = LTYPE(J,I,ILOOP)
      IF (T(K).EQ.0.) GO TO 30
      M = MATL(K)
      A1T = ALPHA1(M)*(-CURETP(M))
      A2T = ALPHA2(M)*(-CURETP(M))
      ICRACK = 0
C     IF (TAPE(M).GT.0.) ICRACK = 1
C     IF (IMOD.EQ.0) CALL NEWMAX(M,K,T,TAPE,DEGRAD,EALLOW,EALLST(1,M))
C
      EX = EPSTOT(1,I,ILOOP)
      EY = EPSTOT(2,I,ILOOP)
      EXY= EPSTOT(3,I,ILOOP)
C
      CALL STRAIN(ILOOP,I,J,EX,EY,EXY,ANGLE(K),EALLST(1,M),
     1       FSSTR,A1T,A2T,E1(M),E2(M),G(M),FNU(M),
     1       IMOD,CRACK(J,I,ILOOP),ICRACK,ICHANG,STRRNG,
     1       IFILE,NPRINT,MODE,ITYPE,M,IICHAN,MIDEND,
     1       SIG1T(ILOAD,M),SIG1C(ILOAD,M),SIG2T(ILOAD,M),
     1       SIG2C(ILOAD,M),SIG12(ILOAD,M))
C
   30 CONTINUE
   60 CONTINUE
  100 CONTINUE
C
      RETURN
      END
C
C
C
C=DECK      STRAIN
      SUBROUTINE STRAIN(ILOOP,ISEG,ILAY,EX,EY,EXY,ANGLE,EALLOW,
     1             FSSTR,A1T,A2T,E1,E2,G,U12,
     1             IMOD,CRACK,ICRACK,ICHANG,STRRNG,IFILE,
     1             NPRINT,MODE,ITYPE,M,IICHAN,MIDEND,
     1             SIG1T,SIG1C,SIG2T,SIG2C,SIGSH)
C
C  PURPOSE IS TO CALCULATE STRAIN MARGINS IN A SINGLE LAYER
C
      COMMON/MATER7/ISOMAT(20),ISOEFF(20)
      DIMENSION EALLOW(*)
      CHARACTER*3 STRRNG
      CHARACTER*15 MODE(7)
      CHARACTER*2 SN, CN
      CHARACTER*6 STATUS
      CHARACTER*7 CN2
      CHARACTER*4 CNN
      CHARACTER*2 CJ
C
      DATA DTR /.017453293/
C
      ARG = ANGLE*DTR
      CS1 = COS(ARG)
      CS2 = SIN(ARG)
      CALL ROTATE(CS1,CS2,EX,EY,EXY,EPS1,EPS2,EPS12)
C
      U21 = 0.
      IF (E2.GT.0.) U21 = U12*E1/E2
      UD = 1. - U12*U21
      SIG1 = (    E1*(EPS1-A1T) +U12*E1*(EPS2-A2T))/UD
      SIG2 = (U12*E1*(EPS1-A1T) +    E2*(EPS2-A2T))/UD
      SIG12= G*EPS12
C
C     IF (IMOD.EQ.0) THEN
C        WRITE(8,*)' ILAY,SIG1,SIG2=',ILAY,SIG1,SIG2
C     ENDIF
C
      CALL CONVRT(M,CJ)
C
      IF (ISOMAT(M).EQ.1) THEN
         IMIN    = 3
         IMAX    = 3
         SIGEFF  = SQRT(SIG1**2 +SIG2**2 -SIG1*SIG2 +3.*SIG12**2)
         SIGTST  = SIGEFF
         GO TO 5
      ELSE
         IMIN    = 1
         IMAX    = 5
         SIGTST  = SIG1
      ENDIF
C
      CRACKD = 1.0
      RATIO  = 1.1
C     IF (SIG2.GT.0.) RATIO = EALLOW(3)/SIG2
      REDCOM = 1.0
      REDSHR = 1.0
      IF (RATIO.LT.1.0.AND.ICRACK.EQ.1) THEN
         CRACKD = RATIO
         IF (SIG1.LT.0.) THEN
            REDCOM = 0.5
            REDSHR = 0.8
         ENDIF
      ENDIF
C
    5 CONTINUE
C
      CNN = 'MID.'
      IF (MIDEND.EQ.2) CNN = 'ENDS'
      CALL CONVRF(FSSTR,CN2)
      ISKIP = 0
C
      DO 200 I = IMIN,IMAX
C
      GO TO (30,40,10,20,50), I
C
   10 CONTINUE
C
      INDEX = 1
      IF (SIGTST.LE.0.) GO TO 100
C     RATIO = ABS(EALLOW(1)/(SIGTST*FSSTR))
C     CALL ELIMIN(RATIO,IBEG,ICONST,CONSTR,IELIM)
C     IF (IELIM.EQ.1) GO TO 100
C     WRITE(8,*)' E1-TENSION, ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)=',
C    1                        ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)
C     IF (IMOD.EQ.0.AND.RATIO.GT.FMAX) GO TO 100
C     IF (IMOD.EQ.1.AND.IPOINC(INUMTT).EQ.0) GO TO 100
C     IF (IMOD.EQ.0) IPOINC(INUMTT) = 1
C     ICONST = ICONST + 1
C     CONSTR(ICONST) = RATIO
C     IF (IMAX.EQ.5) WORDB(ICONST) =
C    1 'tensile fiber: (allowable stress)/(actual stress)-1, matl '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IF (IMAX.EQ.3) WORDB(ICONST) =
C    1 'effective stress margin: (allowable)/(actual) - 1,   matl '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IADDB(ICONST) = ILOOP + 10*ISEG + 100*ILAY
      SIG1T = MAX(SIGTST,SIG1T)
      GO TO 100
   20 CONTINUE
C
      INDEX = 2
      IF (SIG1.GE.0.) GO TO 100
C     RATIO = ABS(EALLOW(2)*REDCOM/(SIG1*FSSTR))
C     CALL ELIMIN(RATIO,IBEG,ICONST,CONSTR,IELIM)
C     IF (IELIM.EQ.1) GO TO 100
C     WRITE(8,*)' E1-COMPRES, ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)=',
C    1                        ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)
C     IF (IMOD.EQ.0.AND.RATIO.GT.FMAX) GO TO 100
C     IF (IMOD.EQ.1.AND.IPOINC(INUMTT).EQ.0) GO TO 100
C     IF (IMOD.EQ.0) IPOINC(INUMTT) = 1
C     ICONST = ICONST + 1
C     CONSTR(ICONST) = RATIO
C     WORDB(ICONST) =
C    1 'compressive fiber: (allowable stress)/actual-1, matl type '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IADDB(ICONST) = ILOOP + 10*ISEG + 100*ILAY
      SIG1C = MAX(ABS(SIG1),SIG1C)
      GO TO 100
   30 CONTINUE
C
      INDEX = 3
      IF (SIG2.LE.0.) GO TO 100
C     RATIO = ABS(EALLOW(3)/(SIG2*FSSTR))
C     RAT2  = RATIO*FSSTR
C     IF (IMOD.EQ.0) WRITE(8,*)' RAT2,CRACK,ICHANG=',RAT2,CRACK,ICHANG
C     IF (IMOD.EQ.0.AND.ICRACK.EQ.1)CALL CRAKNG(RAT2,SIG1,CRACK,ICHANG,
C    1                                          0)
C     IF (IMOD.EQ.0) WRITE(8,*)' AFTER:CRACK,ICHANG=',CRACK,ICHANG
C     IF (ICRACK.EQ.1) GO TO 100
C     CALL ELIMIN(RATIO,IBEG,ICONST,CONSTR,IELIM)
C     IF (IELIM.EQ.1) GO TO 100
C     WRITE(8,*)' E2-TENSION, ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)=',
C    1                        ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)
C     IF (IMOD.EQ.0.AND.RATIO.GT.FMAX) GO TO 100
C     IF (IMOD.EQ.1.AND.IPOINC(INUMTT).EQ.0) GO TO 100
C     IF (IMOD.EQ.0) IPOINC(INUMTT) = 1
C     ICONST = ICONST + 1
C     CONSTR(ICONST) = RATIO
C     WORDB(ICONST) =
C    1 'tensile transverse stress marg.:(allowable/actual)-1,matl '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IADDB(ICONST) = ILOOP + 10*ISEG + 100*ILAY
      SIG2T = MAX(SIG2,SIG2T)
      GO TO 100
   40 CONTINUE
C
      INDEX = 4
      IF (SIG2.GE.0.) GO TO 100
C     IF (IMOD.EQ.0.AND.ICRACK.EQ.1)CALL CRAKNG(5.,SIG1,CRACK,ICHANG,0)
C     RATIO = ABS(EALLOW(4)/(SIG2*FSSTR))
C     CALL ELIMIN(RATIO,IBEG,ICONST,CONSTR,IELIM)
C     IF (IELIM.EQ.1) GO TO 100
C     WRITE(8,*)' E2-COMPRES, ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)=',
C    1                        ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)
C     IF (IMOD.EQ.0.AND.RATIO.GT.FMAX) GO TO 100
C     IF (IMOD.EQ.1.AND.IPOINC(INUMTT).EQ.0) GO TO 100
C     IF (IMOD.EQ.0) IPOINC(INUMTT) = 1
C     ICONST = ICONST + 1
C     CONSTR(ICONST) = RATIO
C     WORDB(ICONST) =
C    1 'compres. transverse stress margin: (allow./actual)-1,matl '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IADDB(ICONST) = ILOOP + 10*ISEG + 100*ILAY
      SIG2C = MAX(ABS(SIG2),SIG2C)
      GO TO 100
   50 CONTINUE
C
      INDEX = 5
      IF (SIG12.EQ.0.) GO TO 100
C     RATIO = ABS(EALLOW(5)*REDSHR/(SIG12*FSSTR))
C     CALL ELIMIN(RATIO,IBEG,ICONST,CONSTR,IELIM)
C     IF (IELIM.EQ.1) GO TO 100
C     WRITE(8,*)' IN-PL-SHEAR, ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)=',
C    1                        ILOOP,ISEG,ILAY,INUMTT,IPOINC(INUMTT)
C     IF (IMOD.EQ.0.AND.RATIO.GT.FMAX) GO TO 100
C     IF (IMOD.EQ.1.AND.IPOINC(INUMTT).EQ.0) GO TO 100
C     IF (IMOD.EQ.0) IPOINC(INUMTT) = 1
C     ICONST = ICONST + 1
C     CONSTR(ICONST) = RATIO
C     WORDB(ICONST) =
C    1 'in-plane shear stress margin: (allowable/actual)-1,  matl '
C    1//CJ//' '//CNN//'; F.S.='//CN2
C     IADDB(ICONST) = ILOOP + 10*ISEG + 100*ILAY
      SIGSH = MAX(ABS(SIG12),SIGSH)
C
  100 CONTINUE
C
  200 CONTINUE
C
      RETURN
      END
C
C
C
C=DECK      ROTATE
      SUBROUTINE ROTATE(C,S,EX,EY,EXY,E1,E2,E12)
C
C  PURPOSE IS TO TRANSFORM STRAINS FROM (AXIAL,TRANSVERSE = EX,EY)
C  SYSTEM TO MATERIAL COORDINATES (E1,E2).  WINDING ANGLE = ANGLE
C
      C2 = C*C
      S2 = S*S
      SC = S*C
C
C  E1, E2, E12 ARE STRAIN COMPONENTS IN MATERIAL COORDINATES...
C
      E1 = C2*EX + S2*EY + SC*EXY
      E2 = S2*EX + C2*EY - SC*EXY
      E12= -2.*SC*(EX - EY) + (C2-S2)*EXY
C
      RETURN
      END
C
C
C
C=DECK      ROTATS
      SUBROUTINE ROTATS(C,S,SX,SY,SXY,SIG1,SIG2,SIG12)
C
C  PURPOSE IS TO TRANSFORM STRESSES FROM (AXIAL,TRANSVERSE = SX,SY)
C  SYSTEM TO MATERIAL COORDINATES (SIG1,SIG2).  WINDING ANGLE = ANGLE
C
      C2 = C*C
      S2 = S*S
      SC = S*C
C
C  SIG1, SIG2, SIG12 ARE STRESS COMPONENTS IN MATERIAL COORDINATES...
C
      SIG1 = C2*SX + S2*SY + 2.*SC*SXY
      SIG2 = S2*SX + C2*SY - 2.*SC*SXY
      SIG12= -SC*(SX - SY) + (C2-S2)*SXY
C
      RETURN
      END
C
C
C
C=DECK      IDSEG
      SUBROUTINE IDSEG(ISTIF,ISEG,NSEGB5,B2,W2,J)
C
C  PURPOSE IS TO GET INDEX J FOR WALL PROPERTIES OF BOSOR5 SEGMENT NO.
C  ISEG.
C
      COMMON/GEOM6/IFAY(2),IMISCL(28)
      J = 1
      IF (ISTIF.NE.4) THEN
         IF (ISEG.NE.NSEGB5) J = ISEG
      ELSE
         IF (ISEG.EQ.2) J = ISEG
         IF (B2.GT.W2) THEN
            IF (ISEG.GE.3.AND.ISEG.LE.5) J = ISEG-1
            IF (ISEG.EQ.6) J = 3
            IF (ISEG.EQ.7) J = 2
            IF (IFAY(1).EQ.1.AND.ISEG.EQ.3) J = 1
         ELSE
            IF (ISEG.EQ.3) J = ISEG
            IF (ISEG.EQ.4) J = ISEG
            IF (ISEG.EQ.5) J = 3
         ENDIF
      ENDIF
C
      RETURN
      END
C
C
C
C=DECK      CHGCIJ
      SUBROUTINE CHGCIJ(COLD,CNEW)
C
C  PURPOSE IS TO SHUFFLE C(I,J) TO ACCOUNT FOR THE FACT THAT THE "1"
C  DIRECTION IN THE PANEL IS ACTUALLY THE "2" DIRECTION IN STABIL AND
C  VISA VERSA
C
      DIMENSION COLD(6,6),CNEW(6,6)
C
      DO 10 I = 1,6
      DO 10 J = 1,6
   10 CNEW(I,J) = COLD(I,J)
C
      CNEW(1,1) = COLD(2,2)
      CNEW(2,2) = COLD(1,1)
      CNEW(4,4) = COLD(5,5)
      CNEW(5,5) = COLD(4,4)
      CNEW(1,4) = COLD(2,5)
      CNEW(2,5) = COLD(1,4)
      CNEW(4,1) = CNEW(1,4)
      CNEW(5,2) = CNEW(2,5)
      CNEW(5,1) = CNEW(1,5)
      CNEW(4,2) = CNEW(2,4)
C
      CNEW(1,3) = 0.
      CNEW(3,1) = 0.
      CNEW(1,6) = 0.
      CNEW(6,1) = 0.
      CNEW(2,3) = 0.
      CNEW(3,2) = 0.
      CNEW(2,6) = 0.
      CNEW(6,2) = 0.
      CNEW(3,4) = 0.
      CNEW(4,3) = 0.
      CNEW(3,5) = 0.
      CNEW(5,3) = 0.
      CNEW(3,6) = -COLD(3,6)
      CNEW(6,3) = CNEW(3,6)
      CNEW(4,6) = 0.
      CNEW(6,4) = 0.
      CNEW(5,6) = 0.
      CNEW(6,5) = 0.
C
      RETURN
      END
