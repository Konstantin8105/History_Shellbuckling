C=DECK      B4READLIB
C
C  THIS IS THE B4READ LIBRARY (SOURCE FILE)
C
C
C=DECK      B4READ
C
C      THIS IS THE MAIN PROGRAM OF THE BOSOR4 PREPROCESSOR.
C
      PROGRAM B4READ
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
#if hp700
$hp9000_800 intrinsics
#endif
C BEG SEP 1997
      COMMON/FLUTNK/GAMMAF,AXLONG,RBIG,ZBEGIN
      COMMON/NUMTNK/IFLSEG(95)
      COMMON/PRMOUT/IFILE3,IFILE4
C END SEP 1997
      COMMON/GLOBAL/IDZ,IZRING(98),ISAVE(20),INOTE
      COMMON/STRHD/NSHEAD
      COMMON/COUNTR/NKOUNT
      COMMON/PAXTAX/ PAXIAL(4,50),TAXIAL(3,50)
      COMMON/LOADHM/NLPOS(95),LAB(95),IDAB(95),ILPOS(12,95),PALL(6000)
      COMMON/NLINS/NSTART,NFIN
      COMMON/DSPACE/IDS
      COMMON/ENDOF/NLAST,NFIRST,NEDPLT
      COMMON/IIFIFE/IIIF
      COMMON/RGFCE/RHF(98)
      COMMON/PSTSS/IPSTS(95)
      COMMON/SMOAD/IMOAD(100),IPMODE(95),IPSMD(95)
      COMMON/LRANGE/FSTART,FMAX,DF
      COMMON/DETER/DET,NEX
      COMMON/TESTIT/NTEST
      COMMON/ITERAT/IMODE
      COMMON/TOTPTS/M3
      COMMON/WAVES/N0,N,NMIN,NMAX,INCR
      COMMON/FORCES/V(98),HF(98),FM(98)
      COMMON/EIGENV/P,OMG2,RHO
      COMMON/SEGS/NSEG,M2,I5(95),I2,I2G
      COMMON/IDENT/IPRW(20)
      COMMON/HYDRO/PRAD,RV
      COMMON/BLKP/IBLKP,NGBKP(20),NKFP(20)
      COMMON/RGTEMP/TNR(98),TMR(98),TMRX(98)
      COMMON/STEPS/STEP,STEP1(98),STEP2(98),STEP3(98)
      COMMON/INSTAB/INDIC
      COMMON/MAXSTP/STEPM,STEPMI,RHOM
      COMMON/ERROR/ERR
      COMMON/NFAC/NFACT,NDIC
      COMMON/ITERS/ITER
      COMMON/ALFAT/ALPHAT
      COMMON/POSDEF/ IDIAG
      COMMON/EIGNO/NVEC,EGV(50),AXB
      COMMON/IDVEC/IPV1(50),IPV2(50)
      COMMON/IDEIG/ IDMODE(500),NVECTL,EIGENW(500)
      COMMON/SIG/NFLAGI
      COMMON/OUTP/ NPRT
      COMMON/BLK/IBLK,NGBK(20),NFK(20)
      COMMON/BCK/IDRW(20,5)
      COMMON/SFLAG/ MONOQ
      COMMON/SHEL/ISHL(95),IWAL(95),ITHK(95),IARC(95),ILOAD(95)
      COMMON/INTRG/NSTATN(95),IRING(95,20)
      COMMON/IDZREF/IZREF(95)
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/TEMTUR/TEMP,DTEMP
c Modified 1/14/90
      COMMON/SIGNALL/ISIG
c end 1/14/90 modification
      COMMON/ORTA/IFLGG,KTM,KROOTS
      COMMON/INTRVL/ INTVAL(95),IOUT,NDIST,NCIRC,NTHETA
      COMMON/XID/IDX
      COMMON/BUCKN/ N0B,NMINB,NMAXB,INCRB
      COMMON/LOCATN/ILOCP,ILOCB,IROWCP(98),IROWCB(98),IIWP,IIWB
      COMMON/NCONDS/NCOND
      COMMON/IHIGH/ITOOHI
      COMMON/LSTEPS/ISTEP
C BEG JULY 1989
      COMMON/PRERT/PREROT,SIGNLL,IPREBK
C END JULY 1989
      COMMON/NOHARM/NHARM
      COMMON/IFRHX/IFB,RHFIX(98),K,MNUMB,ISWTCH,KNT,IFTOT,INDSIG,LFIX
      COMMON/PLTSIG/IPLOT,JPLOT,KPLOT(20),LPLOT(20),MPLOT,RN(20),ZN(20)
      COMMON/VCTRSB/NVECRL(50)
      COMMON/IOCHOZ/IOYES(50),IOSEG(95)
      COMMON/IDHIGH/IDMAX
      COMMON/STRSEG/ISTRSS(95)
      COMMON/NLAMIN/LAMINA(95)
      COMMON/NVVIB/NVIB
C BEG APR 1992
      COMMON/JWATCH/JOLD
      COMMON/ILVARS/ILVAR(11,95),ITREF(95),NLVAR(95),ITIO(95)
C END APR 1992
      common/caseblock/case
      character*28 case
      character*32 fname
      logical exists
#if hp700
      call getarg(2, case)
#else
      call getarg(1, case)
#endif
C
C     IBM SUBROUTINE ERRSET IS CALLED TO SUPPRESS THE UNDERFLOW ERROR
C     MESSAGE NO.208.
C
C      CALL ERRSET(208,0,-1,0,0,0)
C
      CALL MAIN1
C
C     INITIALIZE CLOCK.
      CALL SR100T(1)
C
      IIIF=21
      NEDPLT=-1
C
10    CONTINUE
C     INITIALIZE DRUM
      NVIB = 0
      NFIRST = 0
      IDMAX = 0
C
C     INITIALIZATION OF VARIOUS PROGRAM QUANTITIES.
C
      CALL GASP(DUM1,DUM2,-1,DUM3)
C
      IPLOT = 1
      IPREBK = 0
      IDZ = 0
C BEG JULY 1989
      SIGNLL = 0.
C END JULY 1989
      DIV = 1000.
      STEPMS = 0.0
      IPREB2 = 0
      ITOOHI = 0
      MNUMB = 0
      NKOUNT = 0
      IDS = 0
      IDX = 0
      IFLGG = 0
      ITRACK = 0
      KNT = 0
      INDSIG = 0
      IFIN = 0
      IFTOT = 0
      ILOCP = 0
      ILOCB = 0
      IIWP = 0
      IIWB = 0
      IFB = 0
C BEG APR 1992
      JOLD = 0
C END APR 1992
      DO 40 I=1,20
      IPRW(I) = 0
      NGBK(I) = 0
      NFK(I) = 0
      NGBKP(I) = 0
      NKFP(I) = 0
      DO 30 J=1,5
30    IDRW(I,J) = 0
40    CONTINUE
      DO 50 I=1,98
      RHF(I) = 0.
      RHFIX(I) = 0.
   50 CONTINUE
      DO 51 I = 1,50
      NVECRL(I) = 0
      IOYES(I) = 0
      IPV1(I)  = 0
      IPV2(I)  = 0
   51 CONTINUE
      DO 53 I = 1,100
   53 IMOAD(I) = 0
      DO 55 I = 1,500
      IDMODE(I) = 0
55    EIGENW(I) = 0.
      DO 60 I=1,95
      ISHL(I) = 0
      IWAL(I) = 0
      ITHK(I) = 0
      IARC(I) = 0
      ILOAD(I) = 0
      IPMODE(I) = 0
      IPSMD(I) = 0
      IZREF(I) = 0
      IOSEG(I) = 0
      ISTRSS(I) = 0
      LAMINA(I) = 0
C BEG APR 1992
      ITREF(I) = 0
      NLVAR(I) = 0
      ITIO(I)  = 0
      DO 58 J = 1,11
   58 ILVAR(J,I) = 0
C END APR 1992
C BEG SEP 1997
      IFLSEG(I) = 0
C END SEP 1997
   60 CONTINUE
C
C     DATA READ IN FOR NEXT CASE
C     LINK 1 CALLED INTO CORE WITH READIT.
C
      ISWTCH = 1
C     CALL OVERLAY(5HBOSOR,1,0)
      CALL READIT
      IF (INDIC.LE.0) NVEC = 1
C
      IFILE = 9
c open/close statments added 6/91
      fname = case(1:index(case, ' ')-1)//'.BLK'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
        OPEN(UNIT=IFILE, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='OLD')
#if rs6k
        rewind(IFILE)
#endif
      else
	OPEN(UNIT=IFILE, FILE=fname, FORM='UNFORMATTED',
     1       STATUS='NEW')
      endif
      CALL STOCM1(IFILE)
      CALL STOCM2(IFILE)
      CLOSE(IFILE)
c end 6/91 changes
C
*     CALL GASP(DUM1,DUM2,-2,DUM3)
c Comments added 6/91
c     CLOSE(IFILE)
c     CLOSE(IFILE2)
c     CLOSE(IFILE3)
c     CLOSE(IFILE4)
c     CLOSE(3)
c End 6/91
c Added 11/90 to clear IEEE FPE warnings
      call ieeexx
c End 11/90
      END
C=DECK      MESH  
      SUBROUTINE MESH(NMESH,DS,DSTOT,ISEG)
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C     CALLED FROM READIT, WHICH IS CALLED FROM MAIN   
C     MESH POINT DISTRIBUTION IN ISEGTH SEGMENT IS DETERMINED.    
C     SPACING CAN VARY, OF COURSE.  
      COMMON/INTRVL/ INTVAL(95),IIOUT,NDIST,NCIRC,NTHETA     
      DIMENSION IHVALU(100),HVALU(100),FI(100),DS(100),DW(100)    
      COMMON/PRMFIL/IFILE,IFILE2,IOUT,IPRM(5)
      CHARACTER*4 CHARAC
10    FORMAT(10I6)                                          
20    FORMAT(6E12.8)                                        
C     MEANINGS OF THESE INPUT VARIABLES GIVEN BELOW   
      IFACT = 0
      INTVAL(ISEG) = 0
   25 CONTINUE
      REWIND IFILE2
      IF (ISEG.EQ.1)
     1CALL DATUM(IFILE2,100,0,0,INT,REALL,CHARAC,IOUT,0,1)
      WRITE(IOUT,35) ISEG,ISEG,ISEG,ISEG,ISEG,ISEG,ISEG,ISEG
   35 FORMAT(6X,'H',9X,'$'/6X,'H',9X,'$ SEGMENT NUMBER',8I5)
      WRITE(IOUT,5)
    5 FORMAT(6X,'H',9X,'$ NODAL POINT DISTRIBUTION FOLLOWS...')
      CALL DATUM(IFILE2,101,1,2,NMESH,REALL,CHARAC,IOUT,ISEG,1)
C
      IF (IFACT.LT.2) FACT = 1./20. 
      IF (IFACT.GE.2) FACT = 1./FLOAT(IFACT)    
      IF (INTVAL(ISEG).EQ.0) INTVAL(ISEG) = 1   
      IF (NMESH.GT.2.AND.NMESH.LE.98) GO TO 40  
      WRITE (6,30)
30    FORMAT(//88H NUMBER OF MESH POINTS IN A SEGMENT MUST BE GREATER TH
     1AN 4 AND LESS THAN OR EQUAL TO 98     //)
      GO TO 25
40    CONTINUE    
C     
C     NMESH = NUMBER OF MESH POINTS IN CURRENT SEGMENT
C     NTYPEH = POINTER FOR TYPE OF MESH SPACING INPUT TO FOLLOW---
C     NTYPEH = 1 -- 'NORMALIZED' VALUES OF SPACING READ IN FOR A FEW    
C                   SCATTERED STATIONS AND SPACING EVERYWHERE     
C                   DETERMINED BY LINEAR INTERPOLATION BETWEEN CALLOUTS 
C     NTYPEH = 2- - MESH SPACING READ IN FOR ALL POINTS IN SEGMENT
C     NTYPEH = 3- - MESH SPACING CONSTANT IN CURRENT SEGMENT.     
C     
C     INTVAL(ISEG) SIGNIFIES PRINT AND PLOT OUTPUT FOR EVERY
C     INTVAL(ISEG)TH MESH POINT     
C     
      NMESH1 = NMESH - 1
      CALL DATUM(IFILE2,102,1,3,NTYPEH,REALL,CHARAC,IOUT,0,1)
      GO TO (50,90,100),NTYPEH
C     NHVALU = NO. OF MERIDIONAL STATIONS AT WHICH MESH SPACING HVALU   
C              IS TO BE SPECIFIED.  
C     IHVALU = MESH POINT TAG AT WHICH HVALU  IS TO BE SPECIFIED  
C     HVALU = MESH POINT SPACING (BETWEEN W-POINTS. AT CALLOUT IHVALU.  
C             SPACING WILL VARY LINEARLY BETWEEN STATIONS AT WHICH
C             IT IS CALLED OUT. IT IS EMPHASIZED THAT THIS SPACING
C             REFERS TO THE ARC LENGTH DISTANCE BETWEEN ADJACENT  
C             W-POINTS. 
   50 CONTINUE
      CALL DATUM(IFILE2,103,1,2,NHVALU,REALL,CHARAC,IOUT,0,1)
      DO 55 I = 1,NHVALU
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE2,104,1,2,IHVALU(I),REALL,CHARAC,IOUT,I,IPROMP)
   55 CONTINUE
      IF (IHVALU(1).EQ.1.AND.IHVALU(NHVALU).EQ.NMESH1) GO TO 70   
      WRITE (6,60)
60    FORMAT(//61H MESH SPACING CALLOUTS MUST INCLUDE VALUES AT ENDS OF 
     1SEGMENT   //)
      REWIND IFILE2
      GO TO 50
70    CONTINUE    
      DO 75 I = 1,NHVALU
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE2,105,1,2,INT,HVALU(I),CHARAC,IOUT,I,IPROMP)
   75 CONTINUE
      DO 80 I=1,NMESH   
80    FI(I) = I   
      CALL FINDZ(NHVALU,IHVALU,HVALU,NMESH1,DW,FI)    
      GO TO 120   
   90 CONTINUE
      DO 95 I = 1,NMESH1
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE2,105,1,2,INT,DW(I),CHARAC,IOUT,I,IPROMP)
   95 CONTINUE
      GO TO 120   
100   DO 110 I=1,NMESH1 
110   DW(I) = 1.0 
120   DSTOT = 0.0 
      DO 130 I=1,NMESH1 
130   DSTOT = DSTOT + DW(I)   
      DO 140 I=3,NMESH1 
      I1 = I - 1  
140   DS(I) = DW(I1)    
      DS(1) = FACT*DW(1)
      DS(2) = (1.-FACT)*DW(1) 
      NMESHP = NMESH + 1
      DS(NMESHP) = FACT*DW(NMESH1)  
      DS(NMESH) = (1.-FACT)*DW(NMESH1)    
      DO 150 I=1,NMESHP 
150   DW(I) = DS(I)     
      NMESH = NMESHP + 1
      NMESH1 = NMESHP   
      DO 160 I=2,NMESH1 
      I1 = I - 1  
160   DS(I) = (DW(I1) + DW(I))/2.   
      DS(1) = DW(1)     
      DS(NMESH) = DW(NMESH1)  
C     DS(I) NOW CONTAINS THE ENERGY INTEGRATION WEIGHTS OR LENGTHS
C     OF THE FINITE-DIFFERENCE 'ELEMENTS'.
      RETURN
      END   
C=DECK      OUTAX
C     OVERLAY (2,2)
      SUBROUTINE OUTAX(I,I5,P ,THERM,S)
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
      DIMENSION  P(I5,6),THERM(I5,8),S(*)
      COMMON/OUTP/NPRT
      COMMON/INSTAB/INDIC
      COMMON/PRMFIL/IFILE,IFILE2,IOUT,IPRM(5)
      COMMON/PRMOUT/IFILE3,IFILE4
      COMMON/INDAT/INFILE
      CHARACTER*4 ANSOUT
      LOGICAL ANSL1
      CALL DATUM(IFILE3,610,1,1,INT,REALL,ANSOUT,IOUT,0,1)
      IF (ANSL1('N',ANSOUT,INFILE)) GO TO 110
      IF (INDIC.NE.3) GO TO 70
      DO 65 IL = 1,2
      IF (IL.EQ.1) WRITE (IFILE4,10)
      IF (IL.EQ.2) WRITE (IFILE4,15)
      WRITE(IFILE4,30)
10    FORMAT(//5X,' NONSYMMETRIC DISTRIBUTED MECHANICAL AND THERMAL LOAD 
     1 COMPONENTS FOLLOW. AXIAL DISTRIBUTIONS.   LOAD SET A ')
15    FORMAT(//5X,' NONSYMMETRIC DISTRIBUTED MECHANICAL AND THERMAL LOAD 
     1 COMPONENTS FOLLOW. AXIAL DISTRIBUTIONS.   LOAD SET B ')
      WRITE (IFILE4,20)
20    FORMAT('       STATION           PU           PV           PW
     1           TN1         TN2          TM1          TM2        '/)
30    FORMAT(25X,' AXIAL DISTRIBUTION OF LOAD COMPONENTS FOR ALL CIRCUMF
     1ERENTIAL HARMONICS')
      WRITE (IFILE4,40)I
40    FORMAT(/40X,' LOAD COMPONENTS FOR SEGMENT NO. ',I3/)
      DO 60 K=1,I5
      IF (IL.EQ.1) THEN
      WRITE (IFILE4,50)K,S(K),P(K,1),P(K,2),P(K,3),THERM(K,1),
     1 THERM(K,2),THERM(K,3),THERM(K,4)
      ELSE
      WRITE (IFILE4,50)K,S(K),P(K,4),P(K,5),P(K,6),THERM(K,5),
     1 THERM(K,6),THERM(K,7),THERM(K,8)
      ENDIF
50    FORMAT(I5,1P8E13.4)                              
60    CONTINUE
65    CONTINUE
      GO TO 110
70    CONTINUE
C     WRITE OUT SYMMETRIC MECHANICAL AND THERMAL LOADS
      DO 105 IL = 1,2
      IF (IL.EQ.1) WRITE (IFILE4,80)
80    FORMAT(//15X,' SYMMETRIC DISTRIBUTED MECHANICAL AND THERMAL LOAD 
     1COMPONENTS FOLLOW.  LOAD SET A'/)     
      IF (IL.EQ.2) WRITE(IFILE4,85)
85    FORMAT(//15X,' SYMMETRIC DISTRIBUTED MECHANICAL AND THERMAL LOAD 
     1COMPONENTS FOLLOW.  LOAD SET B'/)
      WRITE (IFILE4,90)
90    FORMAT('       STATION           PU           PV          PW
     1           TN1         TN2          TM1          TM2 '/)
      WRITE (IFILE4,40)I
      DO 100 K=1,I5
      IF (IL.EQ.1) THEN
      WRITE (IFILE4,50)K,S(K),P(K,1),P(K,2),P(K,3),THERM(K,1),
     1 THERM(K,2),THERM(K,3),THERM(K,4)
      ELSE
      WRITE (IFILE4,50)K,S(K),P(K,4),P(K,5),P(K,6),THERM(K,5),
     1 THERM(K,6),THERM(K,7),THERM(K,8)
      ENDIF
100   CONTINUE
105   CONTINUE
110   CONTINUE
      RETURN
      END
C=DECK      OUTIN1
      SUBROUTINE OUTIN1(IPRE,INDIC,ISTRES,NCOND,NLAST,NPRT,P,NSEG,STEP,
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C     CALLED FROM READIT, WHICH IS CALLED FROM MAIN
C     PRINTS OUT SOME INPUT DATA.
     1NVEC,IBOUND)
      COMMON/NLINS/NSTART,NFIN
      COMMON/JUNCT/IFIX(98,6),IFX(98,6),ITYPE(98)
      COMMON/JUNCTB/IFIXB(98,6),IFXB(98,6),ITYPEB(98)
      COMMON/WAVES/N0,N,NMIN,NMAX,INCR
      COMMON/LRANGE/FSTART,FMAX,DF
      COMMON/RING3/D1(98),D2(98)
      COMMON/HED/TITLE(12)
      COMMON/TEMTUR/TEMP,DTEMP
      COMMON/MAXSTP/STEPM,STEPMI,RHOM
      COMMON/BUCKN/ N0B,NMINB,NMAXB,INCRB
      COMMON/BKSIZE/IMAXP,IMAXB,KMAXP(20),KMAXB(20)
      COMMON/PRMOUT/IFILE3,IFILE4
      COMMON/ROTATN/OMEGA,DOMEGA
      COMMON/AMPFAC/OMEGDR,YLATRL,YAXIAL,BDAMP,AMPLTD,GAMP(200)
      COMMON/ACCELR/GRAVTY,GLATRL,GAXIAL
      COMMON/RESTRT/IREST
10    FORMAT(//' BEGINNING OF NEXT CASE'///)         
20    FORMAT(1X,12A4//)
      INDP = INDIC + 3
C
C     WRITE PARAGRAPH ON FIRST PAGE OF OUTPUT TELLING WHAT TYPE OF
C     ANALYSIS THIS CASE REPRESENTS.
C
      GO TO (30,40,50,60,70,80,90),INDP
30    WRITE (IFILE4,110)
      GO TO 100
40    WRITE (IFILE4,120)
      WRITE (IFILE4,130)
      GO TO 100
50    WRITE (IFILE4,140)
      GO TO 100
60    WRITE (IFILE4,150)
      GO TO 100
70    WRITE (IFILE4,160)
      GO TO 100
80    WRITE (IFILE4,170)
      GO TO 100
90    WRITE (IFILE4,180)
100   CONTINUE
110   FORMAT(//' STABILITY ANALYSIS WITH PLOT OF STABILITY DETERMIN-'/
     1' ANT.  NONLINEAR PREBUCKLING EFFECTS ARE INCLUDED.  INDIC IS'/
     1' CHANGED TO -1 WHEN DET CHANGES SIGN OR WHEN IT IS PERCEIVED'/
     1' THAT MULTIPLE ROOTS HAVE BEEN SKIPPED FROM ONE LOAD STEP TO'/
     1' THE NEXT.  CALCULATIONS TERMINATE WHEN THE LOAD EXCEEDS THE'/
     1' MAXIMUM ALLOWABLE VALUE, OR WHEN THE CORRECTION FACTOR IS'/
     1' LESS THAN ERR, OR WHEN THE PREBUCKLING SOLUTION FAILS TO'/
     1' CONVERGE.'//)
120   FORMAT(//' STABILITY ANALYSIS -- NONLINEAR PREBUCKLING EFFECTS'/
     1' INCLUDED. EIGENVALUE REPRESENTS CORRECTION FACTOR TO'/
     2' THE LOAD. CALCULATIONS FOR GIVEN VALUE OF N TERMINATE'/
     3' IF THE EIGENVALUE IS SMALLER THAN ERR. N IS CHANGED'/
     4' IN INCREMENTS (OR DECREMENTS) OF INCR UNTIL N IS LESS'/
     5' THAN NMIN, GREATER THAN NMAX, OR UNTIL A MINIMUM'/
     6' BUCKLING LOAD HAS BEEN FOUND. CALCULATIONS ALSO TER-'/
     7' MINATE IF MORE THAN 10 ESTIMATES OF THE CRITICAL')
130   FORMAT(' LOAD AT A GIVEN N ARE REQUIRED FOR CONVERGENCE OF'/
     1' THE EIGENVALUE TO WITHIN THE ACCURACY SPECIFIED BY '/
     2' ERR, OR IF THE PREBUCKLING SOLUTION FAILS TO CON-'/
     3' VERGE WITHIN THE ACCURACY SPECIFIED BY ERR.'///) 
140   FORMAT(//' STRESS ANALYSIS INCLUDING NONLINEAR EFFECTS. THIS AN-'/
     1' ALYSIS YIELDS THE AXISYMMETRIC PREBUCKLING STRESSES'/
     2' AND DISPLACEMENTS FOR A GIVEN VALUE OR SEQUENCE OF'/
     3' VALUES OF THE APPLIED LOAD OR LOADS.'///)
150   FORMAT(//' STABILITY ANALYSIS WITH "LINEAR" BENDING PREBUCKLING'/
     1' ANALYSIS.  ACTUALLY, THE PREBUCKLING ANALYSIS IS NONLINEAR, '/
     1' BUT IF THE USER SUPPLIES LOADS THAT ARE VERY SMALL COMPARED'/
     1' TO THE DESIGN LOAD, THE STRUCTURAL BEHAVIOR WILL CLOSELY'/
     1' APPROXIMATE LINEAR BEHAVIOR.  IF YOU WANT LINEAR BEHAVIOR,'/
     1' PLEASE USE SMALL LOADS.'//)
160   FORMAT(//' VIBRATION ANALYSIS OF PRESTRESSED SHELLS. THE EIGEN-'/
     1' VALUE REPRESENTS THE FREQUENCY IN CPS. FREQUENCIES'/
     2' ARE OBTAINED FOR N0.LE.N.LE.NMAX.'///)
170   FORMAT(//' LINEAR STATIC ANALYSIS FOR NON-SYMMETRIC LOADS'/)
180   FORMAT(//' BUCKLING OF A NONSYMMETRICALLY LOADED SHELL.'/
     1' PREBUCKLING STATE CALCULATED FROM LINEAR THEORY '/
     2' FOR HARMONICS N0 THRU NMAX. PRESTRESS N10,N20 AND '/
     3' PREBUCKLING ROTATIONS BETA0 IN THE STABILITY EQUA-'/
     4' TIONS ARE THOSE CORRESPONDING TO CIRCUMFERENTIAL'/
     5' LOCATION THETAS, AND ARE ASSUMED AXISYMMETRIC IN THE'/
     6' STABILITY PART OF THE PROGRAM. BUCKLING LOADS CAL-'/
     7' CULATED FOR WAVES N0B THRU NMAXB IN INCREMENTS OF'/
     8' INCRB FROM LINEAR THEORY.' //)
C
C     WRITE OUT SOME OF THE PRELIMINARY INPUT DATA.
C
      WRITE (IFILE4,190)INDIC,NPRT,NLAST,ISTRES,IPRE
190   FORMAT(//17H ANALYSIS TYPE = ,I3,16H, PRINT OPTION =  ,I2,          
     1', PLOT OPTION = ',I2,', STRESS OPTION = ',I2,
     2 ', PRESTRESS CALCULATION OPTION=',I2//)
      WRITE (IFILE4,200)NSEG
200   FORMAT(29H   NUMBER OF SHELL SEGMENTS =   ,I3//)
      WRITE (IFILE4,210)NSTART,NFIN,INCR
210   FORMAT(49H STRESS CALCULATED FOR CIRCUMFERENTIAL WAVES FROM   I7, 
     13H TO  I7,17H IN INCREMENTS OF   I7//)
      WRITE (IFILE4,220)N0B,NMINB,NMAXB,INCRB
220   FORMAT(40H INITIAL BUCKLING OR VIBRATION WAVE NO.= I6,19H, MINIMUM
     1WAVE NO.= I6,19H, MAXIMUM WAVE NO.= I6,12H, INCREMENT=  I6//)
      WRITE (IFILE4,230)NVEC
230   FORMAT(2X,I3,57H EIGENVALUES SOUGHT FOR EACH CIRCUMFERENTIAL WAVE 
     1NUMBER.   //)
      IF (NCOND.EQ.0) GO TO 260
      WRITE (IFILE4,240)
240   FORMAT(//45X,33H CONSTRAINT CONDITION DATA FOLLOW    //)
      CALL WRCON(NCOND,IFIX,D1,D2)
C     IF (IBOUND.EQ.0) GO TO 260
      WRITE (IFILE4,250)
250   FORMAT(//40X,66H CONSTRAINT CONDITIONS FOR STABILITY OR VIBRATION 
     1PROBLEM FOLLOW    //)
      CALL WRCON(NCOND,IFIXB,D1,D2)
260   CONTINUE
      WRITE (IFILE4,270)P,STEP,TEMP,DTEMP
270   FORMAT(//24H PRESSURE MULTIPLIER P =  1PE12.4,15H, INCREMENT DP=  
     11PE12.4,24H, TEMPERATURE MULT.TEMP= 1PE12.4,18H, INCREMENT DTEMP= 
     21PE12.4//)
      WRITE (IFILE4,280)FSTART,FMAX,DF
280   FORMAT(23H INITIAL LOAD, FSTART = 1PE12.4,23H, MAXIMUM LOAD, FMAX 
     1= 1PE12.4,16H, STEP SIZE, DF=  1PE12.4//)               
      WRITE(IFILE4,'(A,G12.3,A,G12.3)')' ANGULAR VELOCITY, OMEGA=',
     1 OMEGA,'   INCREMENT IN OMEGA, DOMEGA=',DOMEGA
C
      IF (OMEGDR.EQ.0.) GO TO 285
      WRITE(IFILE4,283) OMEGDR
  283 FORMAT(/' HARMONIC FORCING AT AN ANGULAR FREQUENCY, OMEGDR=',
     1 1PE12.3/)
      IF (GLATRL.EQ.0.0.AND.GAXIAL.EQ.0.0) GO TO 285
      WRITE(IFILE4,284) GRAVTY,GLATRL,GAXIAL
  284 FORMAT(' ACCELERATION OF GRAVITY, GRAVTY=',1PE12.3/
     1       ' LATERAL COMPONENT OF BASE EXCITATION, GLATRL=',1PE12.3/
     1       ' AXIAL COMPONENT OF BASE EXCITATION,   GAXIAL=',1PE12.3/)
  285 CONTINUE
      P = P - STEP
      TEMP = TEMP - DTEMP
      OMEGA = OMEGA - DOMEGA
      IF (NSEG.LE.95) GO TO 300
      WRITE (6,290)
290   FORMAT(//52H NSEG TOO LARGE. MAXIMUM NUMBER OF SEGMENTS = 95.  //)
      CALL ERREX
C BEG DEC 1990
300   IF (IMAXP.GT.20000) IMAXP = 20000
      IF (IMAXB.GT.20000) IMAXB = 20000
      IF (IMAXP.EQ.0) IMAXP=20000
      IF (IMAXB.EQ.0) IMAXB=20000
C END DEC 1990
      IF (NCOND.LE.98) GO TO 320
      WRITE (6,310)
310   FORMAT(//' NCOND TOO LARGE.'/
     1' MAXIMUM NUMBER OF CONSTRAINT POINTS = 98'//)
      CALL ERREX
320   CONTINUE
      RETURN
      END
C=DECK      READIT
      SUBROUTINE READIT
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
      COMMON/PRMFIL/IFILE,IFILE2,IOUT,IPRM(5)
      COMMON/PRMOUT/IFILE3,IFILE4
      COMMON/INDAT/INFILE
      COMMON/NLINS/NSTART,NFIN
      COMMON/BKSIZE/IMAXP,IMAXB,KMAXP(20),KMAXB(20)   
      COMMON/RBODY/ISTOP0(6),ISTOP1(6)    
      COMMON/NCONDS/NCOND     
      COMMON/TOTPTS/M3  
      COMMON/JUNCT/IFIX(98,6),IFX(98,6),ITYPE(98)     
      COMMON/JUNCTB/IFIXB(98,6),IFXB(98,6),ITYPEB(98) 
      COMMON/BLK/IBLK,NGBK(20),NKF(20)    
      COMMON/BLKP/IBLKP,NGBKP(20),NKFP(20)
      COMMON/LOCATN/ILOCP,ILOCB,IROWCP(98),IROWCB(98),IIWP,IIWB   
      COMMON/DSPACE/IDS 
      COMMON/KCHNG/NNWALL(95),CCH(95)     
      COMMON/RGFCE/RHF(98)    
      COMMON/WAVES/N0,N,NMIN,NMAX,INCR    
      COMMON/INSTAB/INDIC     
      COMMON/ENDOF/NLAST,NFIRST,NEDPLT    
      COMMON/RING3/D1(98),D2(98)    
      COMMON/SEGS/NSEG,M2,I5(95),I2,I2G   
      COMMON/HED/TITLE(12)    
      COMMON/EIGNO/NVEC,EGV(50),AXB 
      COMMON/OUTP/ NPRT 
      COMMON/INTRG/NSTATN(95),IRING(95,20)
      COMMON/RNGGEO/RC(98),AREA(98),ER(98),IY(98),IX(98),IXY(98),IP(98) 
      COMMON/RING2/GAM(98),GJ(98), YC(98), XC(98),E1(98),E2(98),PHI(100)
      COMMON/RMASS/RM(98)     
      COMMON/STEPS/STEP,STEP1(98),STEP2(98),STEP3(98) 
      COMMON/TEMGRD/NTGRAD    
      COMMON/LRANGE/FSTART,FMAX,DF  
      COMMON/ALLRNG/NTOT,IPRE 
      COMMON/EIGENV/P,OMG2,RHO
      COMMON/TEMTUR/TEMP,DTEMP
      COMMON/SFLAG/ISTRES     
      COMMON/STRSEG/ISTRSS(95)
      COMMON/ERROR/ERR  
      COMMON/MAXSTP/STEPM,STEPMI,RHOM     
      COMMON/FORCES/V(98),HF(98),FM(98)   
      COMMON/SHEARF/SHEAR(98) 
      COMMON/RGTEMP/TNR(98),TMR(98),TMRX(98)    
      COMMON/DRGTEM/DTNR(98),DTMR(98),DTMRX(98) 
      COMMON/SHEL/ISHL(95),IWAL(95),ITHK(95),IARC(95),ILOAD(95)   
      COMMON/FICTP/ IFICT     
      COMMON/WAVNUM/ITHETA(50),THETA(50),THETAS,THETAM
      COMMON/INTRVL/ INTVAL(95),IIOUT,NDIST,NCIRC,NTHETA     
      COMMON/BUCKN/ N0B,NMINB,NMAXB,INCRB 
      COMMON/NOHARM/NHARM
c Renamed SIGNAL to SIGNAx, Feb 1996
      COMMON/PRERT/PREROT,SIGNAx,IPREBK   
      COMMON/GLOBAL/IDZ,IZRING(98),ISAVE(20),INOTE    
      COMMON/LOADHM/NLPOS(95),LAB(95),IDAB(95),ILPOS(12,95),PALL(6000)
      COMMON/IFRHX/IFB,RHFIX(98),KKKK,MNUMB,ISWTCH,KNT,IFTOT,INDSEG,LFIX
      COMMON/ALOFIT/INDSIG,II,ITOT,K,L,IBOUND,IPT,IRIGID,ISEG,I5I,KRING,
     1NWALL,NLTYPE,NRINGS,DSTOT,SEND,IPOS,IEND,IENDS,IMAX,ITOTL,LINTYP  
      COMMON/NONEA/KRINGS,NPSTAT,NTSTAT,ARC(98),TT(600)   
      COMMON/STRATG/ISTRAT,IFACTR   
      COMMON/PLTSIG/IPLOT,JPLOT,KPLOT(20),LPLOT(20),MPLOT,RN(20),ZN(20) 
      COMMON/IOCHOZ/IOYES(50),IOSEG(95)
      COMMON/ROTATN/OMEGA,DOMEGA
      COMMON/FORFIX/IOMGAB,VFIX(98),SHFIX(98),HFIX(98),FMFIX(98)
      COMMON/AMPFAC/OMEGDR,YLATRL,YAXIAL,BDAMP,AMPLTD,GAMP(200)
      COMMON/ACCELR/GRAVTY,GLATRL,GAXIAL
C BEG SEP 1997
      COMMON/FLUTNK/GAMMAF,AXLONG,RBIG,ZBEGIN
      COMMON/NUMTNK/IFLSEG(95)
      DIMENSION ISTANK(95)
C END SEP 1997
      COMMON/RESTRT/IREST
      COMMON/COMNOD/NODES(100),NODALL(100),NODTOT
      COMMON/JRING/JJRING
      COMMON/BWORK/BBB(10000),Z(1000),S(1000),DS(1000),ZAX(1000),
     1 RGLOB(1000),ANGLE(1000)
      CHARACTER*4 ANSOUT,CHARAC
      LOGICAL ANSL1
      common/caseblock/case
      character*28 case
      character*32 fname, case2
      logical exists
10    FORMAT(18A4)                                     
20    FORMAT(10I6)                                                
30    FORMAT(6I6,2E12.8)                                          
40    FORMAT(6E12.8)                                              
      DATA IPRE,NSTART,NFIN,INCR/0,0,0,0/
      DATA N0B,NMINB,NMAXB,INCRB,NVEC/0,0,0,0,1/
      DATA NDIST,NCIRC,NTHETA/0,0,2/
      DATA THETAM,THETAS,PREROT/0.,0.,0./
      DATA P,STEP,TEMP,DTEMP/0.,0.,0.,0./
      DATA FSTART,FMAX,DF/0.,0.,0./
      DATA JPLOT,ISTRAT,IFACTR/0,0,0/
      DATA ITHETA(1),THETA(1)/0,0./
      INFILE = 5
      IOUT  = 3
      IFILE = 2
      IFILE2= 4
      IFILE3 = 7
      IFILE4 = 8
C        WRITE(6,'(1X,A,$)')' ENTER THE BOSOR4 CASE NAME '
C        READ(5,'(A)') CASE
C        DO 3 I = 1,9
C           ISTART = I
C           IF (CASE(I:I).NE.' ') GO TO 4
C   3    CONTINUE
C   4    CONTINUE
C        CASE2 = CASE(ISTART: )
C        CASE = CASE2
C
C FOLLOWING USED FOR VAX/VMS..
C     OPEN(UNIT=IFILE,FILE='BOSOR4:PROMPT.DAT',STATUS='OLD',READONLY)
C     OPEN(UNIT=IFILE2,FILE='BOSOR4:PROMPT2.DAT',STATUS='OLD',READONLY)
C     OPEN(UNIT=IFILE3,FILE='BOSOR4:PROMPT3.DAT',STATUS='OLD',READONLY)
C END VAX/VMS OPEN STATEMENTS
C
C FOLLOWING USED FOR UNIX...
      OPEN(UNIT=IFILE,FILE='PROMPT.DAT',STATUS='OLD')
      OPEN(UNIT=IFILE2,FILE='PROMPT2.DAT',STATUS='OLD')
      OPEN(UNIT=IFILE3,FILE='PROMPT3.DAT',STATUS='OLD')
#if rs6k
      rewind(IFILE)
      rewind(IFILE2)
      rewind(IFILE3)
#endif
C END UNIX OPEN STATEMENTS
C
      fname = case(1:index(case, ' ')-1)//'.DOC'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=IOUT, FILE=fname, STATUS='OLD')
#if rs6k
        rewind(iout)
#endif
      else
	OPEN(UNIT=IOUT, FILE=fname, STATUS='NEW')
      endif
c
      fname = case(1:index(case, ' ')-1)//'.OUT'
      inquire(FILE=fname, EXIST=exists)
      if (exists) then
	OPEN(UNIT=IFILE4, FILE=fname, STATUS='OLD')
#if rs6k
        rewind(IFILE4)
#endif
      else
	OPEN(UNIT=IFILE4, FILE=fname, STATUS='NEW')
      endif
C
      IMAXP = 0
      IMAXB = 0
      NMIN = 0
      NMAX = 0
      N0 = 0
      INCR = 1
      IREST = 0
      IMAX = 10000 
      WRITE (6, 50)     
50    FORMAT(//33H START READING DATA FOR THIS CASE   )         
C     CALL SR100T (2)   
C
      CALL DATUM(IFILE,1,0,0,INT,REALL,CHARAC,IOUT,0,1)
C     CALL DATUM(IFILE,1,1,1,INT,REALL,TITLE,IOUT,0,1)
C
      WRITE(6,53)
   53 FORMAT(//' Please provide a title (42 characters or less)...'/)
      READ(INFILE,10) (TITLE(I),I=1,12)
      WRITE(IOUT,10) (TITLE(I),I=1,12)
      WRITE(IFILE4,11) (TITLE(I),I=1,12)
   11 FORMAT(1X,18A4)
C
      CALL DATUM(IFILE,2,1,2,INDIC,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,3,1,1,NPRT,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,5,1,2,ISTRES,REALL,CHARAC,IOUT,0,1)
      IF (INDIC.NE.0.AND.INDIC.NE.3) ISTRES = 0
      IF (INDIC.EQ.4)CALL DATUM(IFILE,6,1,2,IPRE,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,10,1,1,NSEG,REALL,CHARAC,IOUT,0,1)
      DO 55 I = 1,NSEG
   55 ISTRSS(I) = ISTRES
      IF (INDIC.LT.3) GO TO 66
      IF (INDIC.EQ.4.AND.IPRE.EQ.0) GO TO 66
      CALL DATUM(IFILE,16,1,2,NSTART,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,17,1,2,NFIN  ,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,18,1,2,INCR  ,REALL,CHARAC,IOUT,0,1)
      NMIN = MIN0(NSTART,NFIN)
      NMAX = MAX0(NSTART,NFIN)
      N0 = NSTART 
      CALL DATUM(IFILE,29,1,2,INT,THETAM,CHARAC,IOUT,0,1)
      IF (THETAM.GT.181.) CALL ERREX
      IF (THETAM.LT.-0.5) CALL ERREX
      THETAM = THETAM*3.14159/180.
   66 CONTINUE
      CALL RFIRST1
C     START LOOP FOR INPUT DATA FOR ALL SEGMENTS
C     
      INDSIG = 0
      IF (INDIC.EQ.4.AND.IPRE.EQ.1) INDSIG = 1
      IF (INDIC.EQ.4.AND.IPRE.EQ.1) INDIC = 3
C     
      DO 170 ISEGNO=1,NSEG   
      JJRING = 0
      WRITE(6,165) ISEGNO
  165 FORMAT(//' PLEASE PROVIDE DATA FOR SEGMENT NO.',I3/)
      L = ISEGNO 
      KRINGS = KRING    
      REWIND IFILE3
C     MESH GENERATOR    
      CALL MESH(I5(ISEGNO),DS(ITOT),DSTOT,ISEGNO)   
C     CALL OVERLAY(5HBOSOR,1,2)     
      REWIND IFILE2
      CALL GEOMTR(BBB,Z,S,DS,ZAX,RGLOB,ANGLE) 
C     CALL OVERLAY(5HBOSOR,1,3)     
      REWIND IFILE2
      CALL RZLG(BBB,S,ZAX,DS)
C     CALL OVERLAY(5HBOSOR,1,4)     
      REWIND IFILE2
      CALL WALLS(BBB,Z,S,DS,ZAX)  
      REWIND IFILE3
      CALL OUTAX(ISEGNO,I5I,BBB(27*I5I+IPOS),BBB(IPOS),S(ITOT))
C     INPUT DATA READ IN NOW FOR ITH SEGMENT.   
      ITOT = ITOT + I5I 
      SEND = S(ITOT-1)  
      ITOTL = ITOTL + I5I     
170   CONTINUE    
C
      IF (INDSIG.EQ.1.AND.INDIC.EQ.3) INDIC = 4
C
      REWIND IFILE
      WRITE(IOUT,171)
  171 FORMAT(6X,'H',9X,'$'/6X,'H',9X,'$ GLOBAL DATA BEGINS...')
C
      CALL DATUM(IFILE,4,1,2,NLAST,REALL,CHARAC,IOUT,0,1)
      DO 60 I=1,20
      LPLOT(I) = 0
60    KPLOT(I) = 0
      IF (NLAST.GT.-1) CALL BLOWUP(IFILE3,IOUT,JPLOT,KPLOT,LPLOT)
C
      IF (INDIC.EQ.0.OR.INDIC.EQ.3) GO TO 62
      CALL DATUM(IFILE,19,1,1,N0B   ,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,20,1,1,NMINB ,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,21,1,1,NMAXB ,REALL,CHARAC,IOUT,0,1)
      IF (NMAXB.LT.NMINB) CALL ERREX
      CALL DATUM(IFILE,22,1,1,INCRB ,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,23,1,1,NVEC  ,REALL,CHARAC,IOUT,0,1)
      IF (NVEC.LE.0) CALL ERREX
      IF (NVEC.GT.100) CALL ERREX
   62 CONTINUE
      IF (INDIC.LT.3.OR.IPRE.EQ.0) GO TO 69
      CALL DATUM(IFILE,24,1,2,NDIST ,REALL,CHARAC,IOUT,0,1)
      THETA(1) = 0.
      IF (NDIST.EQ.0) GO TO 61
      DO 63 I = 1,NDIST 
      IPROMP = 1  
      IF (I.GT.1) IPROMP = 0  
      CALL DATUM(IFILE,25,1,1,INT   ,THETA(I),CHARAC,IOUT,I,IPROMP)     
      THETA(I) = THETA(I)*3.141593/180.
   63 CONTINUE    
   61 CONTINUE
      CALL DATUM(IFILE,26,1,2,NCIRC ,REALL,CHARAC,IOUT,0,1) 
      NTHETA = 2
      ITHETA(1) = 1001
      IF (NCIRC.EQ.0) GO TO 65
      DO 64 I = 1,NCIRC 
      IPROMP = 1  
      IF (I.GT.1) IPROMP = 0  
      CALL DATUM(IFILE,27,1,2,ITHETA(I),REALL,CHARAC,IOUT,I,IPROMP)     
   64 CONTINUE    
  644 CONTINUE
      CALL DATUM(IFILE,28,1,2,NTHETA,REALL,CHARAC,IOUT,0,1) 
      IF (NTHETA.LE.1) THEN
         WRITE(6,*)' NTHETA MUST BE GREATER THAN 1. TRY AGAIN'
         BACKSPACE(IOUT)
         REWIND IFILE
         GO TO 644
      ENDIF
   65 CONTINUE
      CALL DATUM(IFILE,30,1,2,INT,THETAS,CHARAC,IOUT,0,1)
      THETAS = THETAS*3.14159/180.  
   69 CONTINUE
C     
      NLTYPE = 0  
      LINTYP = 0  
      IF (INDIC.GT.2) GO TO 160
      CALL DATUM(IFILE,45,0,0,INT,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,47,1,2,INT,P,CHARAC,IOUT,0,1)
      IF (INDIC.NE.2)CALL DATUM(IFILE,48,1,1,INT,STEP,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,49,1,2,INT,TEMP,CHARAC,IOUT,0,1)
      IF (INDIC.NE.2)CALL DATUM(IFILE,50,1,1,INT,DTEMP,CHARAC,IOUT,0,1)
      
      IF (INDIC.NE.0.AND.INDIC.NE.-2) GO TO 160 
      CALL DATUM(IFILE,51,1,2,NSTEPS,REALL,CHARAC,IOUT,0,1)
      IF (NSTEPS.LE.0) THEN
         WRITE(6,*)' BAD VALUE FOR  NSTEPS.  USE POSITIVE INTEGER.'
         CALL ERREX
      ENDIF
      FSTEPS = NSTEPS
      FMAX   = FSTEPS + .001
      DF     = 1.
      FSTART = 1.
160   CONTINUE    
C
      OMEGA = 0.
      DOMEGA = 0.
      IF (IPRE.EQ.0) GO TO 162
      CALL DATUM(IFILE,55,1,1,INT,OMEGA,CHARAC,IOUT,0,1)
      IF (INDIC.LT.3) GO TO 162
      REWIND IFILE3
      CALL DATUM(IFILE3,480,1,2,IOMGAB,REALL,CHARAC,IOUT,0,1)
      REWIND IFILE
  162 CONTINUE
      IF (INDIC.LT.2)
     1CALL DATUM(IFILE,56,1,1,INT,DOMEGA,CHARAC,IOUT,0,1)
C
      OMEGDR = 0.
      YLATRL = 0.
      YAXIAL = 0.
      GLATRL = 0.
      GAXIAL = 0.
      GRAVTY = 0.
C
      IF (INDIC.LT.3.OR.IPRE.EQ.0) GO TO 174
C
      REWIND IFILE3
      CALL DATUM(IFILE3,702,1,1,INT,REALL,ANSOUT,IOUT,0,1)
      IF (ANSL1('N',ANSOUT,INFILE)) GO TO 174
      REWIND IFILE
      CALL DATUM(IFILE,57,1,1,INT,OMEGDR,CHARAC,IOUT,0,1)
      REWIND IFILE3
      CALL DATUM(IFILE3,704,1,1,INT,REALL,ANSOUT,IOUT,0,1)
      IF (ANSL1('N',ANSOUT,INFILE)) GO TO 174
      CALL DATUM(IFILE3,706,1,1,INT,GRAVTY,CHARAC,IOUT,0,1)
      REWIND IFILE
      CALL DATUM(IFILE,58,1,1,INT,GLATRL,CHARAC,IOUT,0,1)
      YLATRL = GLATRL*GRAVTY/OMEGDR**2
      CALL DATUM(IFILE,59,1,1,INT,GAXIAL,CHARAC,IOUT,0,1)
      YAXIAL = GAXIAL*GRAVTY/OMEGDR**2
C BEG SEP 1997
      CALL DATUM(IFILE,134,1,2,INT,REALL,ANSOUT,IOUT,0,1)
      IF (ANSL1('N',ANSOUT,INFILE)) GO TO 174   
      CALL DATUM(IFILE,136,1,1,INT,GAMMAF,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,138,1,1,INT,AXLONG,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,140,1,1,INT,RBIG,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,142,1,1,INT,ZBEGIN,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,144,0,0,INT,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,146,1,2,NSEGFL,REALL,CHARAC,IOUT,0,1)
      DO 1725 I = 1,NSEGFL
         CALL DATUM(IFILE,148,1,1,ISTANK(I),REALL,CHARAC,IOUT,I,1)
         INDX = ISTANK(I)
         IFLSEG(INDX) = 1
         CALL DATUM(IFILE,149,1,2,INT,REALL,ANSOUT,IOUT,0,1)
         IF (ANSL1('N',ANSOUT,INFILE)) IFLSEG(INDX) = -1
         REWIND IFILE
 1725 CONTINUE
  174 CONTINUE    
      REWIND IFILE
C END SEP 1997
C
C    PROVIDE CONSTRAINT CONDITIONS...
C
      CALL CONSTR
C
      WRITE(IOUT,173)
  173 FORMAT(6X,'H',9X,'$ "GLOBAL3" QUESTIONS (AT END OF CASE)...')
      REWIND IFILE3
      DO 175 I = 1,NSEG
      IPROMP = 1
      IF (I.GT.1) IPROMP = 0
      CALL DATUM(IFILE3,710,1,1,INT,REALL,ANSOUT,IOUT,I,IPROMP)
      IF (ANSL1('Y',ANSOUT,INFILE)) IOSEG(I) = 1
  175 CONTINUE
      REWIND IFILE3
      IF (INDIC.NE.0) GO TO 176
      IOYES(1) = 1
  176 CONTINUE
      IF (INDIC.EQ.0.OR.INDIC.GE.3) GO TO 177
      IOYES(2) = 1
  177 CONTINUE
      CALL DATUM(IFILE3,740,1,1,INT,REALL,ANSOUT,IOUT,0,1)
      IF (ANSL1('Y',ANSOUT,INFILE)) IOYES(3) = 1
C
C     ALL INPUT DATA HAS BEEN READ IN.    
C     
C
C     CALL OVERLAY(5HBOSOR,1,1)     
      CALL RFIRST 
      I2 = ITOT - 1
      CALL GASP(DS,I2,1,IDS)
      CALL GASP(BBB,IEND,1,ISHL(INOTE))
      ISAVE(INOTE) = IEND
      CALL GASP(S,I2,1,IARC(1))
C     CALL OVERLAY(5HBOSOR,1,5)     
      CALL RFIVE(ZAX)
  180 CONTINUE    
      RETURN
      END   
C=DECK      BLOWUP
      SUBROUTINE BLOWUP(IFILE3,IOUT,JPLOT,KPLOT,LPLOT)
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C
C     PURPOSE IS TO ALLOW USER TO PROVIDE LOCATIONS AND FACTORS FOR
C     EXPANDED PLOTS OF UNDEFORMED AND DEFORMED STRUCTURE.
C
      COMMON/INDAT/INFILE
      DIMENSION LPLOT(*),KPLOT(*)
      LOGICAL ANSL1
      CHARACTER*4 ANSWER,CHARAC
C
      JPLOT = 0
      DO 10 I = 1,20
      LPLOT(I) = 0
      KPLOT(I) = 0
   10 CONTINUE
C
      REWIND IFILE3
      CALL DATUM(IFILE3,500,0,0,INT,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE3,510,1,1,INT,REALL,ANSWER,IOUT,0,1)
      IF (ANSL1('N',ANSWER,INFILE)) GO TO 100
   20 CONTINUE
      JPLOT = JPLOT + 1
      REWIND IFILE3
      IF (JPLOT.GT.1)
     1      CALL DATUM(IFILE3,520,1,1,INT,REALL,ANSWER,IOUT,0,1)
      IF (ANSL1('N',ANSWER,INFILE)) GO TO 100
      CALL DATUM(IFILE3,530,1,2,ISEG,REALL,CHARAC,IOUT,0,1)
      KPLOT(JPLOT) = ISEG*1000 + 1
   25 CONTINUE
      CALL DATUM(IFILE3,540,1,2,LPLOT(JPLOT),REALL,CHARAC,IOUT,0,1)
      IF (LPLOT(JPLOT).LT.1) THEN
         WRITE(6,*)' IMPROPER MAGNIFICATION FACTOR. USE INTEGER > 1 '
         BACKSPACE(IOUT)
         REWIND IFILE3
         GO TO 25
      ENDIF
      GO TO 20
  100 CONTINUE
      IF (JPLOT.GT.0) JPLOT = JPLOT - 1
      RETURN
      END
C
C
C
C
C=DECK      CONSTR
      SUBROUTINE CONSTR 
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C     
C    PURPOSE IS TO PROVIDE INPUT FOR BOUNDARY, POLE, AND JUNCTURE 
C    CONDITIONS.  
C COMMON BLOCK ADDED 17 AUG 85 FOR DYNAMIC REACTION..
       COMMON/DYNAM/FX(2),FY(2),FZ(2),MX(2),MY(2),MZ(2),
     1              ICM,IZ,MAS,ZCM,IDYN(2)
       REAL MX,MY,MZ,ICM,IZ,MAS
      COMMON/RBODY/ISTOP0(6),ISTOP1(6)    
      COMMON/NCONDS/NCOND     
      COMMON/JUNCT/IFIX(98,6),IFX(98,6),ITYPE(98)     
      COMMON/JUNCTB/IFIXB(98,6),IFXB(98,6),ITYPEB(98) 
      COMMON/INSTAB/INDIC     
      COMMON/SEGS/NSEG,M2,I5(95),I2,I2G   
      COMMON/RING3/D1(98),D2(98)    
C     
      LOGICAL ANSL1     
      CHARACTER*4 ANSCON,CHARAC
      COMMON/PRMFIL/IFILE,IFILE2,IOUT,IPRM(5)   
      COMMON/INDAT/INFILE
      DIMENSION IMESH(98)     
C     
      IBOUND = 0  
      IRIGID = 0  
      NCOND  = 0  
      REWIND IFILE
      CALL DATUM (IFILE,60,0,0,INT,REALL,CHARAC,IOUT,0,1)   
      WRITE(IOUT,32)
   32 FORMAT(6X,'H',9X,'$ CONSTRAINT CONDITIONS FOLLOW....')
      CALL DATUM (IFILE,61,1,1,NSEG,REALL,CHARAC,IOUT,0,1)
      IF (NSEG.LE.0) CALL ERREX
      IF (NSEG.GT.95) CALL ERREX
C     
    2 CONTINUE    
      DO 100 ISEG = 1,NSEG    
C     
      I5I = I5(ISEG)
      WRITE(6,*)' CONSTRAINT CONDITIONS FOR SEGMENT NO. ISEG =',ISEG
      WRITE(6,*)' Endpoint of this segment is at Nodal Point No.',I5I
      IF (ISEG.GT.1) WRITE(6,'(1X,A,A,I2)')' Endpoint of previous',
     1' segment is at Nodal Point No. ',I5(ISEG-1)
      WRITE(IOUT,35) ISEG,ISEG,ISEG,ISEG
   35 FORMAT(6X,'H',9X,'$'/
     1 6X,'H',9X,'$ CONSTRAINT CONDITIONS FOR SEGMENT NO.',4I5)
      WRITE(IOUT,3)
    3 FORMAT(6X,'H',9X,'$ POLES INPUT FOLLOWS...')
      REWIND IFILE
      CALL DATUM(IFILE,62,1,2,NPOLES,REALL,CHARAC,IOUT,ISEG,1)    
      IF (NPOLES.LE.-1) CALL ERREX
      IF (NPOLES.GT.20) CALL ERREX
      IF (NPOLES.EQ.0) GO TO 20     
C     
C    CONSTRAINT CONDITIONS FOR A POLE (r=0)...  
C     
      DO 10 I = 1,NPOLES
      REWIND IFILE
      NCOND = NCOND + 1 
      CALL DATUM(IFILE,64,1,1,IMESH(I),REALL,CHARAC,IOUT,I,1)     
      IF (IMESH(I).LE.0) CALL ERREX
      IF (IMESH(I).GT.I5(ISEG)) THEN
        WRITE(6,*)' POLE LOCATED AT HIGHER MESH STATION THAN NMESH'
        CALL ERREX
      ENDIF
      IFIX(NCOND,1) = 1000*ISEG + IMESH(I)
      IFIX(NCOND,2) = IFIX(NCOND,1) 
      DO 5 J = 3,6
    5 IFIX(NCOND,J) = 0 
      D1(NCOND) = 0.    
      D2(NCOND) = 0.    
      DO 7 J = 1,6
    7 IFIXB(NCOND,J) = IFIX(NCOND,J)
   10 CONTINUE    
   20 CONTINUE    
C     
C   CONSTRAINTS TO GROUND (OTHER THAN POLES) FOLLOW....     
C     
      WRITE(IOUT,4)
    4 FORMAT(6X,'H',9X,'$ INPUT FOR CONSTRAINTS TO GROUND FOLLOWS...')
      CALL DATUM(IFILE,66,1,2,NGRND,REALL,CHARAC,IOUT,0,1)  
      IF (NGRND.LE.-1) CALL ERREX
      IF (NGRND.GT.35) CALL ERREX
      IF (NGRND.EQ.0) GO TO 40
      DO 30 I = 1,NGRND 
      REWIND IFILE
      I1 = I - 1  
      NCOND = NCOND + 1 
   22 CONTINUE    
      CALL DATUM(IFILE,68,1,1,IMESH(I),REALL,CHARAC,IOUT,I,1)     
      IF (IMESH(I).LE.0) CALL ERREX
      IF (IMESH(I).GT.I5(ISEG)) THEN
        WRITE(6,*)' FIXITY LOCATED AT HIGHER MESH STATION THAN NMESH'
        CALL ERREX
      ENDIF
      IF (I.EQ.1) GO TO 24    
      MESHDF = IMESH(I) - IMESH(I1) 
      IF (MESHDF.GE.3) GO TO 24     
      WRITE(6,'(A,A)')' CONSTRAINTS TO GROUND MUST BE AT INTERVALS',    
     1' ALONG THE MERIDIAN OF AT LEAST 3 NODAL POINTS'
      REWIND IFILE
      GO TO 22    
   24 CONTINUE    
      IFIX(NCOND,1) = 1000*ISEG + IMESH(I)
      IFIX(NCOND,2) = IFIX(NCOND,1) 
      CALL DATUM(IFILE,70,1,2,IFIX(NCOND,3),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,71,1,1,IFIX(NCOND,4),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,72,1,1,IFIX(NCOND,5),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,73,1,1,IFIX(NCOND,6),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,74,1,2,INT,D1(NCOND),CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,75,1,1,INT,D2(NCOND),CHARAC,IOUT,0,1)
C     
      DO 25 J = 1,6     
   25 IFIXB(NCOND,J) = IFIX(NCOND,J)
C     
      CALL DATUM(IFILE,80,1,2,INT,REALL,ANSCON,IOUT,0,1)    
      IF (ANSL1('Y',ANSCON,INFILE)) GO TO 30   
C     
      CALL DATUM(IFILE,81,1,2,IFIXB(NCOND,3),REALL,CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,82,1,1,IFIXB(NCOND,4),REALL,CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,83,1,1,IFIXB(NCOND,5),REALL,CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,84,1,1,IFIXB(NCOND,6),REALL,CHARAC,IOUT,0,1)     
C     
      IBOUND = 1  
   30 CONTINUE    
   40 CONTINUE    
C     
C    JUNCTURE CONDITIONS ARE NEXT...
C     
      WRITE(6,*)' The current segment is Segment No. ISEG =', ISEG
C     
      WRITE(IOUT,6)
    6 FORMAT(6X,'H',9X,'$ JUNCTION CONDITION INPUT FOLLOWS...')
      CALL DATUM(IFILE,86,1,2,INT,REALL,ANSCON,IOUT,0,1)    
      IF (ANSL1('N',ANSCON,INFILE)) GO TO 80   
      CALL DATUM(IFILE,88,1,2,NJUNCT,REALL,CHARAC,IOUT,0,1) 
      IF (NJUNCT.LT.-1) CALL ERREX
      IF (NJUNCT.GT.35) CALL ERREX
      IF (NJUNCT.EQ.0) GO TO 80     
      DO 60 I = 1,NJUNCT
      REWIND IFILE
      I1 = I - 1  
      NCOND = NCOND + 1 
   42 CONTINUE    
      CALL DATUM(IFILE,90,1,1,IMESH(I),REALL,CHARAC,IOUT,I,1)     
      IF (IMESH(I).LE.0) CALL ERREX
      IF (IMESH(I).GT.I5(ISEG)) THEN
      WRITE(6,*)' JUNCTION AT HIGHER NODE THAN NUMBER OF NODES IN SEG.'
      CALL ERREX
      ENDIF
      IF (I.EQ.1) GO TO 44    
      MESHDF = IMESH(I) - IMESH(I1) 
      IF (MESHDF.GE.3) GO TO 44     
C BEG JULY 1989
      IF (IMESH(I).EQ.1) GO TO 44
C END JULY 1989 
      WRITE(6,'(A,A)')' JUNCTURES TO EARLIER SEGMENTS MUST BE SPACED',
     1' AT INTERVALS OF AT LEAST 3 NODAL POINTS.'
      REWIND IFILE
      GO TO 42    
   44 CONTINUE    
      CALL DATUM(IFILE,92,1,1,JSEG,REALL,CHARAC,IOUT,0,1)   
      IF (JSEG.LE.0) CALL ERREX
      IF (JSEG.GT.95) CALL ERREX
      CALL DATUM(IFILE,94,1,1,JNODE,REALL,CHARAC,IOUT,0,1)  
      IF (JNODE.LE.0) CALL ERREX
      IF (JNODE.GT.I5(JSEG)) THEN
       WRITE(6,*)' JNODE IS AT HIGHER NODAL STATION THAN NODES IN SEG.'
       CALL ERREX
      ENDIF
      IFIX(NCOND,1) = 1000*JSEG + JNODE   
      IFIX(NCOND,2) = 1000*ISEG + IMESH(I)
      CALL DATUM(IFILE,96,1,2,IFIX(NCOND,3),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,98,1,1,IFIX(NCOND,4),REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,100,1,1,IFIX(NCOND,5),REALL,CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,102,1,1,IFIX(NCOND,6),REALL,CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,104,1,2,INT,D1(NCOND),CHARAC,IOUT,0,1)     
      CALL DATUM(IFILE,106,1,1,INT,D2(NCOND),CHARAC,IOUT,0,1)     
C     
      DO 50 J = 1,6     
   50 IFIXB(NCOND,J) = IFIX(NCOND,J)
C     
      CALL DATUM(IFILE,108,1,2,INT,REALL,ANSCON,IOUT,0,1)   
      IF (ANSL1('Y',ANSCON,INFILE)) GO TO 60   
      CALL DATUM(IFILE,110,1,2,IFIXB(NCOND,3),REALL,CHARAC,IOUT,0,1)    
      CALL DATUM(IFILE,111,1,1,IFIXB(NCOND,4),REALL,CHARAC,IOUT,0,1)    
      CALL DATUM(IFILE,112,1,1,IFIXB(NCOND,5),REALL,CHARAC,IOUT,0,1)    
      CALL DATUM(IFILE,113,1,1,IFIXB(NCOND,6),REALL,CHARAC,IOUT,0,1)    
C     
      IBOUND = 1  
   60 CONTINUE    
   80 CONTINUE    
C     
  100 CONTINUE    
C     
C    RIGID BODY MOTION STUFF FOLLOWS...   
C     
      WRITE(IOUT,8)
    8 FORMAT(6X,'H',9X,'$ RIGID BODY CONSTRAINT INPUT FOLLOWS...')
      REWIND IFILE
      CALL DATUM(IFILE,115,0,0,INT,REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,120,1,2,INT,REALL,ANSCON,IOUT,0,1)   
      IF (ANSL1('N',ANSCON,INFILE)) GO TO 200  
      CALL DATUM(IFILE,121,1,2,INT,REALL,ANSCON,IOUT,0,1)
      IF (ANSL1('N',ANSCON,INFILE)) GO TO 190
      IRIGID = 1  
  110 CONTINUE    
      CALL DATUM(IFILE,122,0,0,INT,REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,123,1,1,ISEG,REALL,CHARAC,IOUT,0,1)  
      IF (ISEG.LE.0) CALL ERREX
      IF (ISEG.GT.95) CALL ERREX
      CALL DATUM(IFILE,124,1,1,INODE,REALL,CHARAC,IOUT,0,1) 
      IF (INODE.LE.0) CALL ERREX
      IF (INODE.GT.I5(ISEG)) THEN
      WRITE(6,*)' INODE IS GREATER THAN NUMBER OF NODES IN SEGMENT.'
      CALL ERREX
      ENDIF
      IFIXR = 1000*ISEG + INODE     
      IF (NCOND.EQ.0) GO TO 122     
      DO 120 I = 1,NCOND
      II = I
      IF (IFIXR.NE.IFIX(I,1)) GO TO 120   
      IF(IFIX(I,2).EQ.IFIX(I,1)) GO TO 140
      WRITE(6,*)' THIS LOCATION IS ILLEGAL.  CHOOSE ANOTHER.'     
      CALL ERREX
  120 CONTINUE    
  122 CONTINUE    
      NCOND = NCOND + 1 
      IFIX(NCOND,1) = IFIXR   
      IFIX(NCOND,2) = IFIXR   
      DO 125 I = 3,6    
  125 IFIX(NCOND,I) = 0 
      D1(NCOND) = 0.    
      D2(NCOND) = 0.    
      II = NCOND  
  140 CONTINUE    
C     
      ISTOP0(1) = IFIX(II,1)  
      ISTOP0(2) = IFIX(II,2)  
      ISTOP1(1) = IFIX(II,1)  
      ISTOP1(2) = IFIX(II,2)  
      CALL DATUM(IFILE,125,0,0,INT,REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,126,1,2,ISTOP0(3),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,127,1,1,ISTOP0(4),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,128,1,1,ISTOP0(5),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,129,1,1,ISTOP0(6),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,130,1,1,ISTOP1(3),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,131,1,1,ISTOP1(4),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,132,1,1,ISTOP1(5),REALL,CHARAC,IOUT,0,1)   
      CALL DATUM(IFILE,133,1,1,ISTOP1(6),REALL,CHARAC,IOUT,0,1)   
  190 CONTINUE
C DYNAMIC REACTION STUFF ADDED AUG 17, 1985...
      IDYN(1) = 0
      IDYN(2) = 0
      IF (INDIC.LT.3) GO TO 200
      CALL DATUM(IFILE,150,0,0,INT,REALL,CHARAC,IOUT,0,1)
      CALL DATUM(IFILE,155,1,2,INT,REALL,ANSCON,IOUT,0,1)
      IF (ANSL1('Y',ANSCON,INFILE)) IDYN(1) = 1
      CALL DATUM(IFILE,160,1,2,INT,REALL,ANSCON,IOUT,0,1)
      IF (ANSL1('Y',ANSCON,INFILE)) IDYN(2) = 1
C END 17 AUG 85 MODS...
C     
  200 CONTINUE    
      RETURN
      END   
C=DECK      RFIRST
C./      ADD   NAME=RETLK
      SUBROUTINE RFIRST
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
      COMMON/FICTP/IFICT
      COMMON/ERROR/ERR
      COMMON/INSTAB/INDIC
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/SFLAG/ISTRES
      COMMON/STRSEG/ISTRSS(95)
      COMMON/NOHARM/NHARM
      COMMON/GLOBAL/IDZ,IZRING(98),ISAVE(20),INOTE
      COMMON/EIGNO/NVEC,EGV(50),AXB
      COMMON/WAVES/N0,N,NMIN,NMAX,INCR
      COMMON/BUCKN/N0B,NMINB,NMAXB,INCRB
      COMMON/LRANGE/FSTART,FMAX,DF
      COMMON/TEMTUR/TEMP,DTEMP
      COMMON/MAXSTP/STEPM,STEPMI,RHOM
      COMMON/EIGENV/P,OMG2,RHO
      COMMON/NCONDS/NCOND
      COMMON/ENDOF/NLAST,NFIRST, NEDPLT
      COMMON/OUTP/NPRT
      COMMON/SEGS/NSEG,M2,I5(95),I2,I2G
      COMMON/STEPS/STEP,STEP1(98),STEP2(98),STEP3(98)
      COMMON/INTRG/NSTATN(95),IRING(95,20)
      COMMON/ALOFIT/INDSIG,II,ITOT,J,I,IBOUND,IPT,IRIGID,ISEG,I5I,KRING,
     1NWALL,NLTYPE,NRINGS,DSTOT,SEND,IPOS,IEND,IENDS,IMAX,ITOTL,LINTYP
      INDSIG = 0
      ERR = 0.001
C     IF (INDIC.EQ.0.OR.INDIC.EQ.3.OR.INDIC.EQ.4) IBOUND = 0
      IF (INDIC.NE.1.AND.INDIC.NE.2.AND.INDIC.NE.4) NVEC = 1
      IF (INCR.EQ.0) INCR = 1
      IF (INCRB.EQ.0) INCRB = 1
      IF (INDIC.EQ.-1) DF = 1.0
      IF (INDIC.GT.1.AND.TEMP.EQ.0.0) TEMP = 1.
      RHOM = FMAX
      RHO = FSTART - DF
      STEPM = DF
      STEPMI = DF
      IF (INDIC.EQ.4.AND.IPRE.EQ.1) INDSIG = 1
C     PRINT OUT SOME OF ABOVE INPUT DATA
      CALL OUTIN1(IPRE,INDIC,ISTRES,NCOND,NLAST,NPRT,P,NSEG,STEP,NVEC,
     1IBOUND)
      IF (INDSIG.EQ.1) INDIC = 3
      NHARM = IABS(NMAX-NMIN)/IABS(INCR) + 1
      RETURN
      END
C=DECK      RFIRST1
      SUBROUTINE RFIRST1
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C
C    PURPOSE IS TO INITIALIZE CERTAIN VARIABLES...
C
      COMMON/FICTP/IFICT
      COMMON/NOHARM/NHARM
      COMMON/INSTAB/INDIC
      COMMON/ALLRNG/NTOT,IPRE
      COMMON/WAVES/N0,NNN,NMIN,NMAX,INCR
      COMMON/GLOBAL/IDZ,IZRING(98),ISAVE(20),INOTE
      COMMON/INTRG/NSTATN(95),IRING(95,20)
      COMMON/ALOFIT/INDSIG,II,ITOT,M,N,IBOUND,IPT,IRIGID,ISEG,I5I,KRING,
     1NWALL,NLTYPE,NRINGS,DSTOT,SEND,IPOS,IEND,IENDS,IMAX,ITOTL,LINTYP
C  FOLLOWING STATEMENTS ADDED 17 AUG. 1985, FOR DYNAMIC REACTION...
       COMMON/DYNAM/FX(2),FY(2),FZ(2),MX(2),MY(2),MZ(2),
     1              ICM,IZ,MM,ZCM,IDYN(2)
       REAL MX,MY,MZ,ICM,IZ,MM
       COMMON/IRNGZ/ KRNG
      DO 5 I = 1,2
       FX(I) = 0.
       FY(I) = 0.
       FZ(I) = 0.
       MX(I) = 0.
       MY(I) = 0.
       MZ(I) = 0.
       IDYN(I)=0
    5 CONTINUE
       ICM = 0.
       IZ = 0.
       MM = 0.
       ZCM = 0.
C  END OF STATEMENTS ADDED ON 17 AUG. 1985 FOR DYNAMIC REACTION.
      IFICT = 1
      DO 10 I=1,95
      NSTATN(I) = 0
      DO 10 J=1,20
10    IRING(I,J) = 0
      SEND = 0.0
      KRING = 0
      ITOT = 1
      NHARM = IABS(NMAX-NMIN)/IABS(INCR) + 1
      IEND = 0
      ITOTL = 0
      INOTE = 1
      IF (INDIC.NE.4) IPRE = 1
      RETURN
      END
C=DECK      WRCON
      SUBROUTINE WRCON(NCOND,IFIX,D1,D2)
C+---------------------------------------------------------------------+
C+---------------------------------------------------------------------+
C     CALLED FROM OUTIN1, WHOSE TRACE IS READIT,MAIN
C     PROVIDES FORMAT TO WRITE OUT CONSTRAINT CONDITIONS
      COMMON/PRMOUT/IFILE3,IFILE4
      DIMENSION IFIX(98,6),D1(98),D2(98)
      WRITE (IFILE4,10)
10    FORMAT(128H SEG. POINT CONNECTED TO SEG. POINT     USTAR VSTAR WST.
     1AR BETA     RADIAL DISC. D1(I)   AXIAL DISC. D2(I)                .
     1      //)                                                               .
      DO 30 I=1,NCOND
      J1 = IFIX(I,1)/1000
      J2 = IFIX(I,2)/1000
      J3 = IFIX(I,1) -J1*1000
      J4 = IFIX(I,2) -J2*1000
      WRITE (IFILE4,20)J1,J3,J2,J4,IFIX(I,3),IFIX(I,4),IFIX(I,5),
     1 IFIX(I,6),D1(I),D2(I)
20    FORMAT( I4,I6, I18,I6,I9,I6,I6,I6,1P2E20.8)                       .
30    CONTINUE
      RETURN
      END
